
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Requirement
 * 
 */
export type Requirement = $Result.DefaultSelection<Prisma.$RequirementPayload>
/**
 * Model JobRole
 * 
 */
export type JobRole = $Result.DefaultSelection<Prisma.$JobRolePayload>
/**
 * Model LabourProfile
 * 
 */
export type LabourProfile = $Result.DefaultSelection<Prisma.$LabourProfilePayload>
/**
 * Model Procedure
 * 
 */
export type Procedure = $Result.DefaultSelection<Prisma.$ProcedurePayload>
/**
 * Model LabourStatusLog
 * 
 */
export type LabourStatusLog = $Result.DefaultSelection<Prisma.$LabourStatusLogPayload>
/**
 * Model ClientDocument
 * 
 */
export type ClientDocument = $Result.DefaultSelection<Prisma.$ClientDocumentPayload>
/**
 * Model AgencyDocument
 * 
 */
export type AgencyDocument = $Result.DefaultSelection<Prisma.$AgencyDocumentPayload>
/**
 * Model RequirementDocument
 * 
 */
export type RequirementDocument = $Result.DefaultSelection<Prisma.$RequirementDocumentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  RECRUITMENT_ADMIN: 'RECRUITMENT_ADMIN',
  CLIENT_ADMIN: 'CLIENT_ADMIN',
  RECRUITMENT_AGENCY: 'RECRUITMENT_AGENCY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountStatus: {
  PENDING_REVIEW: 'PENDING_REVIEW',
  SUBMITTED: 'SUBMITTED',
  PENDING_SUBMISSION: 'PENDING_SUBMISSION',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  NOT_VERIFIED: 'NOT_VERIFIED',
  SUSPENDED: 'SUSPENDED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const RequirementStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  FULFILLED: 'FULFILLED',
  CLOSED: 'CLOSED'
};

export type RequirementStatus = (typeof RequirementStatus)[keyof typeof RequirementStatus]


export const LabourProfileStatus: {
  RECEIVED: 'RECEIVED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SHORTLISTED: 'SHORTLISTED',
  DEPLOYED: 'DEPLOYED',
  QVC_PROCESS: 'QVC_PROCESS',
  MEDICAL_PROCESS: 'MEDICAL_PROCESS',
  VISA_PROCESS: 'VISA_PROCESS',
  READY_FOR_DEPLOYMENT: 'READY_FOR_DEPLOYMENT'
};

export type LabourProfileStatus = (typeof LabourProfileStatus)[keyof typeof LabourProfileStatus]


export const DocumentType: {
  LICENSE: 'LICENSE',
  INSURANCE: 'INSURANCE',
  ID_PROOF: 'ID_PROOF',
  ADDRESS_PROOF: 'ADDRESS_PROOF',
  COMPANY_REGISTRATION: 'COMPANY_REGISTRATION',
  PASSPORT: 'PASSPORT',
  CV: 'CV',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const CompanySector: {
  IT: 'IT',
  REAL_ESTATE: 'REAL_ESTATE',
  HEALTHCARE: 'HEALTHCARE',
  FINANCE: 'FINANCE',
  MANUFACTURING: 'MANUFACTURING',
  RETAIL: 'RETAIL',
  CONSTRUCTION: 'CONSTRUCTION',
  EDUCATION: 'EDUCATION',
  HOSPITALITY: 'HOSPITALITY',
  OIL_GAS: 'OIL_GAS',
  TRANSPORTATION: 'TRANSPORTATION',
  OTHER: 'OTHER'
};

export type CompanySector = (typeof CompanySector)[keyof typeof CompanySector]


export const CompanySize: {
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  ENTERPRISE: 'ENTERPRISE'
};

export type CompanySize = (typeof CompanySize)[keyof typeof CompanySize]


export const ContractDuration: {
  ONE_YEAR: 'ONE_YEAR',
  TWO_YEARS: 'TWO_YEARS',
  THREE_YEARS: 'THREE_YEARS',
  UNLIMITED: 'UNLIMITED'
};

export type ContractDuration = (typeof ContractDuration)[keyof typeof ContractDuration]


export const TicketType: {
  ONE_WAY: 'ONE_WAY',
  TWO_WAY: 'TWO_WAY',
  NONE: 'NONE'
};

export type TicketType = (typeof TicketType)[keyof typeof TicketType]


export const ExperienceLevel: {
  FRESH: 'FRESH',
  ONE_YEAR: 'ONE_YEAR',
  TWO_YEARS: 'TWO_YEARS',
  THREE_YEARS: 'THREE_YEARS',
  FOUR_YEARS: 'FOUR_YEARS',
  FIVE_PLUS_YEARS: 'FIVE_PLUS_YEARS'
};

export type ExperienceLevel = (typeof ExperienceLevel)[keyof typeof ExperienceLevel]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const AuditAction: {
  USER_CREATED: 'USER_CREATED',
  USER_UPDATED: 'USER_UPDATED',
  USER_DELETED: 'USER_DELETED',
  USER_STATUS_CHANGED: 'USER_STATUS_CHANGED',
  USER_PASSWORD_RESET: 'USER_PASSWORD_RESET',
  CLIENT_CREATED: 'CLIENT_CREATED',
  CLIENT_UPDATED: 'CLIENT_UPDATED',
  CLIENT_VERIFIED: 'CLIENT_VERIFIED',
  CLIENT_REJECTED: 'CLIENT_REJECTED',
  AGENCY_CREATED: 'AGENCY_CREATED',
  AGENCY_UPDATED: 'AGENCY_UPDATED',
  AGENCY_VERIFIED: 'AGENCY_VERIFIED',
  AGENCY_REJECTED: 'AGENCY_REJECTED',
  AGENCY_DELETION_REQUESTED: 'AGENCY_DELETION_REQUESTED',
  REQUIREMENT_CREATED: 'REQUIREMENT_CREATED',
  REQUIREMENT_UPDATED: 'REQUIREMENT_UPDATED',
  REQUIREMENT_DELETE: 'REQUIREMENT_DELETE',
  REQUIREMENT_REJECTED: 'REQUIREMENT_REJECTED',
  REQUIREMENT_STATUS_CHANGED: 'REQUIREMENT_STATUS_CHANGED',
  REQUIREMENT_ASSIGNED: 'REQUIREMENT_ASSIGNED',
  DRAFT_CREATED: 'DRAFT_CREATED',
  DRAFT_UPDATED: 'DRAFT_UPDATED',
  LABOUR_PROFILE_CREATED: 'LABOUR_PROFILE_CREATED',
  LABOUR_PROFILE_UPDATED: 'LABOUR_PROFILE_UPDATED',
  LABOUR_STATUS_CHANGED: 'LABOUR_STATUS_CHANGED',
  DOCUMENT_UPLOADED: 'DOCUMENT_UPLOADED',
  DOCUMENT_VERIFIED: 'DOCUMENT_VERIFIED',
  DOCUMENT_REJECTED: 'DOCUMENT_REJECTED',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  ACCOUNT_RECOVERY: 'ACCOUNT_RECOVERY'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const ProcedureStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type ProcedureStatus = (typeof ProcedureStatus)[keyof typeof ProcedureStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  REQUIREMENT: 'REQUIREMENT',
  LABOUR: 'LABOUR',
  DOCUMENT: 'DOCUMENT',
  ACCOUNT: 'ACCOUNT',
  GENERAL: 'GENERAL'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const DeletionType: {
  SCHEDULED: 'SCHEDULED',
  IMMEDIATE: 'IMMEDIATE'
};

export type DeletionType = (typeof DeletionType)[keyof typeof DeletionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type RequirementStatus = $Enums.RequirementStatus

export const RequirementStatus: typeof $Enums.RequirementStatus

export type LabourProfileStatus = $Enums.LabourProfileStatus

export const LabourProfileStatus: typeof $Enums.LabourProfileStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type CompanySector = $Enums.CompanySector

export const CompanySector: typeof $Enums.CompanySector

export type CompanySize = $Enums.CompanySize

export const CompanySize: typeof $Enums.CompanySize

export type ContractDuration = $Enums.ContractDuration

export const ContractDuration: typeof $Enums.ContractDuration

export type TicketType = $Enums.TicketType

export const TicketType: typeof $Enums.TicketType

export type ExperienceLevel = $Enums.ExperienceLevel

export const ExperienceLevel: typeof $Enums.ExperienceLevel

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type ProcedureStatus = $Enums.ProcedureStatus

export const ProcedureStatus: typeof $Enums.ProcedureStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type DeletionType = $Enums.DeletionType

export const DeletionType: typeof $Enums.DeletionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirement.findMany()
    * ```
    */
  get requirement(): Prisma.RequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRole`: Exposes CRUD operations for the **JobRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRoles
    * const jobRoles = await prisma.jobRole.findMany()
    * ```
    */
  get jobRole(): Prisma.JobRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourProfile`: Exposes CRUD operations for the **LabourProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourProfiles
    * const labourProfiles = await prisma.labourProfile.findMany()
    * ```
    */
  get labourProfile(): Prisma.LabourProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procedure`: Exposes CRUD operations for the **Procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedures
    * const procedures = await prisma.procedure.findMany()
    * ```
    */
  get procedure(): Prisma.ProcedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourStatusLog`: Exposes CRUD operations for the **LabourStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourStatusLogs
    * const labourStatusLogs = await prisma.labourStatusLog.findMany()
    * ```
    */
  get labourStatusLog(): Prisma.LabourStatusLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientDocument`: Exposes CRUD operations for the **ClientDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientDocuments
    * const clientDocuments = await prisma.clientDocument.findMany()
    * ```
    */
  get clientDocument(): Prisma.ClientDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencyDocument`: Exposes CRUD operations for the **AgencyDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyDocuments
    * const agencyDocuments = await prisma.agencyDocument.findMany()
    * ```
    */
  get agencyDocument(): Prisma.AgencyDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirementDocument`: Exposes CRUD operations for the **RequirementDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequirementDocuments
    * const requirementDocuments = await prisma.requirementDocument.findMany()
    * ```
    */
  get requirementDocument(): Prisma.RequirementDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Agency: 'Agency',
    Admin: 'Admin',
    Requirement: 'Requirement',
    JobRole: 'JobRole',
    LabourProfile: 'LabourProfile',
    Procedure: 'Procedure',
    LabourStatusLog: 'LabourStatusLog',
    ClientDocument: 'ClientDocument',
    AgencyDocument: 'AgencyDocument',
    RequirementDocument: 'RequirementDocument',
    AuditLog: 'AuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "agency" | "admin" | "requirement" | "jobRole" | "labourProfile" | "procedure" | "labourStatusLog" | "clientDocument" | "agencyDocument" | "requirementDocument" | "auditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Requirement: {
        payload: Prisma.$RequirementPayload<ExtArgs>
        fields: Prisma.RequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findFirst: {
            args: Prisma.RequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findMany: {
            args: Prisma.RequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          create: {
            args: Prisma.RequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          createMany: {
            args: Prisma.RequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          delete: {
            args: Prisma.RequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          update: {
            args: Prisma.RequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          deleteMany: {
            args: Prisma.RequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          upsert: {
            args: Prisma.RequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          aggregate: {
            args: Prisma.RequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirement>
          }
          groupBy: {
            args: Prisma.RequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementCountAggregateOutputType> | number
          }
        }
      }
      JobRole: {
        payload: Prisma.$JobRolePayload<ExtArgs>
        fields: Prisma.JobRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          findFirst: {
            args: Prisma.JobRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          findMany: {
            args: Prisma.JobRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          create: {
            args: Prisma.JobRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          createMany: {
            args: Prisma.JobRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          delete: {
            args: Prisma.JobRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          update: {
            args: Prisma.JobRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          deleteMany: {
            args: Prisma.JobRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          upsert: {
            args: Prisma.JobRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          aggregate: {
            args: Prisma.JobRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRole>
          }
          groupBy: {
            args: Prisma.JobRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRoleCountArgs<ExtArgs>
            result: $Utils.Optional<JobRoleCountAggregateOutputType> | number
          }
        }
      }
      LabourProfile: {
        payload: Prisma.$LabourProfilePayload<ExtArgs>
        fields: Prisma.LabourProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          findFirst: {
            args: Prisma.LabourProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          findMany: {
            args: Prisma.LabourProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          create: {
            args: Prisma.LabourProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          createMany: {
            args: Prisma.LabourProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          delete: {
            args: Prisma.LabourProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          update: {
            args: Prisma.LabourProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          deleteMany: {
            args: Prisma.LabourProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          upsert: {
            args: Prisma.LabourProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          aggregate: {
            args: Prisma.LabourProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourProfile>
          }
          groupBy: {
            args: Prisma.LabourProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LabourProfileCountAggregateOutputType> | number
          }
        }
      }
      Procedure: {
        payload: Prisma.$ProcedurePayload<ExtArgs>
        fields: Prisma.ProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findFirst: {
            args: Prisma.ProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findMany: {
            args: Prisma.ProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          create: {
            args: Prisma.ProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          createMany: {
            args: Prisma.ProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          delete: {
            args: Prisma.ProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          update: {
            args: Prisma.ProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          upsert: {
            args: Prisma.ProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          aggregate: {
            args: Prisma.ProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedure>
          }
          groupBy: {
            args: Prisma.ProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureCountAggregateOutputType> | number
          }
        }
      }
      LabourStatusLog: {
        payload: Prisma.$LabourStatusLogPayload<ExtArgs>
        fields: Prisma.LabourStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          findFirst: {
            args: Prisma.LabourStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          findMany: {
            args: Prisma.LabourStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>[]
          }
          create: {
            args: Prisma.LabourStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          createMany: {
            args: Prisma.LabourStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>[]
          }
          delete: {
            args: Prisma.LabourStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          update: {
            args: Prisma.LabourStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.LabourStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourStatusLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>[]
          }
          upsert: {
            args: Prisma.LabourStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStatusLogPayload>
          }
          aggregate: {
            args: Prisma.LabourStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourStatusLog>
          }
          groupBy: {
            args: Prisma.LabourStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<LabourStatusLogCountAggregateOutputType> | number
          }
        }
      }
      ClientDocument: {
        payload: Prisma.$ClientDocumentPayload<ExtArgs>
        fields: Prisma.ClientDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          findFirst: {
            args: Prisma.ClientDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          findMany: {
            args: Prisma.ClientDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>[]
          }
          create: {
            args: Prisma.ClientDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          createMany: {
            args: Prisma.ClientDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>[]
          }
          delete: {
            args: Prisma.ClientDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          update: {
            args: Prisma.ClientDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ClientDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ClientDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDocumentPayload>
          }
          aggregate: {
            args: Prisma.ClientDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientDocument>
          }
          groupBy: {
            args: Prisma.ClientDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ClientDocumentCountAggregateOutputType> | number
          }
        }
      }
      AgencyDocument: {
        payload: Prisma.$AgencyDocumentPayload<ExtArgs>
        fields: Prisma.AgencyDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          findFirst: {
            args: Prisma.AgencyDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          findMany: {
            args: Prisma.AgencyDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>[]
          }
          create: {
            args: Prisma.AgencyDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          createMany: {
            args: Prisma.AgencyDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>[]
          }
          delete: {
            args: Prisma.AgencyDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          update: {
            args: Prisma.AgencyDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>[]
          }
          upsert: {
            args: Prisma.AgencyDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyDocumentPayload>
          }
          aggregate: {
            args: Prisma.AgencyDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyDocument>
          }
          groupBy: {
            args: Prisma.AgencyDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyDocumentCountAggregateOutputType> | number
          }
        }
      }
      RequirementDocument: {
        payload: Prisma.$RequirementDocumentPayload<ExtArgs>
        fields: Prisma.RequirementDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          findFirst: {
            args: Prisma.RequirementDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          findMany: {
            args: Prisma.RequirementDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>[]
          }
          create: {
            args: Prisma.RequirementDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          createMany: {
            args: Prisma.RequirementDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>[]
          }
          delete: {
            args: Prisma.RequirementDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          update: {
            args: Prisma.RequirementDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          deleteMany: {
            args: Prisma.RequirementDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>[]
          }
          upsert: {
            args: Prisma.RequirementDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementDocumentPayload>
          }
          aggregate: {
            args: Prisma.RequirementDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirementDocument>
          }
          groupBy: {
            args: Prisma.RequirementDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementDocumentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    agency?: AgencyOmit
    admin?: AdminOmit
    requirement?: RequirementOmit
    jobRole?: JobRoleOmit
    labourProfile?: LabourProfileOmit
    procedure?: ProcedureOmit
    labourStatusLog?: LabourStatusLogOmit
    clientDocument?: ClientDocumentOmit
    agencyDocument?: AgencyDocumentOmit
    requirementDocument?: RequirementDocumentOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    auditLogs: number
    notifications: number
    statusLogs: number
    clientDocuments: number
    agencyDocuments: number
    requirementDocuments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    statusLogs?: boolean | UserCountOutputTypeCountStatusLogsArgs
    clientDocuments?: boolean | UserCountOutputTypeCountClientDocumentsArgs
    agencyDocuments?: boolean | UserCountOutputTypeCountAgencyDocumentsArgs
    requirementDocuments?: boolean | UserCountOutputTypeCountRequirementDocumentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourStatusLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgencyDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequirementDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementDocumentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    requirements: number
    documents: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | ClientCountOutputTypeCountRequirementsArgs
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDocumentWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    labourProfiles: number
    requirements: number
    documents: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labourProfiles?: boolean | AgencyCountOutputTypeCountLabourProfilesArgs
    requirements?: boolean | AgencyCountOutputTypeCountRequirementsArgs
    documents?: boolean | AgencyCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountLabourProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyDocumentWhereInput
  }


  /**
   * Count Type RequirementCountOutputType
   */

  export type RequirementCountOutputType = {
    jobRoles: number
    labourProfiles: number
    procedures: number
    documents: number
  }

  export type RequirementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRoles?: boolean | RequirementCountOutputTypeCountJobRolesArgs
    labourProfiles?: boolean | RequirementCountOutputTypeCountLabourProfilesArgs
    procedures?: boolean | RequirementCountOutputTypeCountProceduresArgs
    documents?: boolean | RequirementCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementCountOutputType
     */
    select?: RequirementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountJobRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountLabourProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementDocumentWhereInput
  }


  /**
   * Count Type LabourProfileCountOutputType
   */

  export type LabourProfileCountOutputType = {
    statusLogs: number
    procedures: number
  }

  export type LabourProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusLogs?: boolean | LabourProfileCountOutputTypeCountStatusLogsArgs
    procedures?: boolean | LabourProfileCountOutputTypeCountProceduresArgs
  }

  // Custom InputTypes
  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfileCountOutputType
     */
    select?: LabourProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourStatusLogWhereInput
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    resetRequired: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    resetRequired: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    phone: number
    altContact: number
    profilePicture: number
    role: number
    status: number
    resetRequired: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    deleteAt: number
    deletionType: number
    deletionReason: number
    deletionRequestedBy: number
    createdById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole
    status: $Enums.AccountStatus
    resetRequired: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    agencyProfile?: boolean | User$agencyProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    statusLogs?: boolean | User$statusLogsArgs<ExtArgs>
    clientDocuments?: boolean | User$clientDocumentsArgs<ExtArgs>
    agencyDocuments?: boolean | User$agencyDocumentsArgs<ExtArgs>
    requirementDocuments?: boolean | User$requirementDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "phone" | "altContact" | "profilePicture" | "role" | "status" | "resetRequired" | "lastLogin" | "createdAt" | "updatedAt" | "deleteAt" | "deletionType" | "deletionReason" | "deletionRequestedBy" | "createdById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    agencyProfile?: boolean | User$agencyProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    statusLogs?: boolean | User$statusLogsArgs<ExtArgs>
    clientDocuments?: boolean | User$clientDocumentsArgs<ExtArgs>
    agencyDocuments?: boolean | User$agencyDocumentsArgs<ExtArgs>
    requirementDocuments?: boolean | User$requirementDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientProfile: Prisma.$ClientPayload<ExtArgs> | null
      agencyProfile: Prisma.$AgencyPayload<ExtArgs> | null
      adminProfile: Prisma.$AdminPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      statusLogs: Prisma.$LabourStatusLogPayload<ExtArgs>[]
      clientDocuments: Prisma.$ClientDocumentPayload<ExtArgs>[]
      agencyDocuments: Prisma.$AgencyDocumentPayload<ExtArgs>[]
      requirementDocuments: Prisma.$RequirementDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      phone: string | null
      altContact: string | null
      profilePicture: string | null
      role: $Enums.UserRole
      status: $Enums.AccountStatus
      resetRequired: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      deleteAt: Date | null
      deletionType: $Enums.DeletionType | null
      deletionReason: string | null
      deletionRequestedBy: string | null
      createdById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyProfile<T extends User$agencyProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyProfileArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusLogs<T extends User$statusLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$statusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientDocuments<T extends User$clientDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencyDocuments<T extends User$agencyDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirementDocuments<T extends User$requirementDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$requirementDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly altContact: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'AccountStatus'>
    readonly resetRequired: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deleteAt: FieldRef<"User", 'DateTime'>
    readonly deletionType: FieldRef<"User", 'DeletionType'>
    readonly deletionReason: FieldRef<"User", 'String'>
    readonly deletionRequestedBy: FieldRef<"User", 'String'>
    readonly createdById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.agencyProfile
   */
  export type User$agencyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.statusLogs
   */
  export type User$statusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    where?: LabourStatusLogWhereInput
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    cursor?: LabourStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourStatusLogScalarFieldEnum | LabourStatusLogScalarFieldEnum[]
  }

  /**
   * User.clientDocuments
   */
  export type User$clientDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    where?: ClientDocumentWhereInput
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    cursor?: ClientDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientDocumentScalarFieldEnum | ClientDocumentScalarFieldEnum[]
  }

  /**
   * User.agencyDocuments
   */
  export type User$agencyDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    where?: AgencyDocumentWhereInput
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    cursor?: AgencyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyDocumentScalarFieldEnum | AgencyDocumentScalarFieldEnum[]
  }

  /**
   * User.requirementDocuments
   */
  export type User$requirementDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    where?: RequirementDocumentWhereInput
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    cursor?: RequirementDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementDocumentScalarFieldEnum | RequirementDocumentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    registrationNo: string | null
    companySector: $Enums.CompanySector | null
    companySize: $Enums.CompanySize | null
    website: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    registrationNo: string | null
    companySector: $Enums.CompanySector | null
    companySize: $Enums.CompanySize | null
    website: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    registrationNo: number
    companySector: number
    companySize: number
    website: number
    address: number
    city: number
    country: number
    postalCode: number
    designation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string
    companyName: string
    registrationNo: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website: string | null
    address: string
    city: string
    country: string
    postalCode: string | null
    designation: string
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    requirements?: boolean | Client$requirementsArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "registrationNo" | "companySector" | "companySize" | "website" | "address" | "city" | "country" | "postalCode" | "designation" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    requirements?: boolean | Client$requirementsArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      requirements: Prisma.$RequirementPayload<ExtArgs>[]
      documents: Prisma.$ClientDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string
      registrationNo: string | null
      companySector: $Enums.CompanySector
      companySize: $Enums.CompanySize
      website: string | null
      address: string
      city: string
      country: string
      postalCode: string | null
      designation: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirements<T extends Client$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Client$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly registrationNo: FieldRef<"Client", 'String'>
    readonly companySector: FieldRef<"Client", 'CompanySector'>
    readonly companySize: FieldRef<"Client", 'CompanySize'>
    readonly website: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly postalCode: FieldRef<"Client", 'String'>
    readonly designation: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.requirements
   */
  export type Client$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    where?: ClientDocumentWhereInput
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    cursor?: ClientDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientDocumentScalarFieldEnum | ClientDocumentScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyName: string | null
    registrationNo: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    country: string | null
    website: string | null
    address: string | null
    city: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyName: string | null
    registrationNo: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    country: string | null
    website: string | null
    address: string | null
    city: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    userId: number
    agencyName: number
    registrationNo: number
    licenseNumber: number
    licenseExpiry: number
    country: number
    website: number
    address: number
    city: number
    postalCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyMinAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    userId: string
    agencyName: string
    registrationNo: string | null
    licenseNumber: string
    licenseExpiry: Date
    country: string
    website: string | null
    address: string
    city: string
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    labourProfiles?: boolean | Agency$labourProfilesArgs<ExtArgs>
    requirements?: boolean | Agency$requirementsArgs<ExtArgs>
    documents?: boolean | Agency$documentsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agencyName" | "registrationNo" | "licenseNumber" | "licenseExpiry" | "country" | "website" | "address" | "city" | "postalCode" | "createdAt" | "updatedAt", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    labourProfiles?: boolean | Agency$labourProfilesArgs<ExtArgs>
    requirements?: boolean | Agency$requirementsArgs<ExtArgs>
    documents?: boolean | Agency$documentsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      labourProfiles: Prisma.$LabourProfilePayload<ExtArgs>[]
      requirements: Prisma.$RequirementPayload<ExtArgs>[]
      documents: Prisma.$AgencyDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agencyName: string
      registrationNo: string | null
      licenseNumber: string
      licenseExpiry: Date
      country: string
      website: string | null
      address: string
      city: string
      postalCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labourProfiles<T extends Agency$labourProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Agency$labourProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirements<T extends Agency$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Agency$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly userId: FieldRef<"Agency", 'String'>
    readonly agencyName: FieldRef<"Agency", 'String'>
    readonly registrationNo: FieldRef<"Agency", 'String'>
    readonly licenseNumber: FieldRef<"Agency", 'String'>
    readonly licenseExpiry: FieldRef<"Agency", 'DateTime'>
    readonly country: FieldRef<"Agency", 'String'>
    readonly website: FieldRef<"Agency", 'String'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly city: FieldRef<"Agency", 'String'>
    readonly postalCode: FieldRef<"Agency", 'String'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.labourProfiles
   */
  export type Agency$labourProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    cursor?: LabourProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * Agency.requirements
   */
  export type Agency$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Agency.documents
   */
  export type Agency$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    where?: AgencyDocumentWhereInput
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    cursor?: AgencyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyDocumentScalarFieldEnum | AgencyDocumentScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    department: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    name: string
    department: string | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "department" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      department: string | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly department: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'Json'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Requirement
   */

  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null
    _avg: RequirementAvgAggregateOutputType | null
    _sum: RequirementSumAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  export type RequirementAvgAggregateOutputType = {
    maxAge: number | null
  }

  export type RequirementSumAggregateOutputType = {
    maxAge: number | null
  }

  export type RequirementMinAggregateOutputType = {
    id: string | null
    specialNotes: string | null
    status: $Enums.RequirementStatus | null
    minExperience: $Enums.ExperienceLevel | null
    maxAge: number | null
    ticketType: $Enums.TicketType | null
    ticketProvided: boolean | null
    clientId: string | null
    assignedAgencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    submittedAt: Date | null
    reviewedAt: Date | null
  }

  export type RequirementMaxAggregateOutputType = {
    id: string | null
    specialNotes: string | null
    status: $Enums.RequirementStatus | null
    minExperience: $Enums.ExperienceLevel | null
    maxAge: number | null
    ticketType: $Enums.TicketType | null
    ticketProvided: boolean | null
    clientId: string | null
    assignedAgencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    submittedAt: Date | null
    reviewedAt: Date | null
  }

  export type RequirementCountAggregateOutputType = {
    id: number
    specialNotes: number
    status: number
    languages: number
    minExperience: number
    maxAge: number
    ticketType: number
    ticketProvided: number
    clientId: number
    assignedAgencyId: number
    createdAt: number
    updatedAt: number
    submittedAt: number
    reviewedAt: number
    _all: number
  }


  export type RequirementAvgAggregateInputType = {
    maxAge?: true
  }

  export type RequirementSumAggregateInputType = {
    maxAge?: true
  }

  export type RequirementMinAggregateInputType = {
    id?: true
    specialNotes?: true
    status?: true
    minExperience?: true
    maxAge?: true
    ticketType?: true
    ticketProvided?: true
    clientId?: true
    assignedAgencyId?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    reviewedAt?: true
  }

  export type RequirementMaxAggregateInputType = {
    id?: true
    specialNotes?: true
    status?: true
    minExperience?: true
    maxAge?: true
    ticketType?: true
    ticketProvided?: true
    clientId?: true
    assignedAgencyId?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    reviewedAt?: true
  }

  export type RequirementCountAggregateInputType = {
    id?: true
    specialNotes?: true
    status?: true
    languages?: true
    minExperience?: true
    maxAge?: true
    ticketType?: true
    ticketProvided?: true
    clientId?: true
    assignedAgencyId?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    reviewedAt?: true
    _all?: true
  }

  export type RequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirement to aggregate.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requirements
    **/
    _count?: true | RequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementMaxAggregateInputType
  }

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement[P]>
      : GetScalarType<T[P], AggregateRequirement[P]>
  }




  export type RequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithAggregationInput | RequirementOrderByWithAggregationInput[]
    by: RequirementScalarFieldEnum[] | RequirementScalarFieldEnum
    having?: RequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementCountAggregateInputType | true
    _avg?: RequirementAvgAggregateInputType
    _sum?: RequirementSumAggregateInputType
    _min?: RequirementMinAggregateInputType
    _max?: RequirementMaxAggregateInputType
  }

  export type RequirementGroupByOutputType = {
    id: string
    specialNotes: string | null
    status: $Enums.RequirementStatus
    languages: string[]
    minExperience: $Enums.ExperienceLevel | null
    maxAge: number | null
    ticketType: $Enums.TicketType | null
    ticketProvided: boolean
    clientId: string
    assignedAgencyId: string | null
    createdAt: Date
    updatedAt: Date
    submittedAt: Date | null
    reviewedAt: Date | null
    _count: RequirementCountAggregateOutputType | null
    _avg: RequirementAvgAggregateOutputType | null
    _sum: RequirementSumAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>
        }
      >
    >


  export type RequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialNotes?: boolean
    status?: boolean
    languages?: boolean
    minExperience?: boolean
    maxAge?: boolean
    ticketType?: boolean
    ticketProvided?: boolean
    clientId?: boolean
    assignedAgencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
    jobRoles?: boolean | Requirement$jobRolesArgs<ExtArgs>
    labourProfiles?: boolean | Requirement$labourProfilesArgs<ExtArgs>
    procedures?: boolean | Requirement$proceduresArgs<ExtArgs>
    documents?: boolean | Requirement$documentsArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialNotes?: boolean
    status?: boolean
    languages?: boolean
    minExperience?: boolean
    maxAge?: boolean
    ticketType?: boolean
    ticketProvided?: boolean
    clientId?: boolean
    assignedAgencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialNotes?: boolean
    status?: boolean
    languages?: boolean
    minExperience?: boolean
    maxAge?: boolean
    ticketType?: boolean
    ticketProvided?: boolean
    clientId?: boolean
    assignedAgencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectScalar = {
    id?: boolean
    specialNotes?: boolean
    status?: boolean
    languages?: boolean
    minExperience?: boolean
    maxAge?: boolean
    ticketType?: boolean
    ticketProvided?: boolean
    clientId?: boolean
    assignedAgencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
  }

  export type RequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "specialNotes" | "status" | "languages" | "minExperience" | "maxAge" | "ticketType" | "ticketProvided" | "clientId" | "assignedAgencyId" | "createdAt" | "updatedAt" | "submittedAt" | "reviewedAt", ExtArgs["result"]["requirement"]>
  export type RequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
    jobRoles?: boolean | Requirement$jobRolesArgs<ExtArgs>
    labourProfiles?: boolean | Requirement$labourProfilesArgs<ExtArgs>
    procedures?: boolean | Requirement$proceduresArgs<ExtArgs>
    documents?: boolean | Requirement$documentsArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
  }
  export type RequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignedAgency?: boolean | Requirement$assignedAgencyArgs<ExtArgs>
  }

  export type $RequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requirement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      assignedAgency: Prisma.$AgencyPayload<ExtArgs> | null
      jobRoles: Prisma.$JobRolePayload<ExtArgs>[]
      labourProfiles: Prisma.$LabourProfilePayload<ExtArgs>[]
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
      documents: Prisma.$RequirementDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      specialNotes: string | null
      status: $Enums.RequirementStatus
      languages: string[]
      minExperience: $Enums.ExperienceLevel | null
      maxAge: number | null
      ticketType: $Enums.TicketType | null
      ticketProvided: boolean
      clientId: string
      assignedAgencyId: string | null
      createdAt: Date
      updatedAt: Date
      submittedAt: Date | null
      reviewedAt: Date | null
    }, ExtArgs["result"]["requirement"]>
    composites: {}
  }

  type RequirementGetPayload<S extends boolean | null | undefined | RequirementDefaultArgs> = $Result.GetResult<Prisma.$RequirementPayload, S>

  type RequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementCountAggregateInputType | true
    }

  export interface RequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requirement'], meta: { name: 'Requirement' } }
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementFindUniqueArgs>(args: SelectSubset<T, RequirementFindUniqueArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementFindUniqueOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementFindFirstArgs>(args?: SelectSubset<T, RequirementFindFirstArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementFindManyArgs>(args?: SelectSubset<T, RequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     * 
     */
    create<T extends RequirementCreateArgs>(args: SelectSubset<T, RequirementCreateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirements.
     * @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementCreateManyArgs>(args?: SelectSubset<T, RequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {RequirementCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     * 
     */
    delete<T extends RequirementDeleteArgs>(args: SelectSubset<T, RequirementDeleteArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementUpdateArgs>(args: SelectSubset<T, RequirementUpdateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementDeleteManyArgs>(args?: SelectSubset<T, RequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementUpdateManyArgs>(args: SelectSubset<T, RequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {RequirementUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
     */
    upsert<T extends RequirementUpsertArgs>(args: SelectSubset<T, RequirementUpsertArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAggregateArgs>(args: Subset<T, RequirementAggregateArgs>): Prisma.PrismaPromise<GetRequirementAggregateType<T>>

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requirement model
   */
  readonly fields: RequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedAgency<T extends Requirement$assignedAgencyArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$assignedAgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobRoles<T extends Requirement$jobRolesArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$jobRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labourProfiles<T extends Requirement$labourProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$labourProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    procedures<T extends Requirement$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Requirement$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requirement model
   */
  interface RequirementFieldRefs {
    readonly id: FieldRef<"Requirement", 'String'>
    readonly specialNotes: FieldRef<"Requirement", 'String'>
    readonly status: FieldRef<"Requirement", 'RequirementStatus'>
    readonly languages: FieldRef<"Requirement", 'String[]'>
    readonly minExperience: FieldRef<"Requirement", 'ExperienceLevel'>
    readonly maxAge: FieldRef<"Requirement", 'Int'>
    readonly ticketType: FieldRef<"Requirement", 'TicketType'>
    readonly ticketProvided: FieldRef<"Requirement", 'Boolean'>
    readonly clientId: FieldRef<"Requirement", 'String'>
    readonly assignedAgencyId: FieldRef<"Requirement", 'String'>
    readonly createdAt: FieldRef<"Requirement", 'DateTime'>
    readonly updatedAt: FieldRef<"Requirement", 'DateTime'>
    readonly submittedAt: FieldRef<"Requirement", 'DateTime'>
    readonly reviewedAt: FieldRef<"Requirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findUniqueOrThrow
   */
  export type RequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findFirstOrThrow
   */
  export type RequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirements to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement create
   */
  export type RequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a Requirement.
     */
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
  }

  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Requirement createManyAndReturn
   */
  export type RequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement update
   */
  export type RequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a Requirement.
     */
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
    /**
     * Choose, which Requirement to update.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
  }

  /**
   * Requirement updateManyAndReturn
   */
  export type RequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the Requirement to update in case it exists.
     */
    where: RequirementWhereUniqueInput
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     */
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
  }

  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter which Requirement to delete.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirements to delete
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to delete.
     */
    limit?: number
  }

  /**
   * Requirement.assignedAgency
   */
  export type Requirement$assignedAgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Requirement.jobRoles
   */
  export type Requirement$jobRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    where?: JobRoleWhereInput
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    cursor?: JobRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * Requirement.labourProfiles
   */
  export type Requirement$labourProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    cursor?: LabourProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * Requirement.procedures
   */
  export type Requirement$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Requirement.documents
   */
  export type Requirement$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    where?: RequirementDocumentWhereInput
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    cursor?: RequirementDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementDocumentScalarFieldEnum | RequirementDocumentScalarFieldEnum[]
  }

  /**
   * Requirement without action
   */
  export type RequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
  }


  /**
   * Model JobRole
   */

  export type AggregateJobRole = {
    _count: JobRoleCountAggregateOutputType | null
    _avg: JobRoleAvgAggregateOutputType | null
    _sum: JobRoleSumAggregateOutputType | null
    _min: JobRoleMinAggregateOutputType | null
    _max: JobRoleMaxAggregateOutputType | null
  }

  export type JobRoleAvgAggregateOutputType = {
    quantity: number | null
    salary: number | null
  }

  export type JobRoleSumAggregateOutputType = {
    quantity: number | null
    salary: number | null
  }

  export type JobRoleMinAggregateOutputType = {
    id: string | null
    title: string | null
    quantity: number | null
    nationality: string | null
    salary: number | null
    salaryCurrency: string | null
    startDate: Date | null
    contractDuration: $Enums.ContractDuration | null
    requirementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobRoleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    quantity: number | null
    nationality: string | null
    salary: number | null
    salaryCurrency: string | null
    startDate: Date | null
    contractDuration: $Enums.ContractDuration | null
    requirementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobRoleCountAggregateOutputType = {
    id: number
    title: number
    quantity: number
    nationality: number
    salary: number
    salaryCurrency: number
    startDate: number
    contractDuration: number
    requirementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobRoleAvgAggregateInputType = {
    quantity?: true
    salary?: true
  }

  export type JobRoleSumAggregateInputType = {
    quantity?: true
    salary?: true
  }

  export type JobRoleMinAggregateInputType = {
    id?: true
    title?: true
    quantity?: true
    nationality?: true
    salary?: true
    salaryCurrency?: true
    startDate?: true
    contractDuration?: true
    requirementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobRoleMaxAggregateInputType = {
    id?: true
    title?: true
    quantity?: true
    nationality?: true
    salary?: true
    salaryCurrency?: true
    startDate?: true
    contractDuration?: true
    requirementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobRoleCountAggregateInputType = {
    id?: true
    title?: true
    quantity?: true
    nationality?: true
    salary?: true
    salaryCurrency?: true
    startDate?: true
    contractDuration?: true
    requirementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRole to aggregate.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRoles
    **/
    _count?: true | JobRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRoleMaxAggregateInputType
  }

  export type GetJobRoleAggregateType<T extends JobRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRole[P]>
      : GetScalarType<T[P], AggregateJobRole[P]>
  }




  export type JobRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleWhereInput
    orderBy?: JobRoleOrderByWithAggregationInput | JobRoleOrderByWithAggregationInput[]
    by: JobRoleScalarFieldEnum[] | JobRoleScalarFieldEnum
    having?: JobRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRoleCountAggregateInputType | true
    _avg?: JobRoleAvgAggregateInputType
    _sum?: JobRoleSumAggregateInputType
    _min?: JobRoleMinAggregateInputType
    _max?: JobRoleMaxAggregateInputType
  }

  export type JobRoleGroupByOutputType = {
    id: string
    title: string
    quantity: number
    nationality: string
    salary: number | null
    salaryCurrency: string
    startDate: Date | null
    contractDuration: $Enums.ContractDuration | null
    requirementId: string
    createdAt: Date
    updatedAt: Date
    _count: JobRoleCountAggregateOutputType | null
    _avg: JobRoleAvgAggregateOutputType | null
    _sum: JobRoleSumAggregateOutputType | null
    _min: JobRoleMinAggregateOutputType | null
    _max: JobRoleMaxAggregateOutputType | null
  }

  type GetJobRoleGroupByPayload<T extends JobRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRoleGroupByOutputType[P]>
            : GetScalarType<T[P], JobRoleGroupByOutputType[P]>
        }
      >
    >


  export type JobRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    salary?: boolean
    salaryCurrency?: boolean
    startDate?: boolean
    contractDuration?: boolean
    requirementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    salary?: boolean
    salaryCurrency?: boolean
    startDate?: boolean
    contractDuration?: boolean
    requirementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    salary?: boolean
    salaryCurrency?: boolean
    startDate?: boolean
    contractDuration?: boolean
    requirementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectScalar = {
    id?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    salary?: boolean
    salaryCurrency?: boolean
    startDate?: boolean
    contractDuration?: boolean
    requirementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "quantity" | "nationality" | "salary" | "salaryCurrency" | "startDate" | "contractDuration" | "requirementId" | "createdAt" | "updatedAt", ExtArgs["result"]["jobRole"]>
  export type JobRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }
  export type JobRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }
  export type JobRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }

  export type $JobRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRole"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      quantity: number
      nationality: string
      salary: number | null
      salaryCurrency: string
      startDate: Date | null
      contractDuration: $Enums.ContractDuration | null
      requirementId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobRole"]>
    composites: {}
  }

  type JobRoleGetPayload<S extends boolean | null | undefined | JobRoleDefaultArgs> = $Result.GetResult<Prisma.$JobRolePayload, S>

  type JobRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRoleCountAggregateInputType | true
    }

  export interface JobRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRole'], meta: { name: 'JobRole' } }
    /**
     * Find zero or one JobRole that matches the filter.
     * @param {JobRoleFindUniqueArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRoleFindUniqueArgs>(args: SelectSubset<T, JobRoleFindUniqueArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRoleFindUniqueOrThrowArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindFirstArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRoleFindFirstArgs>(args?: SelectSubset<T, JobRoleFindFirstArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindFirstOrThrowArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRoles
     * const jobRoles = await prisma.jobRole.findMany()
     * 
     * // Get first 10 JobRoles
     * const jobRoles = await prisma.jobRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobRoleFindManyArgs>(args?: SelectSubset<T, JobRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRole.
     * @param {JobRoleCreateArgs} args - Arguments to create a JobRole.
     * @example
     * // Create one JobRole
     * const JobRole = await prisma.jobRole.create({
     *   data: {
     *     // ... data to create a JobRole
     *   }
     * })
     * 
     */
    create<T extends JobRoleCreateArgs>(args: SelectSubset<T, JobRoleCreateArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRoles.
     * @param {JobRoleCreateManyArgs} args - Arguments to create many JobRoles.
     * @example
     * // Create many JobRoles
     * const jobRole = await prisma.jobRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRoleCreateManyArgs>(args?: SelectSubset<T, JobRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobRoles and returns the data saved in the database.
     * @param {JobRoleCreateManyAndReturnArgs} args - Arguments to create many JobRoles.
     * @example
     * // Create many JobRoles
     * const jobRole = await prisma.jobRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobRoles and only return the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, JobRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobRole.
     * @param {JobRoleDeleteArgs} args - Arguments to delete one JobRole.
     * @example
     * // Delete one JobRole
     * const JobRole = await prisma.jobRole.delete({
     *   where: {
     *     // ... filter to delete one JobRole
     *   }
     * })
     * 
     */
    delete<T extends JobRoleDeleteArgs>(args: SelectSubset<T, JobRoleDeleteArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRole.
     * @param {JobRoleUpdateArgs} args - Arguments to update one JobRole.
     * @example
     * // Update one JobRole
     * const jobRole = await prisma.jobRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRoleUpdateArgs>(args: SelectSubset<T, JobRoleUpdateArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRoles.
     * @param {JobRoleDeleteManyArgs} args - Arguments to filter JobRoles to delete.
     * @example
     * // Delete a few JobRoles
     * const { count } = await prisma.jobRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRoleDeleteManyArgs>(args?: SelectSubset<T, JobRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRoles
     * const jobRole = await prisma.jobRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRoleUpdateManyArgs>(args: SelectSubset<T, JobRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoles and returns the data updated in the database.
     * @param {JobRoleUpdateManyAndReturnArgs} args - Arguments to update many JobRoles.
     * @example
     * // Update many JobRoles
     * const jobRole = await prisma.jobRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobRoles and only return the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, JobRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobRole.
     * @param {JobRoleUpsertArgs} args - Arguments to update or create a JobRole.
     * @example
     * // Update or create a JobRole
     * const jobRole = await prisma.jobRole.upsert({
     *   create: {
     *     // ... data to create a JobRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRole we want to update
     *   }
     * })
     */
    upsert<T extends JobRoleUpsertArgs>(args: SelectSubset<T, JobRoleUpsertArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleCountArgs} args - Arguments to filter JobRoles to count.
     * @example
     * // Count the number of JobRoles
     * const count = await prisma.jobRole.count({
     *   where: {
     *     // ... the filter for the JobRoles we want to count
     *   }
     * })
    **/
    count<T extends JobRoleCountArgs>(
      args?: Subset<T, JobRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRoleAggregateArgs>(args: Subset<T, JobRoleAggregateArgs>): Prisma.PrismaPromise<GetJobRoleAggregateType<T>>

    /**
     * Group by JobRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRoleGroupByArgs['orderBy'] }
        : { orderBy?: JobRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRole model
   */
  readonly fields: JobRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRole model
   */
  interface JobRoleFieldRefs {
    readonly id: FieldRef<"JobRole", 'String'>
    readonly title: FieldRef<"JobRole", 'String'>
    readonly quantity: FieldRef<"JobRole", 'Int'>
    readonly nationality: FieldRef<"JobRole", 'String'>
    readonly salary: FieldRef<"JobRole", 'Float'>
    readonly salaryCurrency: FieldRef<"JobRole", 'String'>
    readonly startDate: FieldRef<"JobRole", 'DateTime'>
    readonly contractDuration: FieldRef<"JobRole", 'ContractDuration'>
    readonly requirementId: FieldRef<"JobRole", 'String'>
    readonly createdAt: FieldRef<"JobRole", 'DateTime'>
    readonly updatedAt: FieldRef<"JobRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobRole findUnique
   */
  export type JobRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole findUniqueOrThrow
   */
  export type JobRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole findFirst
   */
  export type JobRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoles.
     */
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole findFirstOrThrow
   */
  export type JobRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoles.
     */
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole findMany
   */
  export type JobRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRoles to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole create
   */
  export type JobRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a JobRole.
     */
    data: XOR<JobRoleCreateInput, JobRoleUncheckedCreateInput>
  }

  /**
   * JobRole createMany
   */
  export type JobRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRoles.
     */
    data: JobRoleCreateManyInput | JobRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRole createManyAndReturn
   */
  export type JobRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * The data used to create many JobRoles.
     */
    data: JobRoleCreateManyInput | JobRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRole update
   */
  export type JobRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a JobRole.
     */
    data: XOR<JobRoleUpdateInput, JobRoleUncheckedUpdateInput>
    /**
     * Choose, which JobRole to update.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole updateMany
   */
  export type JobRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRoles.
     */
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyInput>
    /**
     * Filter which JobRoles to update
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to update.
     */
    limit?: number
  }

  /**
   * JobRole updateManyAndReturn
   */
  export type JobRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * The data used to update JobRoles.
     */
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyInput>
    /**
     * Filter which JobRoles to update
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRole upsert
   */
  export type JobRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the JobRole to update in case it exists.
     */
    where: JobRoleWhereUniqueInput
    /**
     * In case the JobRole found by the `where` argument doesn't exist, create a new JobRole with this data.
     */
    create: XOR<JobRoleCreateInput, JobRoleUncheckedCreateInput>
    /**
     * In case the JobRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRoleUpdateInput, JobRoleUncheckedUpdateInput>
  }

  /**
   * JobRole delete
   */
  export type JobRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter which JobRole to delete.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole deleteMany
   */
  export type JobRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRoles to delete
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to delete.
     */
    limit?: number
  }

  /**
   * JobRole without action
   */
  export type JobRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
  }


  /**
   * Model LabourProfile
   */

  export type AggregateLabourProfile = {
    _count: LabourProfileCountAggregateOutputType | null
    _avg: LabourProfileAvgAggregateOutputType | null
    _sum: LabourProfileSumAggregateOutputType | null
    _min: LabourProfileMinAggregateOutputType | null
    _max: LabourProfileMaxAggregateOutputType | null
  }

  export type LabourProfileAvgAggregateOutputType = {
    age: number | null
    experienceYears: number | null
  }

  export type LabourProfileSumAggregateOutputType = {
    age: number | null
    experienceYears: number | null
  }

  export type LabourProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: $Enums.Gender | null
    nationality: string | null
    maritalStatus: string | null
    experienceYears: number | null
    education: string | null
    currentPosition: string | null
    currentCompany: string | null
    englishProficiency: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    country: string | null
    cvUrl: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    visaType: string | null
    visaExpiry: Date | null
    medicalStatus: string | null
    medicalExpiry: Date | null
    photo: string | null
    status: $Enums.LabourProfileStatus | null
    statusReason: string | null
    requirementId: string | null
    agencyId: string | null
    deploymentDate: Date | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabourProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: $Enums.Gender | null
    nationality: string | null
    maritalStatus: string | null
    experienceYears: number | null
    education: string | null
    currentPosition: string | null
    currentCompany: string | null
    englishProficiency: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    country: string | null
    cvUrl: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    visaType: string | null
    visaExpiry: Date | null
    medicalStatus: string | null
    medicalExpiry: Date | null
    photo: string | null
    status: $Enums.LabourProfileStatus | null
    statusReason: string | null
    requirementId: string | null
    agencyId: string | null
    deploymentDate: Date | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabourProfileCountAggregateOutputType = {
    id: number
    name: number
    age: number
    gender: number
    nationality: number
    maritalStatus: number
    skills: number
    experienceYears: number
    education: number
    currentPosition: number
    currentCompany: number
    languages: number
    englishProficiency: number
    email: number
    phone: number
    address: number
    city: number
    country: number
    cvUrl: number
    passportNumber: number
    passportExpiry: number
    visaType: number
    visaExpiry: number
    medicalStatus: number
    medicalExpiry: number
    photo: number
    otherDocs: number
    status: number
    statusReason: number
    requirementId: number
    agencyId: number
    deploymentDate: number
    contractStartDate: number
    contractEndDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabourProfileAvgAggregateInputType = {
    age?: true
    experienceYears?: true
  }

  export type LabourProfileSumAggregateInputType = {
    age?: true
    experienceYears?: true
  }

  export type LabourProfileMinAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    nationality?: true
    maritalStatus?: true
    experienceYears?: true
    education?: true
    currentPosition?: true
    currentCompany?: true
    englishProficiency?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    cvUrl?: true
    passportNumber?: true
    passportExpiry?: true
    visaType?: true
    visaExpiry?: true
    medicalStatus?: true
    medicalExpiry?: true
    photo?: true
    status?: true
    statusReason?: true
    requirementId?: true
    agencyId?: true
    deploymentDate?: true
    contractStartDate?: true
    contractEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabourProfileMaxAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    nationality?: true
    maritalStatus?: true
    experienceYears?: true
    education?: true
    currentPosition?: true
    currentCompany?: true
    englishProficiency?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    cvUrl?: true
    passportNumber?: true
    passportExpiry?: true
    visaType?: true
    visaExpiry?: true
    medicalStatus?: true
    medicalExpiry?: true
    photo?: true
    status?: true
    statusReason?: true
    requirementId?: true
    agencyId?: true
    deploymentDate?: true
    contractStartDate?: true
    contractEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabourProfileCountAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    nationality?: true
    maritalStatus?: true
    skills?: true
    experienceYears?: true
    education?: true
    currentPosition?: true
    currentCompany?: true
    languages?: true
    englishProficiency?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    cvUrl?: true
    passportNumber?: true
    passportExpiry?: true
    visaType?: true
    visaExpiry?: true
    medicalStatus?: true
    medicalExpiry?: true
    photo?: true
    otherDocs?: true
    status?: true
    statusReason?: true
    requirementId?: true
    agencyId?: true
    deploymentDate?: true
    contractStartDate?: true
    contractEndDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabourProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourProfile to aggregate.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourProfiles
    **/
    _count?: true | LabourProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabourProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabourProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourProfileMaxAggregateInputType
  }

  export type GetLabourProfileAggregateType<T extends LabourProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourProfile[P]>
      : GetScalarType<T[P], AggregateLabourProfile[P]>
  }




  export type LabourProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithAggregationInput | LabourProfileOrderByWithAggregationInput[]
    by: LabourProfileScalarFieldEnum[] | LabourProfileScalarFieldEnum
    having?: LabourProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourProfileCountAggregateInputType | true
    _avg?: LabourProfileAvgAggregateInputType
    _sum?: LabourProfileSumAggregateInputType
    _min?: LabourProfileMinAggregateInputType
    _max?: LabourProfileMaxAggregateInputType
  }

  export type LabourProfileGroupByOutputType = {
    id: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus: string | null
    skills: string[]
    experienceYears: number
    education: string | null
    currentPosition: string | null
    currentCompany: string | null
    languages: string[]
    englishProficiency: string | null
    email: string | null
    phone: string
    address: string | null
    city: string | null
    country: string | null
    cvUrl: string
    passportNumber: string | null
    passportExpiry: Date | null
    visaType: string | null
    visaExpiry: Date | null
    medicalStatus: string | null
    medicalExpiry: Date | null
    photo: string | null
    otherDocs: string[]
    status: $Enums.LabourProfileStatus
    statusReason: string | null
    requirementId: string
    agencyId: string
    deploymentDate: Date | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LabourProfileCountAggregateOutputType | null
    _avg: LabourProfileAvgAggregateOutputType | null
    _sum: LabourProfileSumAggregateOutputType | null
    _min: LabourProfileMinAggregateOutputType | null
    _max: LabourProfileMaxAggregateOutputType | null
  }

  type GetLabourProfileGroupByPayload<T extends LabourProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LabourProfileGroupByOutputType[P]>
        }
      >
    >


  export type LabourProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    maritalStatus?: boolean
    skills?: boolean
    experienceYears?: boolean
    education?: boolean
    currentPosition?: boolean
    currentCompany?: boolean
    languages?: boolean
    englishProficiency?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    cvUrl?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    medicalStatus?: boolean
    medicalExpiry?: boolean
    photo?: boolean
    otherDocs?: boolean
    status?: boolean
    statusReason?: boolean
    requirementId?: boolean
    agencyId?: boolean
    deploymentDate?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    statusLogs?: boolean | LabourProfile$statusLogsArgs<ExtArgs>
    procedures?: boolean | LabourProfile$proceduresArgs<ExtArgs>
    _count?: boolean | LabourProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    maritalStatus?: boolean
    skills?: boolean
    experienceYears?: boolean
    education?: boolean
    currentPosition?: boolean
    currentCompany?: boolean
    languages?: boolean
    englishProficiency?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    cvUrl?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    medicalStatus?: boolean
    medicalExpiry?: boolean
    photo?: boolean
    otherDocs?: boolean
    status?: boolean
    statusReason?: boolean
    requirementId?: boolean
    agencyId?: boolean
    deploymentDate?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    maritalStatus?: boolean
    skills?: boolean
    experienceYears?: boolean
    education?: boolean
    currentPosition?: boolean
    currentCompany?: boolean
    languages?: boolean
    englishProficiency?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    cvUrl?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    medicalStatus?: boolean
    medicalExpiry?: boolean
    photo?: boolean
    otherDocs?: boolean
    status?: boolean
    statusReason?: boolean
    requirementId?: boolean
    agencyId?: boolean
    deploymentDate?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectScalar = {
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    maritalStatus?: boolean
    skills?: boolean
    experienceYears?: boolean
    education?: boolean
    currentPosition?: boolean
    currentCompany?: boolean
    languages?: boolean
    englishProficiency?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    cvUrl?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    medicalStatus?: boolean
    medicalExpiry?: boolean
    photo?: boolean
    otherDocs?: boolean
    status?: boolean
    statusReason?: boolean
    requirementId?: boolean
    agencyId?: boolean
    deploymentDate?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabourProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "age" | "gender" | "nationality" | "maritalStatus" | "skills" | "experienceYears" | "education" | "currentPosition" | "currentCompany" | "languages" | "englishProficiency" | "email" | "phone" | "address" | "city" | "country" | "cvUrl" | "passportNumber" | "passportExpiry" | "visaType" | "visaExpiry" | "medicalStatus" | "medicalExpiry" | "photo" | "otherDocs" | "status" | "statusReason" | "requirementId" | "agencyId" | "deploymentDate" | "contractStartDate" | "contractEndDate" | "createdAt" | "updatedAt", ExtArgs["result"]["labourProfile"]>
  export type LabourProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    statusLogs?: boolean | LabourProfile$statusLogsArgs<ExtArgs>
    procedures?: boolean | LabourProfile$proceduresArgs<ExtArgs>
    _count?: boolean | LabourProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabourProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type LabourProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $LabourProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourProfile"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      statusLogs: Prisma.$LabourStatusLogPayload<ExtArgs>[]
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      age: number
      gender: $Enums.Gender
      nationality: string
      maritalStatus: string | null
      skills: string[]
      experienceYears: number
      education: string | null
      currentPosition: string | null
      currentCompany: string | null
      languages: string[]
      englishProficiency: string | null
      email: string | null
      phone: string
      address: string | null
      city: string | null
      country: string | null
      cvUrl: string
      passportNumber: string | null
      passportExpiry: Date | null
      visaType: string | null
      visaExpiry: Date | null
      medicalStatus: string | null
      medicalExpiry: Date | null
      photo: string | null
      otherDocs: string[]
      status: $Enums.LabourProfileStatus
      statusReason: string | null
      requirementId: string
      agencyId: string
      deploymentDate: Date | null
      contractStartDate: Date | null
      contractEndDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labourProfile"]>
    composites: {}
  }

  type LabourProfileGetPayload<S extends boolean | null | undefined | LabourProfileDefaultArgs> = $Result.GetResult<Prisma.$LabourProfilePayload, S>

  type LabourProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourProfileCountAggregateInputType | true
    }

  export interface LabourProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourProfile'], meta: { name: 'LabourProfile' } }
    /**
     * Find zero or one LabourProfile that matches the filter.
     * @param {LabourProfileFindUniqueArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourProfileFindUniqueArgs>(args: SelectSubset<T, LabourProfileFindUniqueArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourProfileFindUniqueOrThrowArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindFirstArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourProfileFindFirstArgs>(args?: SelectSubset<T, LabourProfileFindFirstArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindFirstOrThrowArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourProfiles
     * const labourProfiles = await prisma.labourProfile.findMany()
     * 
     * // Get first 10 LabourProfiles
     * const labourProfiles = await prisma.labourProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourProfileFindManyArgs>(args?: SelectSubset<T, LabourProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourProfile.
     * @param {LabourProfileCreateArgs} args - Arguments to create a LabourProfile.
     * @example
     * // Create one LabourProfile
     * const LabourProfile = await prisma.labourProfile.create({
     *   data: {
     *     // ... data to create a LabourProfile
     *   }
     * })
     * 
     */
    create<T extends LabourProfileCreateArgs>(args: SelectSubset<T, LabourProfileCreateArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourProfiles.
     * @param {LabourProfileCreateManyArgs} args - Arguments to create many LabourProfiles.
     * @example
     * // Create many LabourProfiles
     * const labourProfile = await prisma.labourProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourProfileCreateManyArgs>(args?: SelectSubset<T, LabourProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourProfiles and returns the data saved in the database.
     * @param {LabourProfileCreateManyAndReturnArgs} args - Arguments to create many LabourProfiles.
     * @example
     * // Create many LabourProfiles
     * const labourProfile = await prisma.labourProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourProfiles and only return the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourProfile.
     * @param {LabourProfileDeleteArgs} args - Arguments to delete one LabourProfile.
     * @example
     * // Delete one LabourProfile
     * const LabourProfile = await prisma.labourProfile.delete({
     *   where: {
     *     // ... filter to delete one LabourProfile
     *   }
     * })
     * 
     */
    delete<T extends LabourProfileDeleteArgs>(args: SelectSubset<T, LabourProfileDeleteArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourProfile.
     * @param {LabourProfileUpdateArgs} args - Arguments to update one LabourProfile.
     * @example
     * // Update one LabourProfile
     * const labourProfile = await prisma.labourProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourProfileUpdateArgs>(args: SelectSubset<T, LabourProfileUpdateArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourProfiles.
     * @param {LabourProfileDeleteManyArgs} args - Arguments to filter LabourProfiles to delete.
     * @example
     * // Delete a few LabourProfiles
     * const { count } = await prisma.labourProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourProfileDeleteManyArgs>(args?: SelectSubset<T, LabourProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourProfiles
     * const labourProfile = await prisma.labourProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourProfileUpdateManyArgs>(args: SelectSubset<T, LabourProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourProfiles and returns the data updated in the database.
     * @param {LabourProfileUpdateManyAndReturnArgs} args - Arguments to update many LabourProfiles.
     * @example
     * // Update many LabourProfiles
     * const labourProfile = await prisma.labourProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourProfiles and only return the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourProfile.
     * @param {LabourProfileUpsertArgs} args - Arguments to update or create a LabourProfile.
     * @example
     * // Update or create a LabourProfile
     * const labourProfile = await prisma.labourProfile.upsert({
     *   create: {
     *     // ... data to create a LabourProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourProfile we want to update
     *   }
     * })
     */
    upsert<T extends LabourProfileUpsertArgs>(args: SelectSubset<T, LabourProfileUpsertArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileCountArgs} args - Arguments to filter LabourProfiles to count.
     * @example
     * // Count the number of LabourProfiles
     * const count = await prisma.labourProfile.count({
     *   where: {
     *     // ... the filter for the LabourProfiles we want to count
     *   }
     * })
    **/
    count<T extends LabourProfileCountArgs>(
      args?: Subset<T, LabourProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourProfileAggregateArgs>(args: Subset<T, LabourProfileAggregateArgs>): Prisma.PrismaPromise<GetLabourProfileAggregateType<T>>

    /**
     * Group by LabourProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourProfileGroupByArgs['orderBy'] }
        : { orderBy?: LabourProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourProfile model
   */
  readonly fields: LabourProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    statusLogs<T extends LabourProfile$statusLogsArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$statusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    procedures<T extends LabourProfile$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourProfile model
   */
  interface LabourProfileFieldRefs {
    readonly id: FieldRef<"LabourProfile", 'String'>
    readonly name: FieldRef<"LabourProfile", 'String'>
    readonly age: FieldRef<"LabourProfile", 'Int'>
    readonly gender: FieldRef<"LabourProfile", 'Gender'>
    readonly nationality: FieldRef<"LabourProfile", 'String'>
    readonly maritalStatus: FieldRef<"LabourProfile", 'String'>
    readonly skills: FieldRef<"LabourProfile", 'String[]'>
    readonly experienceYears: FieldRef<"LabourProfile", 'Int'>
    readonly education: FieldRef<"LabourProfile", 'String'>
    readonly currentPosition: FieldRef<"LabourProfile", 'String'>
    readonly currentCompany: FieldRef<"LabourProfile", 'String'>
    readonly languages: FieldRef<"LabourProfile", 'String[]'>
    readonly englishProficiency: FieldRef<"LabourProfile", 'String'>
    readonly email: FieldRef<"LabourProfile", 'String'>
    readonly phone: FieldRef<"LabourProfile", 'String'>
    readonly address: FieldRef<"LabourProfile", 'String'>
    readonly city: FieldRef<"LabourProfile", 'String'>
    readonly country: FieldRef<"LabourProfile", 'String'>
    readonly cvUrl: FieldRef<"LabourProfile", 'String'>
    readonly passportNumber: FieldRef<"LabourProfile", 'String'>
    readonly passportExpiry: FieldRef<"LabourProfile", 'DateTime'>
    readonly visaType: FieldRef<"LabourProfile", 'String'>
    readonly visaExpiry: FieldRef<"LabourProfile", 'DateTime'>
    readonly medicalStatus: FieldRef<"LabourProfile", 'String'>
    readonly medicalExpiry: FieldRef<"LabourProfile", 'DateTime'>
    readonly photo: FieldRef<"LabourProfile", 'String'>
    readonly otherDocs: FieldRef<"LabourProfile", 'String[]'>
    readonly status: FieldRef<"LabourProfile", 'LabourProfileStatus'>
    readonly statusReason: FieldRef<"LabourProfile", 'String'>
    readonly requirementId: FieldRef<"LabourProfile", 'String'>
    readonly agencyId: FieldRef<"LabourProfile", 'String'>
    readonly deploymentDate: FieldRef<"LabourProfile", 'DateTime'>
    readonly contractStartDate: FieldRef<"LabourProfile", 'DateTime'>
    readonly contractEndDate: FieldRef<"LabourProfile", 'DateTime'>
    readonly createdAt: FieldRef<"LabourProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LabourProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabourProfile findUnique
   */
  export type LabourProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile findUniqueOrThrow
   */
  export type LabourProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile findFirst
   */
  export type LabourProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourProfiles.
     */
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile findFirstOrThrow
   */
  export type LabourProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourProfiles.
     */
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile findMany
   */
  export type LabourProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfiles to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile create
   */
  export type LabourProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourProfile.
     */
    data: XOR<LabourProfileCreateInput, LabourProfileUncheckedCreateInput>
  }

  /**
   * LabourProfile createMany
   */
  export type LabourProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourProfiles.
     */
    data: LabourProfileCreateManyInput | LabourProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourProfile createManyAndReturn
   */
  export type LabourProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LabourProfiles.
     */
    data: LabourProfileCreateManyInput | LabourProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourProfile update
   */
  export type LabourProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourProfile.
     */
    data: XOR<LabourProfileUpdateInput, LabourProfileUncheckedUpdateInput>
    /**
     * Choose, which LabourProfile to update.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile updateMany
   */
  export type LabourProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourProfiles.
     */
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabourProfiles to update
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to update.
     */
    limit?: number
  }

  /**
   * LabourProfile updateManyAndReturn
   */
  export type LabourProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * The data used to update LabourProfiles.
     */
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabourProfiles to update
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourProfile upsert
   */
  export type LabourProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourProfile to update in case it exists.
     */
    where: LabourProfileWhereUniqueInput
    /**
     * In case the LabourProfile found by the `where` argument doesn't exist, create a new LabourProfile with this data.
     */
    create: XOR<LabourProfileCreateInput, LabourProfileUncheckedCreateInput>
    /**
     * In case the LabourProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourProfileUpdateInput, LabourProfileUncheckedUpdateInput>
  }

  /**
   * LabourProfile delete
   */
  export type LabourProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter which LabourProfile to delete.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile deleteMany
   */
  export type LabourProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourProfiles to delete
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to delete.
     */
    limit?: number
  }

  /**
   * LabourProfile.statusLogs
   */
  export type LabourProfile$statusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    where?: LabourStatusLogWhereInput
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    cursor?: LabourStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourStatusLogScalarFieldEnum | LabourStatusLogScalarFieldEnum[]
  }

  /**
   * LabourProfile.procedures
   */
  export type LabourProfile$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * LabourProfile without action
   */
  export type LabourProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
  }


  /**
   * Model Procedure
   */

  export type AggregateProcedure = {
    _count: ProcedureCountAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  export type ProcedureMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ProcedureStatus | null
    dueDate: Date | null
    completedDate: Date | null
    comments: string | null
    requirementId: string | null
    labourProfileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ProcedureStatus | null
    dueDate: Date | null
    completedDate: Date | null
    comments: string | null
    requirementId: string | null
    labourProfileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    dueDate: number
    completedDate: number
    comments: number
    metadata: number
    requirementId: number
    labourProfileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcedureMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    comments?: true
    requirementId?: true
    labourProfileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    comments?: true
    requirementId?: true
    labourProfileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    comments?: true
    metadata?: true
    requirementId?: true
    labourProfileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedure to aggregate.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedures
    **/
    _count?: true | ProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureMaxAggregateInputType
  }

  export type GetProcedureAggregateType<T extends ProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedure[P]>
      : GetScalarType<T[P], AggregateProcedure[P]>
  }




  export type ProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithAggregationInput | ProcedureOrderByWithAggregationInput[]
    by: ProcedureScalarFieldEnum[] | ProcedureScalarFieldEnum
    having?: ProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureCountAggregateInputType | true
    _min?: ProcedureMinAggregateInputType
    _max?: ProcedureMaxAggregateInputType
  }

  export type ProcedureGroupByOutputType = {
    id: string
    name: string
    description: string
    status: $Enums.ProcedureStatus
    dueDate: Date | null
    completedDate: Date | null
    comments: string | null
    metadata: JsonValue | null
    requirementId: string | null
    labourProfileId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProcedureCountAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  type GetProcedureGroupByPayload<T extends ProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    comments?: boolean
    metadata?: boolean
    requirementId?: boolean
    labourProfileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    comments?: boolean
    metadata?: boolean
    requirementId?: boolean
    labourProfileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    comments?: boolean
    metadata?: boolean
    requirementId?: boolean
    labourProfileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    comments?: boolean
    metadata?: boolean
    requirementId?: boolean
    labourProfileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "dueDate" | "completedDate" | "comments" | "metadata" | "requirementId" | "labourProfileId" | "createdAt" | "updatedAt", ExtArgs["result"]["procedure"]>
  export type ProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }
  export type ProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }
  export type ProcedureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | Procedure$requirementArgs<ExtArgs>
    labourProfile?: boolean | Procedure$labourProfileArgs<ExtArgs>
  }

  export type $ProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedure"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs> | null
      labourProfile: Prisma.$LabourProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: $Enums.ProcedureStatus
      dueDate: Date | null
      completedDate: Date | null
      comments: string | null
      metadata: Prisma.JsonValue | null
      requirementId: string | null
      labourProfileId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["procedure"]>
    composites: {}
  }

  type ProcedureGetPayload<S extends boolean | null | undefined | ProcedureDefaultArgs> = $Result.GetResult<Prisma.$ProcedurePayload, S>

  type ProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcedureCountAggregateInputType | true
    }

  export interface ProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedure'], meta: { name: 'Procedure' } }
    /**
     * Find zero or one Procedure that matches the filter.
     * @param {ProcedureFindUniqueArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureFindUniqueArgs>(args: SelectSubset<T, ProcedureFindUniqueArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Procedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcedureFindUniqueOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureFindFirstArgs>(args?: SelectSubset<T, ProcedureFindFirstArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedures
     * const procedures = await prisma.procedure.findMany()
     * 
     * // Get first 10 Procedures
     * const procedures = await prisma.procedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedureWithIdOnly = await prisma.procedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcedureFindManyArgs>(args?: SelectSubset<T, ProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Procedure.
     * @param {ProcedureCreateArgs} args - Arguments to create a Procedure.
     * @example
     * // Create one Procedure
     * const Procedure = await prisma.procedure.create({
     *   data: {
     *     // ... data to create a Procedure
     *   }
     * })
     * 
     */
    create<T extends ProcedureCreateArgs>(args: SelectSubset<T, ProcedureCreateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Procedures.
     * @param {ProcedureCreateManyArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureCreateManyArgs>(args?: SelectSubset<T, ProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedures and returns the data saved in the database.
     * @param {ProcedureCreateManyAndReturnArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Procedure.
     * @param {ProcedureDeleteArgs} args - Arguments to delete one Procedure.
     * @example
     * // Delete one Procedure
     * const Procedure = await prisma.procedure.delete({
     *   where: {
     *     // ... filter to delete one Procedure
     *   }
     * })
     * 
     */
    delete<T extends ProcedureDeleteArgs>(args: SelectSubset<T, ProcedureDeleteArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Procedure.
     * @param {ProcedureUpdateArgs} args - Arguments to update one Procedure.
     * @example
     * // Update one Procedure
     * const procedure = await prisma.procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureUpdateArgs>(args: SelectSubset<T, ProcedureUpdateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Procedures.
     * @param {ProcedureDeleteManyArgs} args - Arguments to filter Procedures to delete.
     * @example
     * // Delete a few Procedures
     * const { count } = await prisma.procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureDeleteManyArgs>(args?: SelectSubset<T, ProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureUpdateManyArgs>(args: SelectSubset<T, ProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures and returns the data updated in the database.
     * @param {ProcedureUpdateManyAndReturnArgs} args - Arguments to update many Procedures.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcedureUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Procedure.
     * @param {ProcedureUpsertArgs} args - Arguments to update or create a Procedure.
     * @example
     * // Update or create a Procedure
     * const procedure = await prisma.procedure.upsert({
     *   create: {
     *     // ... data to create a Procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedure we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureUpsertArgs>(args: SelectSubset<T, ProcedureUpsertArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureCountArgs} args - Arguments to filter Procedures to count.
     * @example
     * // Count the number of Procedures
     * const count = await prisma.procedure.count({
     *   where: {
     *     // ... the filter for the Procedures we want to count
     *   }
     * })
    **/
    count<T extends ProcedureCountArgs>(
      args?: Subset<T, ProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureAggregateArgs>(args: Subset<T, ProcedureAggregateArgs>): Prisma.PrismaPromise<GetProcedureAggregateType<T>>

    /**
     * Group by Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedure model
   */
  readonly fields: ProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends Procedure$requirementArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$requirementArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labourProfile<T extends Procedure$labourProfileArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$labourProfileArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedure model
   */
  interface ProcedureFieldRefs {
    readonly id: FieldRef<"Procedure", 'String'>
    readonly name: FieldRef<"Procedure", 'String'>
    readonly description: FieldRef<"Procedure", 'String'>
    readonly status: FieldRef<"Procedure", 'ProcedureStatus'>
    readonly dueDate: FieldRef<"Procedure", 'DateTime'>
    readonly completedDate: FieldRef<"Procedure", 'DateTime'>
    readonly comments: FieldRef<"Procedure", 'String'>
    readonly metadata: FieldRef<"Procedure", 'Json'>
    readonly requirementId: FieldRef<"Procedure", 'String'>
    readonly labourProfileId: FieldRef<"Procedure", 'String'>
    readonly createdAt: FieldRef<"Procedure", 'DateTime'>
    readonly updatedAt: FieldRef<"Procedure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Procedure findUnique
   */
  export type ProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findUniqueOrThrow
   */
  export type ProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findFirst
   */
  export type ProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findFirstOrThrow
   */
  export type ProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findMany
   */
  export type ProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedures to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure create
   */
  export type ProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedure.
     */
    data: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
  }

  /**
   * Procedure createMany
   */
  export type ProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure createManyAndReturn
   */
  export type ProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure update
   */
  export type ProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedure.
     */
    data: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
    /**
     * Choose, which Procedure to update.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure updateMany
   */
  export type ProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
  }

  /**
   * Procedure updateManyAndReturn
   */
  export type ProcedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure upsert
   */
  export type ProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedure to update in case it exists.
     */
    where: ProcedureWhereUniqueInput
    /**
     * In case the Procedure found by the `where` argument doesn't exist, create a new Procedure with this data.
     */
    create: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
    /**
     * In case the Procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
  }

  /**
   * Procedure delete
   */
  export type ProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter which Procedure to delete.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure deleteMany
   */
  export type ProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedures to delete
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to delete.
     */
    limit?: number
  }

  /**
   * Procedure.requirement
   */
  export type Procedure$requirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
  }

  /**
   * Procedure.labourProfile
   */
  export type Procedure$labourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
  }

  /**
   * Procedure without action
   */
  export type ProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
  }


  /**
   * Model LabourStatusLog
   */

  export type AggregateLabourStatusLog = {
    _count: LabourStatusLogCountAggregateOutputType | null
    _min: LabourStatusLogMinAggregateOutputType | null
    _max: LabourStatusLogMaxAggregateOutputType | null
  }

  export type LabourStatusLogMinAggregateOutputType = {
    id: string | null
    status: $Enums.LabourProfileStatus | null
    comments: string | null
    labourProfileId: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type LabourStatusLogMaxAggregateOutputType = {
    id: string | null
    status: $Enums.LabourProfileStatus | null
    comments: string | null
    labourProfileId: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type LabourStatusLogCountAggregateOutputType = {
    id: number
    status: number
    comments: number
    metadata: number
    labourProfileId: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type LabourStatusLogMinAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    labourProfileId?: true
    changedById?: true
    createdAt?: true
  }

  export type LabourStatusLogMaxAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    labourProfileId?: true
    changedById?: true
    createdAt?: true
  }

  export type LabourStatusLogCountAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    metadata?: true
    labourProfileId?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type LabourStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourStatusLog to aggregate.
     */
    where?: LabourStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStatusLogs to fetch.
     */
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourStatusLogs
    **/
    _count?: true | LabourStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourStatusLogMaxAggregateInputType
  }

  export type GetLabourStatusLogAggregateType<T extends LabourStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourStatusLog[P]>
      : GetScalarType<T[P], AggregateLabourStatusLog[P]>
  }




  export type LabourStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourStatusLogWhereInput
    orderBy?: LabourStatusLogOrderByWithAggregationInput | LabourStatusLogOrderByWithAggregationInput[]
    by: LabourStatusLogScalarFieldEnum[] | LabourStatusLogScalarFieldEnum
    having?: LabourStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourStatusLogCountAggregateInputType | true
    _min?: LabourStatusLogMinAggregateInputType
    _max?: LabourStatusLogMaxAggregateInputType
  }

  export type LabourStatusLogGroupByOutputType = {
    id: string
    status: $Enums.LabourProfileStatus
    comments: string | null
    metadata: JsonValue | null
    labourProfileId: string
    changedById: string
    createdAt: Date
    _count: LabourStatusLogCountAggregateOutputType | null
    _min: LabourStatusLogMinAggregateOutputType | null
    _max: LabourStatusLogMaxAggregateOutputType | null
  }

  type GetLabourStatusLogGroupByPayload<T extends LabourStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], LabourStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type LabourStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    comments?: boolean
    metadata?: boolean
    labourProfileId?: boolean
    changedById?: boolean
    createdAt?: boolean
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStatusLog"]>

  export type LabourStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    comments?: boolean
    metadata?: boolean
    labourProfileId?: boolean
    changedById?: boolean
    createdAt?: boolean
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStatusLog"]>

  export type LabourStatusLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    comments?: boolean
    metadata?: boolean
    labourProfileId?: boolean
    changedById?: boolean
    createdAt?: boolean
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStatusLog"]>

  export type LabourStatusLogSelectScalar = {
    id?: boolean
    status?: boolean
    comments?: boolean
    metadata?: boolean
    labourProfileId?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type LabourStatusLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "comments" | "metadata" | "labourProfileId" | "changedById" | "createdAt", ExtArgs["result"]["labourStatusLog"]>
  export type LabourStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LabourStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LabourStatusLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labourProfile?: boolean | LabourProfileDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LabourStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourStatusLog"
    objects: {
      labourProfile: Prisma.$LabourProfilePayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.LabourProfileStatus
      comments: string | null
      metadata: Prisma.JsonValue | null
      labourProfileId: string
      changedById: string
      createdAt: Date
    }, ExtArgs["result"]["labourStatusLog"]>
    composites: {}
  }

  type LabourStatusLogGetPayload<S extends boolean | null | undefined | LabourStatusLogDefaultArgs> = $Result.GetResult<Prisma.$LabourStatusLogPayload, S>

  type LabourStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourStatusLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourStatusLogCountAggregateInputType | true
    }

  export interface LabourStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourStatusLog'], meta: { name: 'LabourStatusLog' } }
    /**
     * Find zero or one LabourStatusLog that matches the filter.
     * @param {LabourStatusLogFindUniqueArgs} args - Arguments to find a LabourStatusLog
     * @example
     * // Get one LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourStatusLogFindUniqueArgs>(args: SelectSubset<T, LabourStatusLogFindUniqueArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourStatusLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourStatusLogFindUniqueOrThrowArgs} args - Arguments to find a LabourStatusLog
     * @example
     * // Get one LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogFindFirstArgs} args - Arguments to find a LabourStatusLog
     * @example
     * // Get one LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourStatusLogFindFirstArgs>(args?: SelectSubset<T, LabourStatusLogFindFirstArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogFindFirstOrThrowArgs} args - Arguments to find a LabourStatusLog
     * @example
     * // Get one LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourStatusLogs
     * const labourStatusLogs = await prisma.labourStatusLog.findMany()
     * 
     * // Get first 10 LabourStatusLogs
     * const labourStatusLogs = await prisma.labourStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourStatusLogWithIdOnly = await prisma.labourStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourStatusLogFindManyArgs>(args?: SelectSubset<T, LabourStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourStatusLog.
     * @param {LabourStatusLogCreateArgs} args - Arguments to create a LabourStatusLog.
     * @example
     * // Create one LabourStatusLog
     * const LabourStatusLog = await prisma.labourStatusLog.create({
     *   data: {
     *     // ... data to create a LabourStatusLog
     *   }
     * })
     * 
     */
    create<T extends LabourStatusLogCreateArgs>(args: SelectSubset<T, LabourStatusLogCreateArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourStatusLogs.
     * @param {LabourStatusLogCreateManyArgs} args - Arguments to create many LabourStatusLogs.
     * @example
     * // Create many LabourStatusLogs
     * const labourStatusLog = await prisma.labourStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourStatusLogCreateManyArgs>(args?: SelectSubset<T, LabourStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourStatusLogs and returns the data saved in the database.
     * @param {LabourStatusLogCreateManyAndReturnArgs} args - Arguments to create many LabourStatusLogs.
     * @example
     * // Create many LabourStatusLogs
     * const labourStatusLog = await prisma.labourStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourStatusLogs and only return the `id`
     * const labourStatusLogWithIdOnly = await prisma.labourStatusLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourStatusLog.
     * @param {LabourStatusLogDeleteArgs} args - Arguments to delete one LabourStatusLog.
     * @example
     * // Delete one LabourStatusLog
     * const LabourStatusLog = await prisma.labourStatusLog.delete({
     *   where: {
     *     // ... filter to delete one LabourStatusLog
     *   }
     * })
     * 
     */
    delete<T extends LabourStatusLogDeleteArgs>(args: SelectSubset<T, LabourStatusLogDeleteArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourStatusLog.
     * @param {LabourStatusLogUpdateArgs} args - Arguments to update one LabourStatusLog.
     * @example
     * // Update one LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourStatusLogUpdateArgs>(args: SelectSubset<T, LabourStatusLogUpdateArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourStatusLogs.
     * @param {LabourStatusLogDeleteManyArgs} args - Arguments to filter LabourStatusLogs to delete.
     * @example
     * // Delete a few LabourStatusLogs
     * const { count } = await prisma.labourStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourStatusLogDeleteManyArgs>(args?: SelectSubset<T, LabourStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourStatusLogs
     * const labourStatusLog = await prisma.labourStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourStatusLogUpdateManyArgs>(args: SelectSubset<T, LabourStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourStatusLogs and returns the data updated in the database.
     * @param {LabourStatusLogUpdateManyAndReturnArgs} args - Arguments to update many LabourStatusLogs.
     * @example
     * // Update many LabourStatusLogs
     * const labourStatusLog = await prisma.labourStatusLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourStatusLogs and only return the `id`
     * const labourStatusLogWithIdOnly = await prisma.labourStatusLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourStatusLogUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourStatusLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourStatusLog.
     * @param {LabourStatusLogUpsertArgs} args - Arguments to update or create a LabourStatusLog.
     * @example
     * // Update or create a LabourStatusLog
     * const labourStatusLog = await prisma.labourStatusLog.upsert({
     *   create: {
     *     // ... data to create a LabourStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends LabourStatusLogUpsertArgs>(args: SelectSubset<T, LabourStatusLogUpsertArgs<ExtArgs>>): Prisma__LabourStatusLogClient<$Result.GetResult<Prisma.$LabourStatusLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogCountArgs} args - Arguments to filter LabourStatusLogs to count.
     * @example
     * // Count the number of LabourStatusLogs
     * const count = await prisma.labourStatusLog.count({
     *   where: {
     *     // ... the filter for the LabourStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends LabourStatusLogCountArgs>(
      args?: Subset<T, LabourStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourStatusLogAggregateArgs>(args: Subset<T, LabourStatusLogAggregateArgs>): Prisma.PrismaPromise<GetLabourStatusLogAggregateType<T>>

    /**
     * Group by LabourStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: LabourStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourStatusLog model
   */
  readonly fields: LabourStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    labourProfile<T extends LabourProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfileDefaultArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourStatusLog model
   */
  interface LabourStatusLogFieldRefs {
    readonly id: FieldRef<"LabourStatusLog", 'String'>
    readonly status: FieldRef<"LabourStatusLog", 'LabourProfileStatus'>
    readonly comments: FieldRef<"LabourStatusLog", 'String'>
    readonly metadata: FieldRef<"LabourStatusLog", 'Json'>
    readonly labourProfileId: FieldRef<"LabourStatusLog", 'String'>
    readonly changedById: FieldRef<"LabourStatusLog", 'String'>
    readonly createdAt: FieldRef<"LabourStatusLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabourStatusLog findUnique
   */
  export type LabourStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which LabourStatusLog to fetch.
     */
    where: LabourStatusLogWhereUniqueInput
  }

  /**
   * LabourStatusLog findUniqueOrThrow
   */
  export type LabourStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which LabourStatusLog to fetch.
     */
    where: LabourStatusLogWhereUniqueInput
  }

  /**
   * LabourStatusLog findFirst
   */
  export type LabourStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which LabourStatusLog to fetch.
     */
    where?: LabourStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStatusLogs to fetch.
     */
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourStatusLogs.
     */
    cursor?: LabourStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourStatusLogs.
     */
    distinct?: LabourStatusLogScalarFieldEnum | LabourStatusLogScalarFieldEnum[]
  }

  /**
   * LabourStatusLog findFirstOrThrow
   */
  export type LabourStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which LabourStatusLog to fetch.
     */
    where?: LabourStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStatusLogs to fetch.
     */
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourStatusLogs.
     */
    cursor?: LabourStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourStatusLogs.
     */
    distinct?: LabourStatusLogScalarFieldEnum | LabourStatusLogScalarFieldEnum[]
  }

  /**
   * LabourStatusLog findMany
   */
  export type LabourStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which LabourStatusLogs to fetch.
     */
    where?: LabourStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStatusLogs to fetch.
     */
    orderBy?: LabourStatusLogOrderByWithRelationInput | LabourStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourStatusLogs.
     */
    cursor?: LabourStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStatusLogs.
     */
    skip?: number
    distinct?: LabourStatusLogScalarFieldEnum | LabourStatusLogScalarFieldEnum[]
  }

  /**
   * LabourStatusLog create
   */
  export type LabourStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourStatusLog.
     */
    data: XOR<LabourStatusLogCreateInput, LabourStatusLogUncheckedCreateInput>
  }

  /**
   * LabourStatusLog createMany
   */
  export type LabourStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourStatusLogs.
     */
    data: LabourStatusLogCreateManyInput | LabourStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourStatusLog createManyAndReturn
   */
  export type LabourStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * The data used to create many LabourStatusLogs.
     */
    data: LabourStatusLogCreateManyInput | LabourStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourStatusLog update
   */
  export type LabourStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourStatusLog.
     */
    data: XOR<LabourStatusLogUpdateInput, LabourStatusLogUncheckedUpdateInput>
    /**
     * Choose, which LabourStatusLog to update.
     */
    where: LabourStatusLogWhereUniqueInput
  }

  /**
   * LabourStatusLog updateMany
   */
  export type LabourStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourStatusLogs.
     */
    data: XOR<LabourStatusLogUpdateManyMutationInput, LabourStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which LabourStatusLogs to update
     */
    where?: LabourStatusLogWhereInput
    /**
     * Limit how many LabourStatusLogs to update.
     */
    limit?: number
  }

  /**
   * LabourStatusLog updateManyAndReturn
   */
  export type LabourStatusLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * The data used to update LabourStatusLogs.
     */
    data: XOR<LabourStatusLogUpdateManyMutationInput, LabourStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which LabourStatusLogs to update
     */
    where?: LabourStatusLogWhereInput
    /**
     * Limit how many LabourStatusLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourStatusLog upsert
   */
  export type LabourStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourStatusLog to update in case it exists.
     */
    where: LabourStatusLogWhereUniqueInput
    /**
     * In case the LabourStatusLog found by the `where` argument doesn't exist, create a new LabourStatusLog with this data.
     */
    create: XOR<LabourStatusLogCreateInput, LabourStatusLogUncheckedCreateInput>
    /**
     * In case the LabourStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourStatusLogUpdateInput, LabourStatusLogUncheckedUpdateInput>
  }

  /**
   * LabourStatusLog delete
   */
  export type LabourStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
    /**
     * Filter which LabourStatusLog to delete.
     */
    where: LabourStatusLogWhereUniqueInput
  }

  /**
   * LabourStatusLog deleteMany
   */
  export type LabourStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourStatusLogs to delete
     */
    where?: LabourStatusLogWhereInput
    /**
     * Limit how many LabourStatusLogs to delete.
     */
    limit?: number
  }

  /**
   * LabourStatusLog without action
   */
  export type LabourStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStatusLog
     */
    select?: LabourStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStatusLog
     */
    omit?: LabourStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model ClientDocument
   */

  export type AggregateClientDocument = {
    _count: ClientDocumentCountAggregateOutputType | null
    _min: ClientDocumentMinAggregateOutputType | null
    _max: ClientDocumentMaxAggregateOutputType | null
  }

  export type ClientDocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    verified: boolean | null
    comments: string | null
    expiryDate: Date | null
    clientId: string | null
    verifiedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientDocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    verified: boolean | null
    comments: string | null
    expiryDate: Date | null
    clientId: string | null
    verifiedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientDocumentCountAggregateOutputType = {
    id: number
    type: number
    url: number
    name: number
    description: number
    verified: number
    comments: number
    expiryDate: number
    clientId: number
    verifiedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientDocumentMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    clientId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    clientId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientDocumentCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    clientId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDocument to aggregate.
     */
    where?: ClientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDocuments to fetch.
     */
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientDocuments
    **/
    _count?: true | ClientDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientDocumentMaxAggregateInputType
  }

  export type GetClientDocumentAggregateType<T extends ClientDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateClientDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientDocument[P]>
      : GetScalarType<T[P], AggregateClientDocument[P]>
  }




  export type ClientDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDocumentWhereInput
    orderBy?: ClientDocumentOrderByWithAggregationInput | ClientDocumentOrderByWithAggregationInput[]
    by: ClientDocumentScalarFieldEnum[] | ClientDocumentScalarFieldEnum
    having?: ClientDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientDocumentCountAggregateInputType | true
    _min?: ClientDocumentMinAggregateInputType
    _max?: ClientDocumentMaxAggregateInputType
  }

  export type ClientDocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    url: string
    name: string | null
    description: string | null
    verified: boolean
    comments: string | null
    expiryDate: Date | null
    clientId: string
    verifiedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientDocumentCountAggregateOutputType | null
    _min: ClientDocumentMinAggregateOutputType | null
    _max: ClientDocumentMaxAggregateOutputType | null
  }

  type GetClientDocumentGroupByPayload<T extends ClientDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ClientDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ClientDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    clientId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["clientDocument"]>

  export type ClientDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    clientId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["clientDocument"]>

  export type ClientDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    clientId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["clientDocument"]>

  export type ClientDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    clientId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "url" | "name" | "description" | "verified" | "comments" | "expiryDate" | "clientId" | "verifiedById" | "createdAt" | "updatedAt", ExtArgs["result"]["clientDocument"]>
  export type ClientDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }
  export type ClientDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }
  export type ClientDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    verifiedBy?: boolean | ClientDocument$verifiedByArgs<ExtArgs>
  }

  export type $ClientDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientDocument"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      url: string
      name: string | null
      description: string | null
      verified: boolean
      comments: string | null
      expiryDate: Date | null
      clientId: string
      verifiedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientDocument"]>
    composites: {}
  }

  type ClientDocumentGetPayload<S extends boolean | null | undefined | ClientDocumentDefaultArgs> = $Result.GetResult<Prisma.$ClientDocumentPayload, S>

  type ClientDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientDocumentCountAggregateInputType | true
    }

  export interface ClientDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientDocument'], meta: { name: 'ClientDocument' } }
    /**
     * Find zero or one ClientDocument that matches the filter.
     * @param {ClientDocumentFindUniqueArgs} args - Arguments to find a ClientDocument
     * @example
     * // Get one ClientDocument
     * const clientDocument = await prisma.clientDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientDocumentFindUniqueArgs>(args: SelectSubset<T, ClientDocumentFindUniqueArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientDocumentFindUniqueOrThrowArgs} args - Arguments to find a ClientDocument
     * @example
     * // Get one ClientDocument
     * const clientDocument = await prisma.clientDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentFindFirstArgs} args - Arguments to find a ClientDocument
     * @example
     * // Get one ClientDocument
     * const clientDocument = await prisma.clientDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientDocumentFindFirstArgs>(args?: SelectSubset<T, ClientDocumentFindFirstArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentFindFirstOrThrowArgs} args - Arguments to find a ClientDocument
     * @example
     * // Get one ClientDocument
     * const clientDocument = await prisma.clientDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientDocuments
     * const clientDocuments = await prisma.clientDocument.findMany()
     * 
     * // Get first 10 ClientDocuments
     * const clientDocuments = await prisma.clientDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientDocumentWithIdOnly = await prisma.clientDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientDocumentFindManyArgs>(args?: SelectSubset<T, ClientDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientDocument.
     * @param {ClientDocumentCreateArgs} args - Arguments to create a ClientDocument.
     * @example
     * // Create one ClientDocument
     * const ClientDocument = await prisma.clientDocument.create({
     *   data: {
     *     // ... data to create a ClientDocument
     *   }
     * })
     * 
     */
    create<T extends ClientDocumentCreateArgs>(args: SelectSubset<T, ClientDocumentCreateArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientDocuments.
     * @param {ClientDocumentCreateManyArgs} args - Arguments to create many ClientDocuments.
     * @example
     * // Create many ClientDocuments
     * const clientDocument = await prisma.clientDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientDocumentCreateManyArgs>(args?: SelectSubset<T, ClientDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientDocuments and returns the data saved in the database.
     * @param {ClientDocumentCreateManyAndReturnArgs} args - Arguments to create many ClientDocuments.
     * @example
     * // Create many ClientDocuments
     * const clientDocument = await prisma.clientDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientDocuments and only return the `id`
     * const clientDocumentWithIdOnly = await prisma.clientDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientDocument.
     * @param {ClientDocumentDeleteArgs} args - Arguments to delete one ClientDocument.
     * @example
     * // Delete one ClientDocument
     * const ClientDocument = await prisma.clientDocument.delete({
     *   where: {
     *     // ... filter to delete one ClientDocument
     *   }
     * })
     * 
     */
    delete<T extends ClientDocumentDeleteArgs>(args: SelectSubset<T, ClientDocumentDeleteArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientDocument.
     * @param {ClientDocumentUpdateArgs} args - Arguments to update one ClientDocument.
     * @example
     * // Update one ClientDocument
     * const clientDocument = await prisma.clientDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientDocumentUpdateArgs>(args: SelectSubset<T, ClientDocumentUpdateArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientDocuments.
     * @param {ClientDocumentDeleteManyArgs} args - Arguments to filter ClientDocuments to delete.
     * @example
     * // Delete a few ClientDocuments
     * const { count } = await prisma.clientDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDocumentDeleteManyArgs>(args?: SelectSubset<T, ClientDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientDocuments
     * const clientDocument = await prisma.clientDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientDocumentUpdateManyArgs>(args: SelectSubset<T, ClientDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDocuments and returns the data updated in the database.
     * @param {ClientDocumentUpdateManyAndReturnArgs} args - Arguments to update many ClientDocuments.
     * @example
     * // Update many ClientDocuments
     * const clientDocument = await prisma.clientDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientDocuments and only return the `id`
     * const clientDocumentWithIdOnly = await prisma.clientDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientDocument.
     * @param {ClientDocumentUpsertArgs} args - Arguments to update or create a ClientDocument.
     * @example
     * // Update or create a ClientDocument
     * const clientDocument = await prisma.clientDocument.upsert({
     *   create: {
     *     // ... data to create a ClientDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientDocument we want to update
     *   }
     * })
     */
    upsert<T extends ClientDocumentUpsertArgs>(args: SelectSubset<T, ClientDocumentUpsertArgs<ExtArgs>>): Prisma__ClientDocumentClient<$Result.GetResult<Prisma.$ClientDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentCountArgs} args - Arguments to filter ClientDocuments to count.
     * @example
     * // Count the number of ClientDocuments
     * const count = await prisma.clientDocument.count({
     *   where: {
     *     // ... the filter for the ClientDocuments we want to count
     *   }
     * })
    **/
    count<T extends ClientDocumentCountArgs>(
      args?: Subset<T, ClientDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientDocumentAggregateArgs>(args: Subset<T, ClientDocumentAggregateArgs>): Prisma.PrismaPromise<GetClientDocumentAggregateType<T>>

    /**
     * Group by ClientDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ClientDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientDocument model
   */
  readonly fields: ClientDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends ClientDocument$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, ClientDocument$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientDocument model
   */
  interface ClientDocumentFieldRefs {
    readonly id: FieldRef<"ClientDocument", 'String'>
    readonly type: FieldRef<"ClientDocument", 'DocumentType'>
    readonly url: FieldRef<"ClientDocument", 'String'>
    readonly name: FieldRef<"ClientDocument", 'String'>
    readonly description: FieldRef<"ClientDocument", 'String'>
    readonly verified: FieldRef<"ClientDocument", 'Boolean'>
    readonly comments: FieldRef<"ClientDocument", 'String'>
    readonly expiryDate: FieldRef<"ClientDocument", 'DateTime'>
    readonly clientId: FieldRef<"ClientDocument", 'String'>
    readonly verifiedById: FieldRef<"ClientDocument", 'String'>
    readonly createdAt: FieldRef<"ClientDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientDocument findUnique
   */
  export type ClientDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClientDocument to fetch.
     */
    where: ClientDocumentWhereUniqueInput
  }

  /**
   * ClientDocument findUniqueOrThrow
   */
  export type ClientDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClientDocument to fetch.
     */
    where: ClientDocumentWhereUniqueInput
  }

  /**
   * ClientDocument findFirst
   */
  export type ClientDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClientDocument to fetch.
     */
    where?: ClientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDocuments to fetch.
     */
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDocuments.
     */
    cursor?: ClientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDocuments.
     */
    distinct?: ClientDocumentScalarFieldEnum | ClientDocumentScalarFieldEnum[]
  }

  /**
   * ClientDocument findFirstOrThrow
   */
  export type ClientDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClientDocument to fetch.
     */
    where?: ClientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDocuments to fetch.
     */
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDocuments.
     */
    cursor?: ClientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDocuments.
     */
    distinct?: ClientDocumentScalarFieldEnum | ClientDocumentScalarFieldEnum[]
  }

  /**
   * ClientDocument findMany
   */
  export type ClientDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClientDocuments to fetch.
     */
    where?: ClientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDocuments to fetch.
     */
    orderBy?: ClientDocumentOrderByWithRelationInput | ClientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientDocuments.
     */
    cursor?: ClientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDocuments.
     */
    skip?: number
    distinct?: ClientDocumentScalarFieldEnum | ClientDocumentScalarFieldEnum[]
  }

  /**
   * ClientDocument create
   */
  export type ClientDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientDocument.
     */
    data: XOR<ClientDocumentCreateInput, ClientDocumentUncheckedCreateInput>
  }

  /**
   * ClientDocument createMany
   */
  export type ClientDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientDocuments.
     */
    data: ClientDocumentCreateManyInput | ClientDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientDocument createManyAndReturn
   */
  export type ClientDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ClientDocuments.
     */
    data: ClientDocumentCreateManyInput | ClientDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDocument update
   */
  export type ClientDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientDocument.
     */
    data: XOR<ClientDocumentUpdateInput, ClientDocumentUncheckedUpdateInput>
    /**
     * Choose, which ClientDocument to update.
     */
    where: ClientDocumentWhereUniqueInput
  }

  /**
   * ClientDocument updateMany
   */
  export type ClientDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientDocuments.
     */
    data: XOR<ClientDocumentUpdateManyMutationInput, ClientDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ClientDocuments to update
     */
    where?: ClientDocumentWhereInput
    /**
     * Limit how many ClientDocuments to update.
     */
    limit?: number
  }

  /**
   * ClientDocument updateManyAndReturn
   */
  export type ClientDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ClientDocuments.
     */
    data: XOR<ClientDocumentUpdateManyMutationInput, ClientDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ClientDocuments to update
     */
    where?: ClientDocumentWhereInput
    /**
     * Limit how many ClientDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDocument upsert
   */
  export type ClientDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientDocument to update in case it exists.
     */
    where: ClientDocumentWhereUniqueInput
    /**
     * In case the ClientDocument found by the `where` argument doesn't exist, create a new ClientDocument with this data.
     */
    create: XOR<ClientDocumentCreateInput, ClientDocumentUncheckedCreateInput>
    /**
     * In case the ClientDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientDocumentUpdateInput, ClientDocumentUncheckedUpdateInput>
  }

  /**
   * ClientDocument delete
   */
  export type ClientDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
    /**
     * Filter which ClientDocument to delete.
     */
    where: ClientDocumentWhereUniqueInput
  }

  /**
   * ClientDocument deleteMany
   */
  export type ClientDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDocuments to delete
     */
    where?: ClientDocumentWhereInput
    /**
     * Limit how many ClientDocuments to delete.
     */
    limit?: number
  }

  /**
   * ClientDocument.verifiedBy
   */
  export type ClientDocument$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ClientDocument without action
   */
  export type ClientDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDocument
     */
    select?: ClientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDocument
     */
    omit?: ClientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDocumentInclude<ExtArgs> | null
  }


  /**
   * Model AgencyDocument
   */

  export type AggregateAgencyDocument = {
    _count: AgencyDocumentCountAggregateOutputType | null
    _min: AgencyDocumentMinAggregateOutputType | null
    _max: AgencyDocumentMaxAggregateOutputType | null
  }

  export type AgencyDocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    verified: boolean | null
    comments: string | null
    expiryDate: Date | null
    agencyId: string | null
    verifiedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyDocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    verified: boolean | null
    comments: string | null
    expiryDate: Date | null
    agencyId: string | null
    verifiedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyDocumentCountAggregateOutputType = {
    id: number
    type: number
    url: number
    name: number
    description: number
    verified: number
    comments: number
    expiryDate: number
    agencyId: number
    verifiedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyDocumentMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    agencyId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    agencyId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyDocumentCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    verified?: true
    comments?: true
    expiryDate?: true
    agencyId?: true
    verifiedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyDocument to aggregate.
     */
    where?: AgencyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyDocuments to fetch.
     */
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyDocuments
    **/
    _count?: true | AgencyDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyDocumentMaxAggregateInputType
  }

  export type GetAgencyDocumentAggregateType<T extends AgencyDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyDocument[P]>
      : GetScalarType<T[P], AggregateAgencyDocument[P]>
  }




  export type AgencyDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyDocumentWhereInput
    orderBy?: AgencyDocumentOrderByWithAggregationInput | AgencyDocumentOrderByWithAggregationInput[]
    by: AgencyDocumentScalarFieldEnum[] | AgencyDocumentScalarFieldEnum
    having?: AgencyDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyDocumentCountAggregateInputType | true
    _min?: AgencyDocumentMinAggregateInputType
    _max?: AgencyDocumentMaxAggregateInputType
  }

  export type AgencyDocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    url: string
    name: string | null
    description: string | null
    verified: boolean
    comments: string | null
    expiryDate: Date | null
    agencyId: string
    verifiedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyDocumentCountAggregateOutputType | null
    _min: AgencyDocumentMinAggregateOutputType | null
    _max: AgencyDocumentMaxAggregateOutputType | null
  }

  type GetAgencyDocumentGroupByPayload<T extends AgencyDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyDocumentGroupByOutputType[P]>
        }
      >
    >


  export type AgencyDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    agencyId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["agencyDocument"]>

  export type AgencyDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    agencyId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["agencyDocument"]>

  export type AgencyDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    agencyId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["agencyDocument"]>

  export type AgencyDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    verified?: boolean
    comments?: boolean
    expiryDate?: boolean
    agencyId?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "url" | "name" | "description" | "verified" | "comments" | "expiryDate" | "agencyId" | "verifiedById" | "createdAt" | "updatedAt", ExtArgs["result"]["agencyDocument"]>
  export type AgencyDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }
  export type AgencyDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }
  export type AgencyDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    verifiedBy?: boolean | AgencyDocument$verifiedByArgs<ExtArgs>
  }

  export type $AgencyDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyDocument"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      url: string
      name: string | null
      description: string | null
      verified: boolean
      comments: string | null
      expiryDate: Date | null
      agencyId: string
      verifiedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyDocument"]>
    composites: {}
  }

  type AgencyDocumentGetPayload<S extends boolean | null | undefined | AgencyDocumentDefaultArgs> = $Result.GetResult<Prisma.$AgencyDocumentPayload, S>

  type AgencyDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyDocumentCountAggregateInputType | true
    }

  export interface AgencyDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyDocument'], meta: { name: 'AgencyDocument' } }
    /**
     * Find zero or one AgencyDocument that matches the filter.
     * @param {AgencyDocumentFindUniqueArgs} args - Arguments to find a AgencyDocument
     * @example
     * // Get one AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyDocumentFindUniqueArgs>(args: SelectSubset<T, AgencyDocumentFindUniqueArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencyDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyDocumentFindUniqueOrThrowArgs} args - Arguments to find a AgencyDocument
     * @example
     * // Get one AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentFindFirstArgs} args - Arguments to find a AgencyDocument
     * @example
     * // Get one AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyDocumentFindFirstArgs>(args?: SelectSubset<T, AgencyDocumentFindFirstArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencyDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentFindFirstOrThrowArgs} args - Arguments to find a AgencyDocument
     * @example
     * // Get one AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencyDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyDocuments
     * const agencyDocuments = await prisma.agencyDocument.findMany()
     * 
     * // Get first 10 AgencyDocuments
     * const agencyDocuments = await prisma.agencyDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyDocumentWithIdOnly = await prisma.agencyDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyDocumentFindManyArgs>(args?: SelectSubset<T, AgencyDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencyDocument.
     * @param {AgencyDocumentCreateArgs} args - Arguments to create a AgencyDocument.
     * @example
     * // Create one AgencyDocument
     * const AgencyDocument = await prisma.agencyDocument.create({
     *   data: {
     *     // ... data to create a AgencyDocument
     *   }
     * })
     * 
     */
    create<T extends AgencyDocumentCreateArgs>(args: SelectSubset<T, AgencyDocumentCreateArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencyDocuments.
     * @param {AgencyDocumentCreateManyArgs} args - Arguments to create many AgencyDocuments.
     * @example
     * // Create many AgencyDocuments
     * const agencyDocument = await prisma.agencyDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyDocumentCreateManyArgs>(args?: SelectSubset<T, AgencyDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyDocuments and returns the data saved in the database.
     * @param {AgencyDocumentCreateManyAndReturnArgs} args - Arguments to create many AgencyDocuments.
     * @example
     * // Create many AgencyDocuments
     * const agencyDocument = await prisma.agencyDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyDocuments and only return the `id`
     * const agencyDocumentWithIdOnly = await prisma.agencyDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencyDocument.
     * @param {AgencyDocumentDeleteArgs} args - Arguments to delete one AgencyDocument.
     * @example
     * // Delete one AgencyDocument
     * const AgencyDocument = await prisma.agencyDocument.delete({
     *   where: {
     *     // ... filter to delete one AgencyDocument
     *   }
     * })
     * 
     */
    delete<T extends AgencyDocumentDeleteArgs>(args: SelectSubset<T, AgencyDocumentDeleteArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencyDocument.
     * @param {AgencyDocumentUpdateArgs} args - Arguments to update one AgencyDocument.
     * @example
     * // Update one AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyDocumentUpdateArgs>(args: SelectSubset<T, AgencyDocumentUpdateArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencyDocuments.
     * @param {AgencyDocumentDeleteManyArgs} args - Arguments to filter AgencyDocuments to delete.
     * @example
     * // Delete a few AgencyDocuments
     * const { count } = await prisma.agencyDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDocumentDeleteManyArgs>(args?: SelectSubset<T, AgencyDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyDocuments
     * const agencyDocument = await prisma.agencyDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyDocumentUpdateManyArgs>(args: SelectSubset<T, AgencyDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyDocuments and returns the data updated in the database.
     * @param {AgencyDocumentUpdateManyAndReturnArgs} args - Arguments to update many AgencyDocuments.
     * @example
     * // Update many AgencyDocuments
     * const agencyDocument = await prisma.agencyDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencyDocuments and only return the `id`
     * const agencyDocumentWithIdOnly = await prisma.agencyDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencyDocument.
     * @param {AgencyDocumentUpsertArgs} args - Arguments to update or create a AgencyDocument.
     * @example
     * // Update or create a AgencyDocument
     * const agencyDocument = await prisma.agencyDocument.upsert({
     *   create: {
     *     // ... data to create a AgencyDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyDocument we want to update
     *   }
     * })
     */
    upsert<T extends AgencyDocumentUpsertArgs>(args: SelectSubset<T, AgencyDocumentUpsertArgs<ExtArgs>>): Prisma__AgencyDocumentClient<$Result.GetResult<Prisma.$AgencyDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentCountArgs} args - Arguments to filter AgencyDocuments to count.
     * @example
     * // Count the number of AgencyDocuments
     * const count = await prisma.agencyDocument.count({
     *   where: {
     *     // ... the filter for the AgencyDocuments we want to count
     *   }
     * })
    **/
    count<T extends AgencyDocumentCountArgs>(
      args?: Subset<T, AgencyDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyDocumentAggregateArgs>(args: Subset<T, AgencyDocumentAggregateArgs>): Prisma.PrismaPromise<GetAgencyDocumentAggregateType<T>>

    /**
     * Group by AgencyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyDocumentGroupByArgs['orderBy'] }
        : { orderBy?: AgencyDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyDocument model
   */
  readonly fields: AgencyDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends AgencyDocument$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDocument$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyDocument model
   */
  interface AgencyDocumentFieldRefs {
    readonly id: FieldRef<"AgencyDocument", 'String'>
    readonly type: FieldRef<"AgencyDocument", 'DocumentType'>
    readonly url: FieldRef<"AgencyDocument", 'String'>
    readonly name: FieldRef<"AgencyDocument", 'String'>
    readonly description: FieldRef<"AgencyDocument", 'String'>
    readonly verified: FieldRef<"AgencyDocument", 'Boolean'>
    readonly comments: FieldRef<"AgencyDocument", 'String'>
    readonly expiryDate: FieldRef<"AgencyDocument", 'DateTime'>
    readonly agencyId: FieldRef<"AgencyDocument", 'String'>
    readonly verifiedById: FieldRef<"AgencyDocument", 'String'>
    readonly createdAt: FieldRef<"AgencyDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyDocument findUnique
   */
  export type AgencyDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyDocument to fetch.
     */
    where: AgencyDocumentWhereUniqueInput
  }

  /**
   * AgencyDocument findUniqueOrThrow
   */
  export type AgencyDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyDocument to fetch.
     */
    where: AgencyDocumentWhereUniqueInput
  }

  /**
   * AgencyDocument findFirst
   */
  export type AgencyDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyDocument to fetch.
     */
    where?: AgencyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyDocuments to fetch.
     */
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyDocuments.
     */
    cursor?: AgencyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyDocuments.
     */
    distinct?: AgencyDocumentScalarFieldEnum | AgencyDocumentScalarFieldEnum[]
  }

  /**
   * AgencyDocument findFirstOrThrow
   */
  export type AgencyDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyDocument to fetch.
     */
    where?: AgencyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyDocuments to fetch.
     */
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyDocuments.
     */
    cursor?: AgencyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyDocuments.
     */
    distinct?: AgencyDocumentScalarFieldEnum | AgencyDocumentScalarFieldEnum[]
  }

  /**
   * AgencyDocument findMany
   */
  export type AgencyDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgencyDocuments to fetch.
     */
    where?: AgencyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyDocuments to fetch.
     */
    orderBy?: AgencyDocumentOrderByWithRelationInput | AgencyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyDocuments.
     */
    cursor?: AgencyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyDocuments.
     */
    skip?: number
    distinct?: AgencyDocumentScalarFieldEnum | AgencyDocumentScalarFieldEnum[]
  }

  /**
   * AgencyDocument create
   */
  export type AgencyDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyDocument.
     */
    data: XOR<AgencyDocumentCreateInput, AgencyDocumentUncheckedCreateInput>
  }

  /**
   * AgencyDocument createMany
   */
  export type AgencyDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyDocuments.
     */
    data: AgencyDocumentCreateManyInput | AgencyDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyDocument createManyAndReturn
   */
  export type AgencyDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many AgencyDocuments.
     */
    data: AgencyDocumentCreateManyInput | AgencyDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyDocument update
   */
  export type AgencyDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyDocument.
     */
    data: XOR<AgencyDocumentUpdateInput, AgencyDocumentUncheckedUpdateInput>
    /**
     * Choose, which AgencyDocument to update.
     */
    where: AgencyDocumentWhereUniqueInput
  }

  /**
   * AgencyDocument updateMany
   */
  export type AgencyDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyDocuments.
     */
    data: XOR<AgencyDocumentUpdateManyMutationInput, AgencyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AgencyDocuments to update
     */
    where?: AgencyDocumentWhereInput
    /**
     * Limit how many AgencyDocuments to update.
     */
    limit?: number
  }

  /**
   * AgencyDocument updateManyAndReturn
   */
  export type AgencyDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * The data used to update AgencyDocuments.
     */
    data: XOR<AgencyDocumentUpdateManyMutationInput, AgencyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AgencyDocuments to update
     */
    where?: AgencyDocumentWhereInput
    /**
     * Limit how many AgencyDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyDocument upsert
   */
  export type AgencyDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyDocument to update in case it exists.
     */
    where: AgencyDocumentWhereUniqueInput
    /**
     * In case the AgencyDocument found by the `where` argument doesn't exist, create a new AgencyDocument with this data.
     */
    create: XOR<AgencyDocumentCreateInput, AgencyDocumentUncheckedCreateInput>
    /**
     * In case the AgencyDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyDocumentUpdateInput, AgencyDocumentUncheckedUpdateInput>
  }

  /**
   * AgencyDocument delete
   */
  export type AgencyDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
    /**
     * Filter which AgencyDocument to delete.
     */
    where: AgencyDocumentWhereUniqueInput
  }

  /**
   * AgencyDocument deleteMany
   */
  export type AgencyDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyDocuments to delete
     */
    where?: AgencyDocumentWhereInput
    /**
     * Limit how many AgencyDocuments to delete.
     */
    limit?: number
  }

  /**
   * AgencyDocument.verifiedBy
   */
  export type AgencyDocument$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AgencyDocument without action
   */
  export type AgencyDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyDocument
     */
    select?: AgencyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencyDocument
     */
    omit?: AgencyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyDocumentInclude<ExtArgs> | null
  }


  /**
   * Model RequirementDocument
   */

  export type AggregateRequirementDocument = {
    _count: RequirementDocumentCountAggregateOutputType | null
    _min: RequirementDocumentMinAggregateOutputType | null
    _max: RequirementDocumentMaxAggregateOutputType | null
  }

  export type RequirementDocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    requirementId: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementDocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    url: string | null
    name: string | null
    description: string | null
    requirementId: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementDocumentCountAggregateOutputType = {
    id: number
    type: number
    url: number
    name: number
    description: number
    requirementId: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequirementDocumentMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    requirementId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    requirementId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementDocumentCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    name?: true
    description?: true
    requirementId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequirementDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementDocument to aggregate.
     */
    where?: RequirementDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementDocuments to fetch.
     */
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequirementDocuments
    **/
    _count?: true | RequirementDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementDocumentMaxAggregateInputType
  }

  export type GetRequirementDocumentAggregateType<T extends RequirementDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirementDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirementDocument[P]>
      : GetScalarType<T[P], AggregateRequirementDocument[P]>
  }




  export type RequirementDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementDocumentWhereInput
    orderBy?: RequirementDocumentOrderByWithAggregationInput | RequirementDocumentOrderByWithAggregationInput[]
    by: RequirementDocumentScalarFieldEnum[] | RequirementDocumentScalarFieldEnum
    having?: RequirementDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementDocumentCountAggregateInputType | true
    _min?: RequirementDocumentMinAggregateInputType
    _max?: RequirementDocumentMaxAggregateInputType
  }

  export type RequirementDocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    url: string
    name: string | null
    description: string | null
    requirementId: string
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: RequirementDocumentCountAggregateOutputType | null
    _min: RequirementDocumentMinAggregateOutputType | null
    _max: RequirementDocumentMaxAggregateOutputType | null
  }

  type GetRequirementDocumentGroupByPayload<T extends RequirementDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementDocumentGroupByOutputType[P]>
        }
      >
    >


  export type RequirementDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    requirementId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementDocument"]>

  export type RequirementDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    requirementId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementDocument"]>

  export type RequirementDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    requirementId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementDocument"]>

  export type RequirementDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    requirementId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequirementDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "url" | "name" | "description" | "requirementId" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["requirementDocument"]>
  export type RequirementDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequirementDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequirementDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RequirementDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequirementDocument"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      url: string
      name: string | null
      description: string | null
      requirementId: string
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requirementDocument"]>
    composites: {}
  }

  type RequirementDocumentGetPayload<S extends boolean | null | undefined | RequirementDocumentDefaultArgs> = $Result.GetResult<Prisma.$RequirementDocumentPayload, S>

  type RequirementDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementDocumentCountAggregateInputType | true
    }

  export interface RequirementDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequirementDocument'], meta: { name: 'RequirementDocument' } }
    /**
     * Find zero or one RequirementDocument that matches the filter.
     * @param {RequirementDocumentFindUniqueArgs} args - Arguments to find a RequirementDocument
     * @example
     * // Get one RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementDocumentFindUniqueArgs>(args: SelectSubset<T, RequirementDocumentFindUniqueArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequirementDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementDocumentFindUniqueOrThrowArgs} args - Arguments to find a RequirementDocument
     * @example
     * // Get one RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentFindFirstArgs} args - Arguments to find a RequirementDocument
     * @example
     * // Get one RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementDocumentFindFirstArgs>(args?: SelectSubset<T, RequirementDocumentFindFirstArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentFindFirstOrThrowArgs} args - Arguments to find a RequirementDocument
     * @example
     * // Get one RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequirementDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequirementDocuments
     * const requirementDocuments = await prisma.requirementDocument.findMany()
     * 
     * // Get first 10 RequirementDocuments
     * const requirementDocuments = await prisma.requirementDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementDocumentWithIdOnly = await prisma.requirementDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementDocumentFindManyArgs>(args?: SelectSubset<T, RequirementDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequirementDocument.
     * @param {RequirementDocumentCreateArgs} args - Arguments to create a RequirementDocument.
     * @example
     * // Create one RequirementDocument
     * const RequirementDocument = await prisma.requirementDocument.create({
     *   data: {
     *     // ... data to create a RequirementDocument
     *   }
     * })
     * 
     */
    create<T extends RequirementDocumentCreateArgs>(args: SelectSubset<T, RequirementDocumentCreateArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequirementDocuments.
     * @param {RequirementDocumentCreateManyArgs} args - Arguments to create many RequirementDocuments.
     * @example
     * // Create many RequirementDocuments
     * const requirementDocument = await prisma.requirementDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementDocumentCreateManyArgs>(args?: SelectSubset<T, RequirementDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequirementDocuments and returns the data saved in the database.
     * @param {RequirementDocumentCreateManyAndReturnArgs} args - Arguments to create many RequirementDocuments.
     * @example
     * // Create many RequirementDocuments
     * const requirementDocument = await prisma.requirementDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequirementDocuments and only return the `id`
     * const requirementDocumentWithIdOnly = await prisma.requirementDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequirementDocument.
     * @param {RequirementDocumentDeleteArgs} args - Arguments to delete one RequirementDocument.
     * @example
     * // Delete one RequirementDocument
     * const RequirementDocument = await prisma.requirementDocument.delete({
     *   where: {
     *     // ... filter to delete one RequirementDocument
     *   }
     * })
     * 
     */
    delete<T extends RequirementDocumentDeleteArgs>(args: SelectSubset<T, RequirementDocumentDeleteArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequirementDocument.
     * @param {RequirementDocumentUpdateArgs} args - Arguments to update one RequirementDocument.
     * @example
     * // Update one RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementDocumentUpdateArgs>(args: SelectSubset<T, RequirementDocumentUpdateArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequirementDocuments.
     * @param {RequirementDocumentDeleteManyArgs} args - Arguments to filter RequirementDocuments to delete.
     * @example
     * // Delete a few RequirementDocuments
     * const { count } = await prisma.requirementDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementDocumentDeleteManyArgs>(args?: SelectSubset<T, RequirementDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequirementDocuments
     * const requirementDocument = await prisma.requirementDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementDocumentUpdateManyArgs>(args: SelectSubset<T, RequirementDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementDocuments and returns the data updated in the database.
     * @param {RequirementDocumentUpdateManyAndReturnArgs} args - Arguments to update many RequirementDocuments.
     * @example
     * // Update many RequirementDocuments
     * const requirementDocument = await prisma.requirementDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequirementDocuments and only return the `id`
     * const requirementDocumentWithIdOnly = await prisma.requirementDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequirementDocument.
     * @param {RequirementDocumentUpsertArgs} args - Arguments to update or create a RequirementDocument.
     * @example
     * // Update or create a RequirementDocument
     * const requirementDocument = await prisma.requirementDocument.upsert({
     *   create: {
     *     // ... data to create a RequirementDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequirementDocument we want to update
     *   }
     * })
     */
    upsert<T extends RequirementDocumentUpsertArgs>(args: SelectSubset<T, RequirementDocumentUpsertArgs<ExtArgs>>): Prisma__RequirementDocumentClient<$Result.GetResult<Prisma.$RequirementDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequirementDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentCountArgs} args - Arguments to filter RequirementDocuments to count.
     * @example
     * // Count the number of RequirementDocuments
     * const count = await prisma.requirementDocument.count({
     *   where: {
     *     // ... the filter for the RequirementDocuments we want to count
     *   }
     * })
    **/
    count<T extends RequirementDocumentCountArgs>(
      args?: Subset<T, RequirementDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequirementDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementDocumentAggregateArgs>(args: Subset<T, RequirementDocumentAggregateArgs>): Prisma.PrismaPromise<GetRequirementDocumentAggregateType<T>>

    /**
     * Group by RequirementDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementDocumentGroupByArgs['orderBy'] }
        : { orderBy?: RequirementDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequirementDocument model
   */
  readonly fields: RequirementDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequirementDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequirementDocument model
   */
  interface RequirementDocumentFieldRefs {
    readonly id: FieldRef<"RequirementDocument", 'String'>
    readonly type: FieldRef<"RequirementDocument", 'DocumentType'>
    readonly url: FieldRef<"RequirementDocument", 'String'>
    readonly name: FieldRef<"RequirementDocument", 'String'>
    readonly description: FieldRef<"RequirementDocument", 'String'>
    readonly requirementId: FieldRef<"RequirementDocument", 'String'>
    readonly uploadedById: FieldRef<"RequirementDocument", 'String'>
    readonly createdAt: FieldRef<"RequirementDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"RequirementDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequirementDocument findUnique
   */
  export type RequirementDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementDocument to fetch.
     */
    where: RequirementDocumentWhereUniqueInput
  }

  /**
   * RequirementDocument findUniqueOrThrow
   */
  export type RequirementDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementDocument to fetch.
     */
    where: RequirementDocumentWhereUniqueInput
  }

  /**
   * RequirementDocument findFirst
   */
  export type RequirementDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementDocument to fetch.
     */
    where?: RequirementDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementDocuments to fetch.
     */
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementDocuments.
     */
    cursor?: RequirementDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementDocuments.
     */
    distinct?: RequirementDocumentScalarFieldEnum | RequirementDocumentScalarFieldEnum[]
  }

  /**
   * RequirementDocument findFirstOrThrow
   */
  export type RequirementDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementDocument to fetch.
     */
    where?: RequirementDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementDocuments to fetch.
     */
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementDocuments.
     */
    cursor?: RequirementDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementDocuments.
     */
    distinct?: RequirementDocumentScalarFieldEnum | RequirementDocumentScalarFieldEnum[]
  }

  /**
   * RequirementDocument findMany
   */
  export type RequirementDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementDocuments to fetch.
     */
    where?: RequirementDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementDocuments to fetch.
     */
    orderBy?: RequirementDocumentOrderByWithRelationInput | RequirementDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequirementDocuments.
     */
    cursor?: RequirementDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementDocuments.
     */
    skip?: number
    distinct?: RequirementDocumentScalarFieldEnum | RequirementDocumentScalarFieldEnum[]
  }

  /**
   * RequirementDocument create
   */
  export type RequirementDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a RequirementDocument.
     */
    data: XOR<RequirementDocumentCreateInput, RequirementDocumentUncheckedCreateInput>
  }

  /**
   * RequirementDocument createMany
   */
  export type RequirementDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequirementDocuments.
     */
    data: RequirementDocumentCreateManyInput | RequirementDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequirementDocument createManyAndReturn
   */
  export type RequirementDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many RequirementDocuments.
     */
    data: RequirementDocumentCreateManyInput | RequirementDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementDocument update
   */
  export type RequirementDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a RequirementDocument.
     */
    data: XOR<RequirementDocumentUpdateInput, RequirementDocumentUncheckedUpdateInput>
    /**
     * Choose, which RequirementDocument to update.
     */
    where: RequirementDocumentWhereUniqueInput
  }

  /**
   * RequirementDocument updateMany
   */
  export type RequirementDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequirementDocuments.
     */
    data: XOR<RequirementDocumentUpdateManyMutationInput, RequirementDocumentUncheckedUpdateManyInput>
    /**
     * Filter which RequirementDocuments to update
     */
    where?: RequirementDocumentWhereInput
    /**
     * Limit how many RequirementDocuments to update.
     */
    limit?: number
  }

  /**
   * RequirementDocument updateManyAndReturn
   */
  export type RequirementDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * The data used to update RequirementDocuments.
     */
    data: XOR<RequirementDocumentUpdateManyMutationInput, RequirementDocumentUncheckedUpdateManyInput>
    /**
     * Filter which RequirementDocuments to update
     */
    where?: RequirementDocumentWhereInput
    /**
     * Limit how many RequirementDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementDocument upsert
   */
  export type RequirementDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the RequirementDocument to update in case it exists.
     */
    where: RequirementDocumentWhereUniqueInput
    /**
     * In case the RequirementDocument found by the `where` argument doesn't exist, create a new RequirementDocument with this data.
     */
    create: XOR<RequirementDocumentCreateInput, RequirementDocumentUncheckedCreateInput>
    /**
     * In case the RequirementDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementDocumentUpdateInput, RequirementDocumentUncheckedUpdateInput>
  }

  /**
   * RequirementDocument delete
   */
  export type RequirementDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
    /**
     * Filter which RequirementDocument to delete.
     */
    where: RequirementDocumentWhereUniqueInput
  }

  /**
   * RequirementDocument deleteMany
   */
  export type RequirementDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementDocuments to delete
     */
    where?: RequirementDocumentWhereInput
    /**
     * Limit how many RequirementDocuments to delete.
     */
    limit?: number
  }

  /**
   * RequirementDocument without action
   */
  export type RequirementDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementDocument
     */
    select?: RequirementDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementDocument
     */
    omit?: RequirementDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementDocumentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.AuditAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    performedById: string | null
    performedAt: Date | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.AuditAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    performedById: string | null
    performedAt: Date | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    description: number
    oldData: number
    newData: number
    affectedFields: number
    ipAddress: number
    userAgent: number
    performedById: number
    performedAt: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    oldData?: true
    newData?: true
    affectedFields?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description: string | null
    oldData: JsonValue | null
    newData: JsonValue | null
    affectedFields: string[]
    ipAddress: string | null
    userAgent: string | null
    performedById: string
    performedAt: Date
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "description" | "oldData" | "newData" | "affectedFields" | "ipAddress" | "userAgent" | "performedById" | "performedAt" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      performedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.AuditAction
      entityType: string
      entityId: string
      description: string | null
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      affectedFields: string[]
      ipAddress: string | null
      userAgent: string | null
      performedById: string
      performedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly affectedFields: FieldRef<"AuditLog", 'String[]'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly performedById: FieldRef<"AuditLog", 'String'>
    readonly performedAt: FieldRef<"AuditLog", 'DateTime'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    actionUrl: string | null
    recipientId: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    actionUrl: string | null
    recipientId: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    read: number
    actionUrl: number
    metadata: number
    recipientId: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    metadata?: true
    recipientId?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: $Enums.NotificationType
    read: boolean
    actionUrl: string | null
    metadata: JsonValue | null
    recipientId: string
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    metadata?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    metadata?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    metadata?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    metadata?: boolean
    recipientId?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "read" | "actionUrl" | "metadata" | "recipientId" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: $Enums.NotificationType
      read: boolean
      actionUrl: string | null
      metadata: Prisma.JsonValue | null
      recipientId: string
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    altContact: 'altContact',
    profilePicture: 'profilePicture',
    role: 'role',
    status: 'status',
    resetRequired: 'resetRequired',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleteAt: 'deleteAt',
    deletionType: 'deletionType',
    deletionReason: 'deletionReason',
    deletionRequestedBy: 'deletionRequestedBy',
    createdById: 'createdById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    registrationNo: 'registrationNo',
    companySector: 'companySector',
    companySize: 'companySize',
    website: 'website',
    address: 'address',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    designation: 'designation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agencyName: 'agencyName',
    registrationNo: 'registrationNo',
    licenseNumber: 'licenseNumber',
    licenseExpiry: 'licenseExpiry',
    country: 'country',
    website: 'website',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    department: 'department',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const RequirementScalarFieldEnum: {
    id: 'id',
    specialNotes: 'specialNotes',
    status: 'status',
    languages: 'languages',
    minExperience: 'minExperience',
    maxAge: 'maxAge',
    ticketType: 'ticketType',
    ticketProvided: 'ticketProvided',
    clientId: 'clientId',
    assignedAgencyId: 'assignedAgencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt'
  };

  export type RequirementScalarFieldEnum = (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum]


  export const JobRoleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    quantity: 'quantity',
    nationality: 'nationality',
    salary: 'salary',
    salaryCurrency: 'salaryCurrency',
    startDate: 'startDate',
    contractDuration: 'contractDuration',
    requirementId: 'requirementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobRoleScalarFieldEnum = (typeof JobRoleScalarFieldEnum)[keyof typeof JobRoleScalarFieldEnum]


  export const LabourProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    age: 'age',
    gender: 'gender',
    nationality: 'nationality',
    maritalStatus: 'maritalStatus',
    skills: 'skills',
    experienceYears: 'experienceYears',
    education: 'education',
    currentPosition: 'currentPosition',
    currentCompany: 'currentCompany',
    languages: 'languages',
    englishProficiency: 'englishProficiency',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    country: 'country',
    cvUrl: 'cvUrl',
    passportNumber: 'passportNumber',
    passportExpiry: 'passportExpiry',
    visaType: 'visaType',
    visaExpiry: 'visaExpiry',
    medicalStatus: 'medicalStatus',
    medicalExpiry: 'medicalExpiry',
    photo: 'photo',
    otherDocs: 'otherDocs',
    status: 'status',
    statusReason: 'statusReason',
    requirementId: 'requirementId',
    agencyId: 'agencyId',
    deploymentDate: 'deploymentDate',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabourProfileScalarFieldEnum = (typeof LabourProfileScalarFieldEnum)[keyof typeof LabourProfileScalarFieldEnum]


  export const ProcedureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    comments: 'comments',
    metadata: 'metadata',
    requirementId: 'requirementId',
    labourProfileId: 'labourProfileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcedureScalarFieldEnum = (typeof ProcedureScalarFieldEnum)[keyof typeof ProcedureScalarFieldEnum]


  export const LabourStatusLogScalarFieldEnum: {
    id: 'id',
    status: 'status',
    comments: 'comments',
    metadata: 'metadata',
    labourProfileId: 'labourProfileId',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type LabourStatusLogScalarFieldEnum = (typeof LabourStatusLogScalarFieldEnum)[keyof typeof LabourStatusLogScalarFieldEnum]


  export const ClientDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    name: 'name',
    description: 'description',
    verified: 'verified',
    comments: 'comments',
    expiryDate: 'expiryDate',
    clientId: 'clientId',
    verifiedById: 'verifiedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientDocumentScalarFieldEnum = (typeof ClientDocumentScalarFieldEnum)[keyof typeof ClientDocumentScalarFieldEnum]


  export const AgencyDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    name: 'name',
    description: 'description',
    verified: 'verified',
    comments: 'comments',
    expiryDate: 'expiryDate',
    agencyId: 'agencyId',
    verifiedById: 'verifiedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyDocumentScalarFieldEnum = (typeof AgencyDocumentScalarFieldEnum)[keyof typeof AgencyDocumentScalarFieldEnum]


  export const RequirementDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    name: 'name',
    description: 'description',
    requirementId: 'requirementId',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequirementDocumentScalarFieldEnum = (typeof RequirementDocumentScalarFieldEnum)[keyof typeof RequirementDocumentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    description: 'description',
    oldData: 'oldData',
    newData: 'newData',
    affectedFields: 'affectedFields',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    performedById: 'performedById',
    performedAt: 'performedAt',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    actionUrl: 'actionUrl',
    metadata: 'metadata',
    recipientId: 'recipientId',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DeletionType'
   */
  export type EnumDeletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeletionType'>
    


  /**
   * Reference to a field of type 'DeletionType[]'
   */
  export type ListEnumDeletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeletionType[]'>
    


  /**
   * Reference to a field of type 'CompanySector'
   */
  export type EnumCompanySectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySector'>
    


  /**
   * Reference to a field of type 'CompanySector[]'
   */
  export type ListEnumCompanySectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySector[]'>
    


  /**
   * Reference to a field of type 'CompanySize'
   */
  export type EnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize'>
    


  /**
   * Reference to a field of type 'CompanySize[]'
   */
  export type ListEnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus'>
    


  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>
    


  /**
   * Reference to a field of type 'ExperienceLevel'
   */
  export type EnumExperienceLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExperienceLevel'>
    


  /**
   * Reference to a field of type 'ExperienceLevel[]'
   */
  export type ListEnumExperienceLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExperienceLevel[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TicketType'
   */
  export type EnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType'>
    


  /**
   * Reference to a field of type 'TicketType[]'
   */
  export type ListEnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ContractDuration'
   */
  export type EnumContractDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractDuration'>
    


  /**
   * Reference to a field of type 'ContractDuration[]'
   */
  export type ListEnumContractDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractDuration[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'LabourProfileStatus'
   */
  export type EnumLabourProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourProfileStatus'>
    


  /**
   * Reference to a field of type 'LabourProfileStatus[]'
   */
  export type ListEnumLabourProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourProfileStatus[]'>
    


  /**
   * Reference to a field of type 'ProcedureStatus'
   */
  export type EnumProcedureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcedureStatus'>
    


  /**
   * Reference to a field of type 'ProcedureStatus[]'
   */
  export type ListEnumProcedureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcedureStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agencyProfile?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    statusLogs?: LabourStatusLogListRelationFilter
    clientDocuments?: ClientDocumentListRelationFilter
    agencyDocuments?: AgencyDocumentListRelationFilter
    requirementDocuments?: RequirementDocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    altContact?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrderInput | SortOrder
    deletionType?: SortOrderInput | SortOrder
    deletionReason?: SortOrderInput | SortOrder
    deletionRequestedBy?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    clientProfile?: ClientOrderByWithRelationInput
    agencyProfile?: AgencyOrderByWithRelationInput
    adminProfile?: AdminOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    statusLogs?: LabourStatusLogOrderByRelationAggregateInput
    clientDocuments?: ClientDocumentOrderByRelationAggregateInput
    agencyDocuments?: AgencyDocumentOrderByRelationAggregateInput
    requirementDocuments?: RequirementDocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agencyProfile?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    statusLogs?: LabourStatusLogListRelationFilter
    clientDocuments?: ClientDocumentListRelationFilter
    agencyDocuments?: AgencyDocumentListRelationFilter
    requirementDocuments?: RequirementDocumentListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    altContact?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrderInput | SortOrder
    deletionType?: SortOrderInput | SortOrder
    deletionReason?: SortOrderInput | SortOrder
    deletionRequestedBy?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    altContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableWithAggregatesFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    companyName?: StringFilter<"Client"> | string
    registrationNo?: StringNullableFilter<"Client"> | string | null
    companySector?: EnumCompanySectorFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableFilter<"Client"> | string | null
    address?: StringFilter<"Client"> | string
    city?: StringFilter<"Client"> | string
    country?: StringFilter<"Client"> | string
    postalCode?: StringNullableFilter<"Client"> | string | null
    designation?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    requirements?: RequirementListRelationFilter
    documents?: ClientDocumentListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    requirements?: RequirementOrderByRelationAggregateInput
    documents?: ClientDocumentOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    registrationNo?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    companyName?: StringFilter<"Client"> | string
    companySector?: EnumCompanySectorFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableFilter<"Client"> | string | null
    address?: StringFilter<"Client"> | string
    city?: StringFilter<"Client"> | string
    country?: StringFilter<"Client"> | string
    postalCode?: StringNullableFilter<"Client"> | string | null
    designation?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    requirements?: RequirementListRelationFilter
    documents?: ClientDocumentListRelationFilter
  }, "id" | "userId" | "registrationNo">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringWithAggregatesFilter<"Client"> | string
    companyName?: StringWithAggregatesFilter<"Client"> | string
    registrationNo?: StringNullableWithAggregatesFilter<"Client"> | string | null
    companySector?: EnumCompanySectorWithAggregatesFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeWithAggregatesFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringWithAggregatesFilter<"Client"> | string
    city?: StringWithAggregatesFilter<"Client"> | string
    country?: StringWithAggregatesFilter<"Client"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    designation?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    userId?: StringFilter<"Agency"> | string
    agencyName?: StringFilter<"Agency"> | string
    registrationNo?: StringNullableFilter<"Agency"> | string | null
    licenseNumber?: StringFilter<"Agency"> | string
    licenseExpiry?: DateTimeFilter<"Agency"> | Date | string
    country?: StringFilter<"Agency"> | string
    website?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    postalCode?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    labourProfiles?: LabourProfileListRelationFilter
    requirements?: RequirementListRelationFilter
    documents?: AgencyDocumentListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    labourProfiles?: LabourProfileOrderByRelationAggregateInput
    requirements?: RequirementOrderByRelationAggregateInput
    documents?: AgencyDocumentOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    registrationNo?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    agencyName?: StringFilter<"Agency"> | string
    licenseNumber?: StringFilter<"Agency"> | string
    licenseExpiry?: DateTimeFilter<"Agency"> | Date | string
    country?: StringFilter<"Agency"> | string
    website?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    postalCode?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    labourProfiles?: LabourProfileListRelationFilter
    requirements?: RequirementListRelationFilter
    documents?: AgencyDocumentListRelationFilter
  }, "id" | "userId" | "registrationNo">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    userId?: StringWithAggregatesFilter<"Agency"> | string
    agencyName?: StringWithAggregatesFilter<"Agency"> | string
    registrationNo?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    licenseNumber?: StringWithAggregatesFilter<"Agency"> | string
    licenseExpiry?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    country?: StringWithAggregatesFilter<"Agency"> | string
    website?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    address?: StringWithAggregatesFilter<"Agency"> | string
    city?: StringWithAggregatesFilter<"Agency"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    department?: StringNullableFilter<"Admin"> | string | null
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    department?: StringNullableFilter<"Admin"> | string | null
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    department?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    permissions?: JsonNullableWithAggregatesFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type RequirementWhereInput = {
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    id?: StringFilter<"Requirement"> | string
    specialNotes?: StringNullableFilter<"Requirement"> | string | null
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    languages?: StringNullableListFilter<"Requirement">
    minExperience?: EnumExperienceLevelNullableFilter<"Requirement"> | $Enums.ExperienceLevel | null
    maxAge?: IntNullableFilter<"Requirement"> | number | null
    ticketType?: EnumTicketTypeNullableFilter<"Requirement"> | $Enums.TicketType | null
    ticketProvided?: BoolFilter<"Requirement"> | boolean
    clientId?: StringFilter<"Requirement"> | string
    assignedAgencyId?: StringNullableFilter<"Requirement"> | string | null
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    submittedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    assignedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    jobRoles?: JobRoleListRelationFilter
    labourProfiles?: LabourProfileListRelationFilter
    procedures?: ProcedureListRelationFilter
    documents?: RequirementDocumentListRelationFilter
  }

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder
    specialNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    languages?: SortOrder
    minExperience?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    ticketType?: SortOrderInput | SortOrder
    ticketProvided?: SortOrder
    clientId?: SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    assignedAgency?: AgencyOrderByWithRelationInput
    jobRoles?: JobRoleOrderByRelationAggregateInput
    labourProfiles?: LabourProfileOrderByRelationAggregateInput
    procedures?: ProcedureOrderByRelationAggregateInput
    documents?: RequirementDocumentOrderByRelationAggregateInput
  }

  export type RequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    specialNotes?: StringNullableFilter<"Requirement"> | string | null
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    languages?: StringNullableListFilter<"Requirement">
    minExperience?: EnumExperienceLevelNullableFilter<"Requirement"> | $Enums.ExperienceLevel | null
    maxAge?: IntNullableFilter<"Requirement"> | number | null
    ticketType?: EnumTicketTypeNullableFilter<"Requirement"> | $Enums.TicketType | null
    ticketProvided?: BoolFilter<"Requirement"> | boolean
    clientId?: StringFilter<"Requirement"> | string
    assignedAgencyId?: StringNullableFilter<"Requirement"> | string | null
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    submittedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    assignedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    jobRoles?: JobRoleListRelationFilter
    labourProfiles?: LabourProfileListRelationFilter
    procedures?: ProcedureListRelationFilter
    documents?: RequirementDocumentListRelationFilter
  }, "id">

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder
    specialNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    languages?: SortOrder
    minExperience?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    ticketType?: SortOrderInput | SortOrder
    ticketProvided?: SortOrder
    clientId?: SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: RequirementCountOrderByAggregateInput
    _avg?: RequirementAvgOrderByAggregateInput
    _max?: RequirementMaxOrderByAggregateInput
    _min?: RequirementMinOrderByAggregateInput
    _sum?: RequirementSumOrderByAggregateInput
  }

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    OR?: RequirementScalarWhereWithAggregatesInput[]
    NOT?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requirement"> | string
    specialNotes?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    status?: EnumRequirementStatusWithAggregatesFilter<"Requirement"> | $Enums.RequirementStatus
    languages?: StringNullableListFilter<"Requirement">
    minExperience?: EnumExperienceLevelNullableWithAggregatesFilter<"Requirement"> | $Enums.ExperienceLevel | null
    maxAge?: IntNullableWithAggregatesFilter<"Requirement"> | number | null
    ticketType?: EnumTicketTypeNullableWithAggregatesFilter<"Requirement"> | $Enums.TicketType | null
    ticketProvided?: BoolWithAggregatesFilter<"Requirement"> | boolean
    clientId?: StringWithAggregatesFilter<"Requirement"> | string
    assignedAgencyId?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Requirement"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Requirement"> | Date | string | null
  }

  export type JobRoleWhereInput = {
    AND?: JobRoleWhereInput | JobRoleWhereInput[]
    OR?: JobRoleWhereInput[]
    NOT?: JobRoleWhereInput | JobRoleWhereInput[]
    id?: StringFilter<"JobRole"> | string
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    salary?: FloatNullableFilter<"JobRole"> | number | null
    salaryCurrency?: StringFilter<"JobRole"> | string
    startDate?: DateTimeNullableFilter<"JobRole"> | Date | string | null
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    requirementId?: StringFilter<"JobRole"> | string
    createdAt?: DateTimeFilter<"JobRole"> | Date | string
    updatedAt?: DateTimeFilter<"JobRole"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
  }

  export type JobRoleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    salary?: SortOrderInput | SortOrder
    salaryCurrency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    contractDuration?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
  }

  export type JobRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobRoleWhereInput | JobRoleWhereInput[]
    OR?: JobRoleWhereInput[]
    NOT?: JobRoleWhereInput | JobRoleWhereInput[]
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    salary?: FloatNullableFilter<"JobRole"> | number | null
    salaryCurrency?: StringFilter<"JobRole"> | string
    startDate?: DateTimeNullableFilter<"JobRole"> | Date | string | null
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    requirementId?: StringFilter<"JobRole"> | string
    createdAt?: DateTimeFilter<"JobRole"> | Date | string
    updatedAt?: DateTimeFilter<"JobRole"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
  }, "id">

  export type JobRoleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    salary?: SortOrderInput | SortOrder
    salaryCurrency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    contractDuration?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobRoleCountOrderByAggregateInput
    _avg?: JobRoleAvgOrderByAggregateInput
    _max?: JobRoleMaxOrderByAggregateInput
    _min?: JobRoleMinOrderByAggregateInput
    _sum?: JobRoleSumOrderByAggregateInput
  }

  export type JobRoleScalarWhereWithAggregatesInput = {
    AND?: JobRoleScalarWhereWithAggregatesInput | JobRoleScalarWhereWithAggregatesInput[]
    OR?: JobRoleScalarWhereWithAggregatesInput[]
    NOT?: JobRoleScalarWhereWithAggregatesInput | JobRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobRole"> | string
    title?: StringWithAggregatesFilter<"JobRole"> | string
    quantity?: IntWithAggregatesFilter<"JobRole"> | number
    nationality?: StringWithAggregatesFilter<"JobRole"> | string
    salary?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    salaryCurrency?: StringWithAggregatesFilter<"JobRole"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"JobRole"> | Date | string | null
    contractDuration?: EnumContractDurationNullableWithAggregatesFilter<"JobRole"> | $Enums.ContractDuration | null
    requirementId?: StringWithAggregatesFilter<"JobRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobRole"> | Date | string
  }

  export type LabourProfileWhereInput = {
    AND?: LabourProfileWhereInput | LabourProfileWhereInput[]
    OR?: LabourProfileWhereInput[]
    NOT?: LabourProfileWhereInput | LabourProfileWhereInput[]
    id?: StringFilter<"LabourProfile"> | string
    name?: StringFilter<"LabourProfile"> | string
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    maritalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experienceYears?: IntFilter<"LabourProfile"> | number
    education?: StringNullableFilter<"LabourProfile"> | string | null
    currentPosition?: StringNullableFilter<"LabourProfile"> | string | null
    currentCompany?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    englishProficiency?: StringNullableFilter<"LabourProfile"> | string | null
    email?: StringNullableFilter<"LabourProfile"> | string | null
    phone?: StringFilter<"LabourProfile"> | string
    address?: StringNullableFilter<"LabourProfile"> | string | null
    city?: StringNullableFilter<"LabourProfile"> | string | null
    country?: StringNullableFilter<"LabourProfile"> | string | null
    cvUrl?: StringFilter<"LabourProfile"> | string
    passportNumber?: StringNullableFilter<"LabourProfile"> | string | null
    passportExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    medicalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    medicalExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    photo?: StringNullableFilter<"LabourProfile"> | string | null
    otherDocs?: StringNullableListFilter<"LabourProfile">
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    statusReason?: StringNullableFilter<"LabourProfile"> | string | null
    requirementId?: StringFilter<"LabourProfile"> | string
    agencyId?: StringFilter<"LabourProfile"> | string
    deploymentDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractStartDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    statusLogs?: LabourStatusLogListRelationFilter
    procedures?: ProcedureListRelationFilter
  }

  export type LabourProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    skills?: SortOrder
    experienceYears?: SortOrder
    education?: SortOrderInput | SortOrder
    currentPosition?: SortOrderInput | SortOrder
    currentCompany?: SortOrderInput | SortOrder
    languages?: SortOrder
    englishProficiency?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    cvUrl?: SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    visaType?: SortOrderInput | SortOrder
    visaExpiry?: SortOrderInput | SortOrder
    medicalStatus?: SortOrderInput | SortOrder
    medicalExpiry?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    otherDocs?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    deploymentDate?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    statusLogs?: LabourStatusLogOrderByRelationAggregateInput
    procedures?: ProcedureOrderByRelationAggregateInput
  }

  export type LabourProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabourProfileWhereInput | LabourProfileWhereInput[]
    OR?: LabourProfileWhereInput[]
    NOT?: LabourProfileWhereInput | LabourProfileWhereInput[]
    name?: StringFilter<"LabourProfile"> | string
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    maritalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experienceYears?: IntFilter<"LabourProfile"> | number
    education?: StringNullableFilter<"LabourProfile"> | string | null
    currentPosition?: StringNullableFilter<"LabourProfile"> | string | null
    currentCompany?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    englishProficiency?: StringNullableFilter<"LabourProfile"> | string | null
    email?: StringNullableFilter<"LabourProfile"> | string | null
    phone?: StringFilter<"LabourProfile"> | string
    address?: StringNullableFilter<"LabourProfile"> | string | null
    city?: StringNullableFilter<"LabourProfile"> | string | null
    country?: StringNullableFilter<"LabourProfile"> | string | null
    cvUrl?: StringFilter<"LabourProfile"> | string
    passportNumber?: StringNullableFilter<"LabourProfile"> | string | null
    passportExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    medicalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    medicalExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    photo?: StringNullableFilter<"LabourProfile"> | string | null
    otherDocs?: StringNullableListFilter<"LabourProfile">
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    statusReason?: StringNullableFilter<"LabourProfile"> | string | null
    requirementId?: StringFilter<"LabourProfile"> | string
    agencyId?: StringFilter<"LabourProfile"> | string
    deploymentDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractStartDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    statusLogs?: LabourStatusLogListRelationFilter
    procedures?: ProcedureListRelationFilter
  }, "id">

  export type LabourProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    skills?: SortOrder
    experienceYears?: SortOrder
    education?: SortOrderInput | SortOrder
    currentPosition?: SortOrderInput | SortOrder
    currentCompany?: SortOrderInput | SortOrder
    languages?: SortOrder
    englishProficiency?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    cvUrl?: SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    visaType?: SortOrderInput | SortOrder
    visaExpiry?: SortOrderInput | SortOrder
    medicalStatus?: SortOrderInput | SortOrder
    medicalExpiry?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    otherDocs?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    deploymentDate?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabourProfileCountOrderByAggregateInput
    _avg?: LabourProfileAvgOrderByAggregateInput
    _max?: LabourProfileMaxOrderByAggregateInput
    _min?: LabourProfileMinOrderByAggregateInput
    _sum?: LabourProfileSumOrderByAggregateInput
  }

  export type LabourProfileScalarWhereWithAggregatesInput = {
    AND?: LabourProfileScalarWhereWithAggregatesInput | LabourProfileScalarWhereWithAggregatesInput[]
    OR?: LabourProfileScalarWhereWithAggregatesInput[]
    NOT?: LabourProfileScalarWhereWithAggregatesInput | LabourProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourProfile"> | string
    name?: StringWithAggregatesFilter<"LabourProfile"> | string
    age?: IntWithAggregatesFilter<"LabourProfile"> | number
    gender?: EnumGenderWithAggregatesFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringWithAggregatesFilter<"LabourProfile"> | string
    maritalStatus?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experienceYears?: IntWithAggregatesFilter<"LabourProfile"> | number
    education?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    currentPosition?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    currentCompany?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    englishProficiency?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    email?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    phone?: StringWithAggregatesFilter<"LabourProfile"> | string
    address?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    cvUrl?: StringWithAggregatesFilter<"LabourProfile"> | string
    passportNumber?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    passportExpiry?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    visaType?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    medicalStatus?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    medicalExpiry?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    photo?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    otherDocs?: StringNullableListFilter<"LabourProfile">
    status?: EnumLabourProfileStatusWithAggregatesFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    statusReason?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    requirementId?: StringWithAggregatesFilter<"LabourProfile"> | string
    agencyId?: StringWithAggregatesFilter<"LabourProfile"> | string
    deploymentDate?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    contractStartDate?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabourProfile"> | Date | string
  }

  export type ProcedureWhereInput = {
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    id?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    description?: StringFilter<"Procedure"> | string
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    dueDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    comments?: StringNullableFilter<"Procedure"> | string | null
    metadata?: JsonNullableFilter<"Procedure">
    requirementId?: StringNullableFilter<"Procedure"> | string | null
    labourProfileId?: StringNullableFilter<"Procedure"> | string | null
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
    requirement?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    labourProfile?: XOR<LabourProfileNullableScalarRelationFilter, LabourProfileWhereInput> | null
  }

  export type ProcedureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    requirementId?: SortOrderInput | SortOrder
    labourProfileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
    labourProfile?: LabourProfileOrderByWithRelationInput
  }

  export type ProcedureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    name?: StringFilter<"Procedure"> | string
    description?: StringFilter<"Procedure"> | string
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    dueDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    comments?: StringNullableFilter<"Procedure"> | string | null
    metadata?: JsonNullableFilter<"Procedure">
    requirementId?: StringNullableFilter<"Procedure"> | string | null
    labourProfileId?: StringNullableFilter<"Procedure"> | string | null
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
    requirement?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    labourProfile?: XOR<LabourProfileNullableScalarRelationFilter, LabourProfileWhereInput> | null
  }, "id">

  export type ProcedureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    requirementId?: SortOrderInput | SortOrder
    labourProfileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcedureCountOrderByAggregateInput
    _max?: ProcedureMaxOrderByAggregateInput
    _min?: ProcedureMinOrderByAggregateInput
  }

  export type ProcedureScalarWhereWithAggregatesInput = {
    AND?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    OR?: ProcedureScalarWhereWithAggregatesInput[]
    NOT?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Procedure"> | string
    name?: StringWithAggregatesFilter<"Procedure"> | string
    description?: StringWithAggregatesFilter<"Procedure"> | string
    status?: EnumProcedureStatusWithAggregatesFilter<"Procedure"> | $Enums.ProcedureStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Procedure"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Procedure"> | Date | string | null
    comments?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Procedure">
    requirementId?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
    labourProfileId?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Procedure"> | Date | string
  }

  export type LabourStatusLogWhereInput = {
    AND?: LabourStatusLogWhereInput | LabourStatusLogWhereInput[]
    OR?: LabourStatusLogWhereInput[]
    NOT?: LabourStatusLogWhereInput | LabourStatusLogWhereInput[]
    id?: StringFilter<"LabourStatusLog"> | string
    status?: EnumLabourProfileStatusFilter<"LabourStatusLog"> | $Enums.LabourProfileStatus
    comments?: StringNullableFilter<"LabourStatusLog"> | string | null
    metadata?: JsonNullableFilter<"LabourStatusLog">
    labourProfileId?: StringFilter<"LabourStatusLog"> | string
    changedById?: StringFilter<"LabourStatusLog"> | string
    createdAt?: DateTimeFilter<"LabourStatusLog"> | Date | string
    labourProfile?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LabourStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    labourProfileId?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    labourProfile?: LabourProfileOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type LabourStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabourStatusLogWhereInput | LabourStatusLogWhereInput[]
    OR?: LabourStatusLogWhereInput[]
    NOT?: LabourStatusLogWhereInput | LabourStatusLogWhereInput[]
    status?: EnumLabourProfileStatusFilter<"LabourStatusLog"> | $Enums.LabourProfileStatus
    comments?: StringNullableFilter<"LabourStatusLog"> | string | null
    metadata?: JsonNullableFilter<"LabourStatusLog">
    labourProfileId?: StringFilter<"LabourStatusLog"> | string
    changedById?: StringFilter<"LabourStatusLog"> | string
    createdAt?: DateTimeFilter<"LabourStatusLog"> | Date | string
    labourProfile?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LabourStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    labourProfileId?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    _count?: LabourStatusLogCountOrderByAggregateInput
    _max?: LabourStatusLogMaxOrderByAggregateInput
    _min?: LabourStatusLogMinOrderByAggregateInput
  }

  export type LabourStatusLogScalarWhereWithAggregatesInput = {
    AND?: LabourStatusLogScalarWhereWithAggregatesInput | LabourStatusLogScalarWhereWithAggregatesInput[]
    OR?: LabourStatusLogScalarWhereWithAggregatesInput[]
    NOT?: LabourStatusLogScalarWhereWithAggregatesInput | LabourStatusLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourStatusLog"> | string
    status?: EnumLabourProfileStatusWithAggregatesFilter<"LabourStatusLog"> | $Enums.LabourProfileStatus
    comments?: StringNullableWithAggregatesFilter<"LabourStatusLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"LabourStatusLog">
    labourProfileId?: StringWithAggregatesFilter<"LabourStatusLog"> | string
    changedById?: StringWithAggregatesFilter<"LabourStatusLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LabourStatusLog"> | Date | string
  }

  export type ClientDocumentWhereInput = {
    AND?: ClientDocumentWhereInput | ClientDocumentWhereInput[]
    OR?: ClientDocumentWhereInput[]
    NOT?: ClientDocumentWhereInput | ClientDocumentWhereInput[]
    id?: StringFilter<"ClientDocument"> | string
    type?: EnumDocumentTypeFilter<"ClientDocument"> | $Enums.DocumentType
    url?: StringFilter<"ClientDocument"> | string
    name?: StringNullableFilter<"ClientDocument"> | string | null
    description?: StringNullableFilter<"ClientDocument"> | string | null
    verified?: BoolFilter<"ClientDocument"> | boolean
    comments?: StringNullableFilter<"ClientDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"ClientDocument"> | Date | string | null
    clientId?: StringFilter<"ClientDocument"> | string
    verifiedById?: StringNullableFilter<"ClientDocument"> | string | null
    createdAt?: DateTimeFilter<"ClientDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ClientDocument"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ClientDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    comments?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    clientId?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
  }

  export type ClientDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientDocumentWhereInput | ClientDocumentWhereInput[]
    OR?: ClientDocumentWhereInput[]
    NOT?: ClientDocumentWhereInput | ClientDocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"ClientDocument"> | $Enums.DocumentType
    url?: StringFilter<"ClientDocument"> | string
    name?: StringNullableFilter<"ClientDocument"> | string | null
    description?: StringNullableFilter<"ClientDocument"> | string | null
    verified?: BoolFilter<"ClientDocument"> | boolean
    comments?: StringNullableFilter<"ClientDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"ClientDocument"> | Date | string | null
    clientId?: StringFilter<"ClientDocument"> | string
    verifiedById?: StringNullableFilter<"ClientDocument"> | string | null
    createdAt?: DateTimeFilter<"ClientDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ClientDocument"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ClientDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    comments?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    clientId?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientDocumentCountOrderByAggregateInput
    _max?: ClientDocumentMaxOrderByAggregateInput
    _min?: ClientDocumentMinOrderByAggregateInput
  }

  export type ClientDocumentScalarWhereWithAggregatesInput = {
    AND?: ClientDocumentScalarWhereWithAggregatesInput | ClientDocumentScalarWhereWithAggregatesInput[]
    OR?: ClientDocumentScalarWhereWithAggregatesInput[]
    NOT?: ClientDocumentScalarWhereWithAggregatesInput | ClientDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientDocument"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"ClientDocument"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"ClientDocument"> | string
    name?: StringNullableWithAggregatesFilter<"ClientDocument"> | string | null
    description?: StringNullableWithAggregatesFilter<"ClientDocument"> | string | null
    verified?: BoolWithAggregatesFilter<"ClientDocument"> | boolean
    comments?: StringNullableWithAggregatesFilter<"ClientDocument"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"ClientDocument"> | Date | string | null
    clientId?: StringWithAggregatesFilter<"ClientDocument"> | string
    verifiedById?: StringNullableWithAggregatesFilter<"ClientDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientDocument"> | Date | string
  }

  export type AgencyDocumentWhereInput = {
    AND?: AgencyDocumentWhereInput | AgencyDocumentWhereInput[]
    OR?: AgencyDocumentWhereInput[]
    NOT?: AgencyDocumentWhereInput | AgencyDocumentWhereInput[]
    id?: StringFilter<"AgencyDocument"> | string
    type?: EnumDocumentTypeFilter<"AgencyDocument"> | $Enums.DocumentType
    url?: StringFilter<"AgencyDocument"> | string
    name?: StringNullableFilter<"AgencyDocument"> | string | null
    description?: StringNullableFilter<"AgencyDocument"> | string | null
    verified?: BoolFilter<"AgencyDocument"> | boolean
    comments?: StringNullableFilter<"AgencyDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"AgencyDocument"> | Date | string | null
    agencyId?: StringFilter<"AgencyDocument"> | string
    verifiedById?: StringNullableFilter<"AgencyDocument"> | string | null
    createdAt?: DateTimeFilter<"AgencyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyDocument"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AgencyDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    comments?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
  }

  export type AgencyDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyDocumentWhereInput | AgencyDocumentWhereInput[]
    OR?: AgencyDocumentWhereInput[]
    NOT?: AgencyDocumentWhereInput | AgencyDocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"AgencyDocument"> | $Enums.DocumentType
    url?: StringFilter<"AgencyDocument"> | string
    name?: StringNullableFilter<"AgencyDocument"> | string | null
    description?: StringNullableFilter<"AgencyDocument"> | string | null
    verified?: BoolFilter<"AgencyDocument"> | boolean
    comments?: StringNullableFilter<"AgencyDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"AgencyDocument"> | Date | string | null
    agencyId?: StringFilter<"AgencyDocument"> | string
    verifiedById?: StringNullableFilter<"AgencyDocument"> | string | null
    createdAt?: DateTimeFilter<"AgencyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyDocument"> | Date | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AgencyDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verified?: SortOrder
    comments?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyDocumentCountOrderByAggregateInput
    _max?: AgencyDocumentMaxOrderByAggregateInput
    _min?: AgencyDocumentMinOrderByAggregateInput
  }

  export type AgencyDocumentScalarWhereWithAggregatesInput = {
    AND?: AgencyDocumentScalarWhereWithAggregatesInput | AgencyDocumentScalarWhereWithAggregatesInput[]
    OR?: AgencyDocumentScalarWhereWithAggregatesInput[]
    NOT?: AgencyDocumentScalarWhereWithAggregatesInput | AgencyDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyDocument"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"AgencyDocument"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"AgencyDocument"> | string
    name?: StringNullableWithAggregatesFilter<"AgencyDocument"> | string | null
    description?: StringNullableWithAggregatesFilter<"AgencyDocument"> | string | null
    verified?: BoolWithAggregatesFilter<"AgencyDocument"> | boolean
    comments?: StringNullableWithAggregatesFilter<"AgencyDocument"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"AgencyDocument"> | Date | string | null
    agencyId?: StringWithAggregatesFilter<"AgencyDocument"> | string
    verifiedById?: StringNullableWithAggregatesFilter<"AgencyDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgencyDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyDocument"> | Date | string
  }

  export type RequirementDocumentWhereInput = {
    AND?: RequirementDocumentWhereInput | RequirementDocumentWhereInput[]
    OR?: RequirementDocumentWhereInput[]
    NOT?: RequirementDocumentWhereInput | RequirementDocumentWhereInput[]
    id?: StringFilter<"RequirementDocument"> | string
    type?: EnumDocumentTypeFilter<"RequirementDocument"> | $Enums.DocumentType
    url?: StringFilter<"RequirementDocument"> | string
    name?: StringNullableFilter<"RequirementDocument"> | string | null
    description?: StringNullableFilter<"RequirementDocument"> | string | null
    requirementId?: StringFilter<"RequirementDocument"> | string
    uploadedById?: StringFilter<"RequirementDocument"> | string
    createdAt?: DateTimeFilter<"RequirementDocument"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementDocument"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RequirementDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type RequirementDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementDocumentWhereInput | RequirementDocumentWhereInput[]
    OR?: RequirementDocumentWhereInput[]
    NOT?: RequirementDocumentWhereInput | RequirementDocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"RequirementDocument"> | $Enums.DocumentType
    url?: StringFilter<"RequirementDocument"> | string
    name?: StringNullableFilter<"RequirementDocument"> | string | null
    description?: StringNullableFilter<"RequirementDocument"> | string | null
    requirementId?: StringFilter<"RequirementDocument"> | string
    uploadedById?: StringFilter<"RequirementDocument"> | string
    createdAt?: DateTimeFilter<"RequirementDocument"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementDocument"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RequirementDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    requirementId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequirementDocumentCountOrderByAggregateInput
    _max?: RequirementDocumentMaxOrderByAggregateInput
    _min?: RequirementDocumentMinOrderByAggregateInput
  }

  export type RequirementDocumentScalarWhereWithAggregatesInput = {
    AND?: RequirementDocumentScalarWhereWithAggregatesInput | RequirementDocumentScalarWhereWithAggregatesInput[]
    OR?: RequirementDocumentScalarWhereWithAggregatesInput[]
    NOT?: RequirementDocumentScalarWhereWithAggregatesInput | RequirementDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequirementDocument"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"RequirementDocument"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"RequirementDocument"> | string
    name?: StringNullableWithAggregatesFilter<"RequirementDocument"> | string | null
    description?: StringNullableWithAggregatesFilter<"RequirementDocument"> | string | null
    requirementId?: StringWithAggregatesFilter<"RequirementDocument"> | string
    uploadedById?: StringWithAggregatesFilter<"RequirementDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequirementDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RequirementDocument"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    performedBy?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    performedById?: StringWithAggregatesFilter<"AuditLog"> | string
    performedAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    recipient?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    requirements?: RequirementCreateNestedManyWithoutClientInput
    documents?: ClientDocumentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutClientInput
    documents?: ClientDocumentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    requirements?: RequirementUpdateManyWithoutClientNestedInput
    documents?: ClientDocumentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutClientNestedInput
    documents?: ClientDocumentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyCreateInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutAgencyInput
    requirements?: RequirementCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementCreateManyInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
  }

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobRoleCreateInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutJobRolesInput
  }

  export type JobRoleUncheckedCreateInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    requirementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutJobRolesNestedInput
  }

  export type JobRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    requirementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleCreateManyInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    requirementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    requirementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileCreateInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutLabourProfilesInput
    agency: AgencyCreateNestedOneWithoutLabourProfilesInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutLabourProfilesNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfilesNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileCreateManyInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement?: RequirementCreateNestedOneWithoutProceduresInput
    labourProfile?: LabourProfileCreateNestedOneWithoutProceduresInput
  }

  export type ProcedureUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: string | null
    labourProfileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneWithoutProceduresNestedInput
    labourProfile?: LabourProfileUpdateOneWithoutProceduresNestedInput
  }

  export type ProcedureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateManyInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: string | null
    labourProfileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogCreateInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    labourProfile: LabourProfileCreateNestedOneWithoutStatusLogsInput
    changedBy: UserCreateNestedOneWithoutStatusLogsInput
  }

  export type LabourStatusLogUncheckedCreateInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId: string
    changedById: string
    createdAt?: Date | string
  }

  export type LabourStatusLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfile?: LabourProfileUpdateOneRequiredWithoutStatusLogsNestedInput
    changedBy?: UserUpdateOneRequiredWithoutStatusLogsNestedInput
  }

  export type LabourStatusLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogCreateManyInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId: string
    changedById: string
    createdAt?: Date | string
  }

  export type LabourStatusLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDocumentsInput
    verifiedBy?: UserCreateNestedOneWithoutClientDocumentsInput
  }

  export type ClientDocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    clientId: string
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDocumentsNestedInput
    verifiedBy?: UserUpdateOneWithoutClientDocumentsNestedInput
  }

  export type ClientDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    clientId: string
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutDocumentsInput
    verifiedBy?: UserCreateNestedOneWithoutAgencyDocumentsInput
  }

  export type AgencyDocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    agencyId: string
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutDocumentsNestedInput
    verifiedBy?: UserUpdateOneWithoutAgencyDocumentsNestedInput
  }

  export type AgencyDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    agencyId: string
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutRequirementDocumentsInput
  }

  export type RequirementDocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    requirementId: string
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutRequirementDocumentsNestedInput
  }

  export type RequirementDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    requirementId: string
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    performedBy: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipientId: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipientId: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumDeletionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableFilter<$PrismaModel> | $Enums.DeletionType | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type LabourStatusLogListRelationFilter = {
    every?: LabourStatusLogWhereInput
    some?: LabourStatusLogWhereInput
    none?: LabourStatusLogWhereInput
  }

  export type ClientDocumentListRelationFilter = {
    every?: ClientDocumentWhereInput
    some?: ClientDocumentWhereInput
    none?: ClientDocumentWhereInput
  }

  export type AgencyDocumentListRelationFilter = {
    every?: AgencyDocumentWhereInput
    some?: AgencyDocumentWhereInput
    none?: AgencyDocumentWhereInput
  }

  export type RequirementDocumentListRelationFilter = {
    every?: RequirementDocumentWhereInput
    some?: RequirementDocumentWhereInput
    none?: RequirementDocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabourStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeletionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
  }

  export type EnumCompanySectorFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorFilter<$PrismaModel> | $Enums.CompanySector
  }

  export type EnumCompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeFilter<$PrismaModel> | $Enums.CompanySize
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput
    some?: RequirementWhereInput
    none?: RequirementWhereInput
  }

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanySectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel> | $Enums.CompanySector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySectorFilter<$PrismaModel>
    _max?: NestedEnumCompanySectorFilter<$PrismaModel>
  }

  export type EnumCompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeFilter<$PrismaModel>
  }

  export type LabourProfileListRelationFilter = {
    every?: LabourProfileWhereInput
    some?: LabourProfileWhereInput
    none?: LabourProfileWhereInput
  }

  export type LabourProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumExperienceLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperienceLevel | EnumExperienceLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExperienceLevelNullableFilter<$PrismaModel> | $Enums.ExperienceLevel | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTicketTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTicketTypeNullableFilter<$PrismaModel> | $Enums.TicketType | null
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type JobRoleListRelationFilter = {
    every?: JobRoleWhereInput
    some?: JobRoleWhereInput
    none?: JobRoleWhereInput
  }

  export type ProcedureListRelationFilter = {
    every?: ProcedureWhereInput
    some?: ProcedureWhereInput
    none?: ProcedureWhereInput
  }

  export type JobRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder
    specialNotes?: SortOrder
    status?: SortOrder
    languages?: SortOrder
    minExperience?: SortOrder
    maxAge?: SortOrder
    ticketType?: SortOrder
    ticketProvided?: SortOrder
    clientId?: SortOrder
    assignedAgencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type RequirementAvgOrderByAggregateInput = {
    maxAge?: SortOrder
  }

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    specialNotes?: SortOrder
    status?: SortOrder
    minExperience?: SortOrder
    maxAge?: SortOrder
    ticketType?: SortOrder
    ticketProvided?: SortOrder
    clientId?: SortOrder
    assignedAgencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder
    specialNotes?: SortOrder
    status?: SortOrder
    minExperience?: SortOrder
    maxAge?: SortOrder
    ticketType?: SortOrder
    ticketProvided?: SortOrder
    clientId?: SortOrder
    assignedAgencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type RequirementSumOrderByAggregateInput = {
    maxAge?: SortOrder
  }

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type EnumExperienceLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperienceLevel | EnumExperienceLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExperienceLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExperienceLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExperienceLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumExperienceLevelNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTicketTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTicketTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TicketType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumContractDurationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableFilter<$PrismaModel> | $Enums.ContractDuration | null
  }

  export type RequirementScalarRelationFilter = {
    is?: RequirementWhereInput
    isNot?: RequirementWhereInput
  }

  export type JobRoleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    salary?: SortOrder
    salaryCurrency?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    requirementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobRoleAvgOrderByAggregateInput = {
    quantity?: SortOrder
    salary?: SortOrder
  }

  export type JobRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    salary?: SortOrder
    salaryCurrency?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    requirementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobRoleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    salary?: SortOrder
    salaryCurrency?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    requirementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobRoleSumOrderByAggregateInput = {
    quantity?: SortOrder
    salary?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumContractDurationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractDuration | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractDurationNullableFilter<$PrismaModel>
    _max?: NestedEnumContractDurationNullableFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumLabourProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusFilter<$PrismaModel> | $Enums.LabourProfileStatus
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type LabourProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    maritalStatus?: SortOrder
    skills?: SortOrder
    experienceYears?: SortOrder
    education?: SortOrder
    currentPosition?: SortOrder
    currentCompany?: SortOrder
    languages?: SortOrder
    englishProficiency?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    cvUrl?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    medicalStatus?: SortOrder
    medicalExpiry?: SortOrder
    photo?: SortOrder
    otherDocs?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    deploymentDate?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabourProfileAvgOrderByAggregateInput = {
    age?: SortOrder
    experienceYears?: SortOrder
  }

  export type LabourProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    maritalStatus?: SortOrder
    experienceYears?: SortOrder
    education?: SortOrder
    currentPosition?: SortOrder
    currentCompany?: SortOrder
    englishProficiency?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    cvUrl?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    medicalStatus?: SortOrder
    medicalExpiry?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    deploymentDate?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabourProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    maritalStatus?: SortOrder
    experienceYears?: SortOrder
    education?: SortOrder
    currentPosition?: SortOrder
    currentCompany?: SortOrder
    englishProficiency?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    cvUrl?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    medicalStatus?: SortOrder
    medicalExpiry?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    deploymentDate?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabourProfileSumOrderByAggregateInput = {
    age?: SortOrder
    experienceYears?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumLabourProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabourProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
  }

  export type EnumProcedureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusFilter<$PrismaModel> | $Enums.ProcedureStatus
  }

  export type RequirementNullableScalarRelationFilter = {
    is?: RequirementWhereInput | null
    isNot?: RequirementWhereInput | null
  }

  export type LabourProfileNullableScalarRelationFilter = {
    is?: LabourProfileWhereInput | null
    isNot?: LabourProfileWhereInput | null
  }

  export type ProcedureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    comments?: SortOrder
    metadata?: SortOrder
    requirementId?: SortOrder
    labourProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    comments?: SortOrder
    requirementId?: SortOrder
    labourProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    comments?: SortOrder
    requirementId?: SortOrder
    labourProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProcedureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcedureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcedureStatusFilter<$PrismaModel>
    _max?: NestedEnumProcedureStatusFilter<$PrismaModel>
  }

  export type LabourProfileScalarRelationFilter = {
    is?: LabourProfileWhereInput
    isNot?: LabourProfileWhereInput
  }

  export type LabourStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    metadata?: SortOrder
    labourProfileId?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LabourStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    labourProfileId?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LabourStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    labourProfileId?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type ClientDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    clientId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    clientId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    clientId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type AgencyDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    agencyId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    agencyId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    verified?: SortOrder
    comments?: SortOrder
    expiryDate?: SortOrder
    agencyId?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requirementId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requirementId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requirementId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    metadata?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    connect?: AgencyWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LabourStatusLogCreateNestedManyWithoutChangedByInput = {
    create?: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput> | LabourStatusLogCreateWithoutChangedByInput[] | LabourStatusLogUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutChangedByInput | LabourStatusLogCreateOrConnectWithoutChangedByInput[]
    createMany?: LabourStatusLogCreateManyChangedByInputEnvelope
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
  }

  export type ClientDocumentCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput> | ClientDocumentCreateWithoutVerifiedByInput[] | ClientDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutVerifiedByInput | ClientDocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: ClientDocumentCreateManyVerifiedByInputEnvelope
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
  }

  export type AgencyDocumentCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput> | AgencyDocumentCreateWithoutVerifiedByInput[] | AgencyDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutVerifiedByInput | AgencyDocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: AgencyDocumentCreateManyVerifiedByInputEnvelope
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
  }

  export type RequirementDocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput> | RequirementDocumentCreateWithoutUploadedByInput[] | RequirementDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutUploadedByInput | RequirementDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: RequirementDocumentCreateManyUploadedByInputEnvelope
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    connect?: AgencyWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput> | LabourStatusLogCreateWithoutChangedByInput[] | LabourStatusLogUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutChangedByInput | LabourStatusLogCreateOrConnectWithoutChangedByInput[]
    createMany?: LabourStatusLogCreateManyChangedByInputEnvelope
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
  }

  export type ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput> | ClientDocumentCreateWithoutVerifiedByInput[] | ClientDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutVerifiedByInput | ClientDocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: ClientDocumentCreateManyVerifiedByInputEnvelope
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
  }

  export type AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput> | AgencyDocumentCreateWithoutVerifiedByInput[] | AgencyDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutVerifiedByInput | AgencyDocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: AgencyDocumentCreateManyVerifiedByInputEnvelope
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
  }

  export type RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput> | RequirementDocumentCreateWithoutUploadedByInput[] | RequirementDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutUploadedByInput | RequirementDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: RequirementDocumentCreateManyUploadedByInputEnvelope
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumDeletionTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeletionType | null
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    upsert?: AgencyUpsertWithoutUserInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUserInput, AgencyUpdateWithoutUserInput>, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPerformedByInput | AuditLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPerformedByInput | AuditLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPerformedByInput | AuditLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LabourStatusLogUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput> | LabourStatusLogCreateWithoutChangedByInput[] | LabourStatusLogUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutChangedByInput | LabourStatusLogCreateOrConnectWithoutChangedByInput[]
    upsert?: LabourStatusLogUpsertWithWhereUniqueWithoutChangedByInput | LabourStatusLogUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: LabourStatusLogCreateManyChangedByInputEnvelope
    set?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    disconnect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    delete?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    update?: LabourStatusLogUpdateWithWhereUniqueWithoutChangedByInput | LabourStatusLogUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: LabourStatusLogUpdateManyWithWhereWithoutChangedByInput | LabourStatusLogUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
  }

  export type ClientDocumentUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput> | ClientDocumentCreateWithoutVerifiedByInput[] | ClientDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutVerifiedByInput | ClientDocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: ClientDocumentUpsertWithWhereUniqueWithoutVerifiedByInput | ClientDocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: ClientDocumentCreateManyVerifiedByInputEnvelope
    set?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    disconnect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    delete?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    update?: ClientDocumentUpdateWithWhereUniqueWithoutVerifiedByInput | ClientDocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: ClientDocumentUpdateManyWithWhereWithoutVerifiedByInput | ClientDocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
  }

  export type AgencyDocumentUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput> | AgencyDocumentCreateWithoutVerifiedByInput[] | AgencyDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutVerifiedByInput | AgencyDocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: AgencyDocumentUpsertWithWhereUniqueWithoutVerifiedByInput | AgencyDocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: AgencyDocumentCreateManyVerifiedByInputEnvelope
    set?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    disconnect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    delete?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    update?: AgencyDocumentUpdateWithWhereUniqueWithoutVerifiedByInput | AgencyDocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: AgencyDocumentUpdateManyWithWhereWithoutVerifiedByInput | AgencyDocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
  }

  export type RequirementDocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput> | RequirementDocumentCreateWithoutUploadedByInput[] | RequirementDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutUploadedByInput | RequirementDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: RequirementDocumentUpsertWithWhereUniqueWithoutUploadedByInput | RequirementDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: RequirementDocumentCreateManyUploadedByInputEnvelope
    set?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    disconnect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    delete?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    update?: RequirementDocumentUpdateWithWhereUniqueWithoutUploadedByInput | RequirementDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: RequirementDocumentUpdateManyWithWhereWithoutUploadedByInput | RequirementDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    upsert?: AgencyUpsertWithoutUserInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUserInput, AgencyUpdateWithoutUserInput>, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPerformedByInput | AuditLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPerformedByInput | AuditLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPerformedByInput | AuditLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput> | LabourStatusLogCreateWithoutChangedByInput[] | LabourStatusLogUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutChangedByInput | LabourStatusLogCreateOrConnectWithoutChangedByInput[]
    upsert?: LabourStatusLogUpsertWithWhereUniqueWithoutChangedByInput | LabourStatusLogUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: LabourStatusLogCreateManyChangedByInputEnvelope
    set?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    disconnect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    delete?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    update?: LabourStatusLogUpdateWithWhereUniqueWithoutChangedByInput | LabourStatusLogUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: LabourStatusLogUpdateManyWithWhereWithoutChangedByInput | LabourStatusLogUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
  }

  export type ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput> | ClientDocumentCreateWithoutVerifiedByInput[] | ClientDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutVerifiedByInput | ClientDocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: ClientDocumentUpsertWithWhereUniqueWithoutVerifiedByInput | ClientDocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: ClientDocumentCreateManyVerifiedByInputEnvelope
    set?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    disconnect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    delete?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    update?: ClientDocumentUpdateWithWhereUniqueWithoutVerifiedByInput | ClientDocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: ClientDocumentUpdateManyWithWhereWithoutVerifiedByInput | ClientDocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
  }

  export type AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput> | AgencyDocumentCreateWithoutVerifiedByInput[] | AgencyDocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutVerifiedByInput | AgencyDocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: AgencyDocumentUpsertWithWhereUniqueWithoutVerifiedByInput | AgencyDocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: AgencyDocumentCreateManyVerifiedByInputEnvelope
    set?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    disconnect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    delete?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    update?: AgencyDocumentUpdateWithWhereUniqueWithoutVerifiedByInput | AgencyDocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: AgencyDocumentUpdateManyWithWhereWithoutVerifiedByInput | AgencyDocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
  }

  export type RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput> | RequirementDocumentCreateWithoutUploadedByInput[] | RequirementDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutUploadedByInput | RequirementDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: RequirementDocumentUpsertWithWhereUniqueWithoutUploadedByInput | RequirementDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: RequirementDocumentCreateManyUploadedByInputEnvelope
    set?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    disconnect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    delete?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    update?: RequirementDocumentUpdateWithWhereUniqueWithoutUploadedByInput | RequirementDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: RequirementDocumentUpdateManyWithWhereWithoutUploadedByInput | RequirementDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutClientInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type ClientDocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput> | ClientDocumentCreateWithoutClientInput[] | ClientDocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutClientInput | ClientDocumentCreateOrConnectWithoutClientInput[]
    createMany?: ClientDocumentCreateManyClientInputEnvelope
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type ClientDocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput> | ClientDocumentCreateWithoutClientInput[] | ClientDocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutClientInput | ClientDocumentCreateOrConnectWithoutClientInput[]
    createMany?: ClientDocumentCreateManyClientInputEnvelope
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
  }

  export type EnumCompanySectorFieldUpdateOperationsInput = {
    set?: $Enums.CompanySector
  }

  export type EnumCompanySizeFieldUpdateOperationsInput = {
    set?: $Enums.CompanySize
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type RequirementUpdateManyWithoutClientNestedInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutClientInput | RequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutClientInput | RequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutClientInput | RequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type ClientDocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput> | ClientDocumentCreateWithoutClientInput[] | ClientDocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutClientInput | ClientDocumentCreateOrConnectWithoutClientInput[]
    upsert?: ClientDocumentUpsertWithWhereUniqueWithoutClientInput | ClientDocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientDocumentCreateManyClientInputEnvelope
    set?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    disconnect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    delete?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    update?: ClientDocumentUpdateWithWhereUniqueWithoutClientInput | ClientDocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientDocumentUpdateManyWithWhereWithoutClientInput | ClientDocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutClientInput | RequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutClientInput | RequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutClientInput | RequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type ClientDocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput> | ClientDocumentCreateWithoutClientInput[] | ClientDocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientDocumentCreateOrConnectWithoutClientInput | ClientDocumentCreateOrConnectWithoutClientInput[]
    upsert?: ClientDocumentUpsertWithWhereUniqueWithoutClientInput | ClientDocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientDocumentCreateManyClientInputEnvelope
    set?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    disconnect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    delete?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    connect?: ClientDocumentWhereUniqueInput | ClientDocumentWhereUniqueInput[]
    update?: ClientDocumentUpdateWithWhereUniqueWithoutClientInput | ClientDocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientDocumentUpdateManyWithWhereWithoutClientInput | ClientDocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgencyProfileInput = {
    create?: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyProfileInput
    connect?: UserWhereUniqueInput
  }

  export type LabourProfileCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type RequirementCreateNestedManyWithoutAssignedAgencyInput = {
    create?: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput> | RequirementCreateWithoutAssignedAgencyInput[] | RequirementUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAssignedAgencyInput | RequirementCreateOrConnectWithoutAssignedAgencyInput[]
    createMany?: RequirementCreateManyAssignedAgencyInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type AgencyDocumentCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput> | AgencyDocumentCreateWithoutAgencyInput[] | AgencyDocumentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutAgencyInput | AgencyDocumentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyDocumentCreateManyAgencyInputEnvelope
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
  }

  export type LabourProfileUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutAssignedAgencyInput = {
    create?: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput> | RequirementCreateWithoutAssignedAgencyInput[] | RequirementUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAssignedAgencyInput | RequirementCreateOrConnectWithoutAssignedAgencyInput[]
    createMany?: RequirementCreateManyAssignedAgencyInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type AgencyDocumentUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput> | AgencyDocumentCreateWithoutAgencyInput[] | AgencyDocumentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutAgencyInput | AgencyDocumentCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencyDocumentCreateManyAgencyInputEnvelope
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAgencyProfileNestedInput = {
    create?: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyProfileInput
    upsert?: UserUpsertWithoutAgencyProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyProfileInput, UserUpdateWithoutAgencyProfileInput>, UserUncheckedUpdateWithoutAgencyProfileInput>
  }

  export type LabourProfileUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAgencyInput | LabourProfileUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAgencyInput | LabourProfileUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAgencyInput | LabourProfileUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type RequirementUpdateManyWithoutAssignedAgencyNestedInput = {
    create?: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput> | RequirementCreateWithoutAssignedAgencyInput[] | RequirementUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAssignedAgencyInput | RequirementCreateOrConnectWithoutAssignedAgencyInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutAssignedAgencyInput | RequirementUpsertWithWhereUniqueWithoutAssignedAgencyInput[]
    createMany?: RequirementCreateManyAssignedAgencyInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutAssignedAgencyInput | RequirementUpdateWithWhereUniqueWithoutAssignedAgencyInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutAssignedAgencyInput | RequirementUpdateManyWithWhereWithoutAssignedAgencyInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type AgencyDocumentUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput> | AgencyDocumentCreateWithoutAgencyInput[] | AgencyDocumentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutAgencyInput | AgencyDocumentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyDocumentUpsertWithWhereUniqueWithoutAgencyInput | AgencyDocumentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyDocumentCreateManyAgencyInputEnvelope
    set?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    disconnect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    delete?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    update?: AgencyDocumentUpdateWithWhereUniqueWithoutAgencyInput | AgencyDocumentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyDocumentUpdateManyWithWhereWithoutAgencyInput | AgencyDocumentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
  }

  export type LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAgencyInput | LabourProfileUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAgencyInput | LabourProfileUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAgencyInput | LabourProfileUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutAssignedAgencyNestedInput = {
    create?: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput> | RequirementCreateWithoutAssignedAgencyInput[] | RequirementUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAssignedAgencyInput | RequirementCreateOrConnectWithoutAssignedAgencyInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutAssignedAgencyInput | RequirementUpsertWithWhereUniqueWithoutAssignedAgencyInput[]
    createMany?: RequirementCreateManyAssignedAgencyInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutAssignedAgencyInput | RequirementUpdateWithWhereUniqueWithoutAssignedAgencyInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutAssignedAgencyInput | RequirementUpdateManyWithWhereWithoutAssignedAgencyInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type AgencyDocumentUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput> | AgencyDocumentCreateWithoutAgencyInput[] | AgencyDocumentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencyDocumentCreateOrConnectWithoutAgencyInput | AgencyDocumentCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencyDocumentUpsertWithWhereUniqueWithoutAgencyInput | AgencyDocumentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencyDocumentCreateManyAgencyInputEnvelope
    set?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    disconnect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    delete?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    connect?: AgencyDocumentWhereUniqueInput | AgencyDocumentWhereUniqueInput[]
    update?: AgencyDocumentUpdateWithWhereUniqueWithoutAgencyInput | AgencyDocumentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencyDocumentUpdateManyWithWhereWithoutAgencyInput | AgencyDocumentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type RequirementCreatelanguagesInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementsInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<AgencyCreateWithoutRequirementsInput, AgencyUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRequirementsInput
    connect?: AgencyWhereUniqueInput
  }

  export type JobRoleCreateNestedManyWithoutRequirementInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type LabourProfileCreateNestedManyWithoutRequirementInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type ProcedureCreateNestedManyWithoutRequirementInput = {
    create?: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput> | ProcedureCreateWithoutRequirementInput[] | ProcedureUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutRequirementInput | ProcedureCreateOrConnectWithoutRequirementInput[]
    createMany?: ProcedureCreateManyRequirementInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type RequirementDocumentCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput> | RequirementDocumentCreateWithoutRequirementInput[] | RequirementDocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutRequirementInput | RequirementDocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementDocumentCreateManyRequirementInputEnvelope
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
  }

  export type JobRoleUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type LabourProfileUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput> | ProcedureCreateWithoutRequirementInput[] | ProcedureUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutRequirementInput | ProcedureCreateOrConnectWithoutRequirementInput[]
    createMany?: ProcedureCreateManyRequirementInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput> | RequirementDocumentCreateWithoutRequirementInput[] | RequirementDocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutRequirementInput | RequirementDocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementDocumentCreateManyRequirementInputEnvelope
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
  }

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus
  }

  export type RequirementUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumExperienceLevelFieldUpdateOperationsInput = {
    set?: $Enums.ExperienceLevel | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTicketTypeFieldUpdateOperationsInput = {
    set?: $Enums.TicketType | null
  }

  export type ClientUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementsInput
    upsert?: ClientUpsertWithoutRequirementsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRequirementsInput, ClientUpdateWithoutRequirementsInput>, ClientUncheckedUpdateWithoutRequirementsInput>
  }

  export type AgencyUpdateOneWithoutRequirementsNestedInput = {
    create?: XOR<AgencyCreateWithoutRequirementsInput, AgencyUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRequirementsInput
    upsert?: AgencyUpsertWithoutRequirementsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutRequirementsInput, AgencyUpdateWithoutRequirementsInput>, AgencyUncheckedUpdateWithoutRequirementsInput>
  }

  export type JobRoleUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutRequirementInput | JobRoleUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutRequirementInput | JobRoleUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutRequirementInput | JobRoleUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type LabourProfileUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutRequirementInput | LabourProfileUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutRequirementInput | LabourProfileUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutRequirementInput | LabourProfileUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type ProcedureUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput> | ProcedureCreateWithoutRequirementInput[] | ProcedureUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutRequirementInput | ProcedureCreateOrConnectWithoutRequirementInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutRequirementInput | ProcedureUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: ProcedureCreateManyRequirementInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutRequirementInput | ProcedureUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutRequirementInput | ProcedureUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type RequirementDocumentUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput> | RequirementDocumentCreateWithoutRequirementInput[] | RequirementDocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutRequirementInput | RequirementDocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementDocumentUpsertWithWhereUniqueWithoutRequirementInput | RequirementDocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementDocumentCreateManyRequirementInputEnvelope
    set?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    disconnect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    delete?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    update?: RequirementDocumentUpdateWithWhereUniqueWithoutRequirementInput | RequirementDocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementDocumentUpdateManyWithWhereWithoutRequirementInput | RequirementDocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
  }

  export type JobRoleUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutRequirementInput | JobRoleUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutRequirementInput | JobRoleUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutRequirementInput | JobRoleUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutRequirementInput | LabourProfileUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutRequirementInput | LabourProfileUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutRequirementInput | LabourProfileUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput> | ProcedureCreateWithoutRequirementInput[] | ProcedureUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutRequirementInput | ProcedureCreateOrConnectWithoutRequirementInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutRequirementInput | ProcedureUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: ProcedureCreateManyRequirementInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutRequirementInput | ProcedureUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutRequirementInput | ProcedureUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput> | RequirementDocumentCreateWithoutRequirementInput[] | RequirementDocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementDocumentCreateOrConnectWithoutRequirementInput | RequirementDocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementDocumentUpsertWithWhereUniqueWithoutRequirementInput | RequirementDocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementDocumentCreateManyRequirementInputEnvelope
    set?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    disconnect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    delete?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    connect?: RequirementDocumentWhereUniqueInput | RequirementDocumentWhereUniqueInput[]
    update?: RequirementDocumentUpdateWithWhereUniqueWithoutRequirementInput | RequirementDocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementDocumentUpdateManyWithWhereWithoutRequirementInput | RequirementDocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
  }

  export type RequirementCreateNestedOneWithoutJobRolesInput = {
    create?: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutJobRolesInput
    connect?: RequirementWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumContractDurationFieldUpdateOperationsInput = {
    set?: $Enums.ContractDuration | null
  }

  export type RequirementUpdateOneRequiredWithoutJobRolesNestedInput = {
    create?: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutJobRolesInput
    upsert?: RequirementUpsertWithoutJobRolesInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutJobRolesInput, RequirementUpdateWithoutJobRolesInput>, RequirementUncheckedUpdateWithoutJobRolesInput>
  }

  export type LabourProfileCreateskillsInput = {
    set: string[]
  }

  export type LabourProfileCreatelanguagesInput = {
    set: string[]
  }

  export type LabourProfileCreateotherDocsInput = {
    set: string[]
  }

  export type RequirementCreateNestedOneWithoutLabourProfilesInput = {
    create?: XOR<RequirementCreateWithoutLabourProfilesInput, RequirementUncheckedCreateWithoutLabourProfilesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutLabourProfilesInput
    connect?: RequirementWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutLabourProfilesInput = {
    create?: XOR<AgencyCreateWithoutLabourProfilesInput, AgencyUncheckedCreateWithoutLabourProfilesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourProfilesInput
    connect?: AgencyWhereUniqueInput
  }

  export type LabourStatusLogCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput> | LabourStatusLogCreateWithoutLabourProfileInput[] | LabourStatusLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutLabourProfileInput | LabourStatusLogCreateOrConnectWithoutLabourProfileInput[]
    createMany?: LabourStatusLogCreateManyLabourProfileInputEnvelope
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
  }

  export type ProcedureCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput> | ProcedureCreateWithoutLabourProfileInput[] | ProcedureUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutLabourProfileInput | ProcedureCreateOrConnectWithoutLabourProfileInput[]
    createMany?: ProcedureCreateManyLabourProfileInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type LabourStatusLogUncheckedCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput> | LabourStatusLogCreateWithoutLabourProfileInput[] | LabourStatusLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutLabourProfileInput | LabourStatusLogCreateOrConnectWithoutLabourProfileInput[]
    createMany?: LabourStatusLogCreateManyLabourProfileInputEnvelope
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput> | ProcedureCreateWithoutLabourProfileInput[] | ProcedureUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutLabourProfileInput | ProcedureCreateOrConnectWithoutLabourProfileInput[]
    createMany?: ProcedureCreateManyLabourProfileInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type LabourProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LabourProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LabourProfileUpdateotherDocsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumLabourProfileStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabourProfileStatus
  }

  export type RequirementUpdateOneRequiredWithoutLabourProfilesNestedInput = {
    create?: XOR<RequirementCreateWithoutLabourProfilesInput, RequirementUncheckedCreateWithoutLabourProfilesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutLabourProfilesInput
    upsert?: RequirementUpsertWithoutLabourProfilesInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutLabourProfilesInput, RequirementUpdateWithoutLabourProfilesInput>, RequirementUncheckedUpdateWithoutLabourProfilesInput>
  }

  export type AgencyUpdateOneRequiredWithoutLabourProfilesNestedInput = {
    create?: XOR<AgencyCreateWithoutLabourProfilesInput, AgencyUncheckedCreateWithoutLabourProfilesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourProfilesInput
    upsert?: AgencyUpsertWithoutLabourProfilesInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutLabourProfilesInput, AgencyUpdateWithoutLabourProfilesInput>, AgencyUncheckedUpdateWithoutLabourProfilesInput>
  }

  export type LabourStatusLogUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput> | LabourStatusLogCreateWithoutLabourProfileInput[] | LabourStatusLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutLabourProfileInput | LabourStatusLogCreateOrConnectWithoutLabourProfileInput[]
    upsert?: LabourStatusLogUpsertWithWhereUniqueWithoutLabourProfileInput | LabourStatusLogUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: LabourStatusLogCreateManyLabourProfileInputEnvelope
    set?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    disconnect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    delete?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    update?: LabourStatusLogUpdateWithWhereUniqueWithoutLabourProfileInput | LabourStatusLogUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: LabourStatusLogUpdateManyWithWhereWithoutLabourProfileInput | LabourStatusLogUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
  }

  export type ProcedureUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput> | ProcedureCreateWithoutLabourProfileInput[] | ProcedureUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutLabourProfileInput | ProcedureCreateOrConnectWithoutLabourProfileInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutLabourProfileInput | ProcedureUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: ProcedureCreateManyLabourProfileInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutLabourProfileInput | ProcedureUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutLabourProfileInput | ProcedureUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type LabourStatusLogUncheckedUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput> | LabourStatusLogCreateWithoutLabourProfileInput[] | LabourStatusLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: LabourStatusLogCreateOrConnectWithoutLabourProfileInput | LabourStatusLogCreateOrConnectWithoutLabourProfileInput[]
    upsert?: LabourStatusLogUpsertWithWhereUniqueWithoutLabourProfileInput | LabourStatusLogUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: LabourStatusLogCreateManyLabourProfileInputEnvelope
    set?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    disconnect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    delete?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    connect?: LabourStatusLogWhereUniqueInput | LabourStatusLogWhereUniqueInput[]
    update?: LabourStatusLogUpdateWithWhereUniqueWithoutLabourProfileInput | LabourStatusLogUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: LabourStatusLogUpdateManyWithWhereWithoutLabourProfileInput | LabourStatusLogUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput> | ProcedureCreateWithoutLabourProfileInput[] | ProcedureUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutLabourProfileInput | ProcedureCreateOrConnectWithoutLabourProfileInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutLabourProfileInput | ProcedureUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: ProcedureCreateManyLabourProfileInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutLabourProfileInput | ProcedureUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutLabourProfileInput | ProcedureUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type RequirementCreateNestedOneWithoutProceduresInput = {
    create?: XOR<RequirementCreateWithoutProceduresInput, RequirementUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutProceduresInput
    connect?: RequirementWhereUniqueInput
  }

  export type LabourProfileCreateNestedOneWithoutProceduresInput = {
    create?: XOR<LabourProfileCreateWithoutProceduresInput, LabourProfileUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutProceduresInput
    connect?: LabourProfileWhereUniqueInput
  }

  export type EnumProcedureStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcedureStatus
  }

  export type RequirementUpdateOneWithoutProceduresNestedInput = {
    create?: XOR<RequirementCreateWithoutProceduresInput, RequirementUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutProceduresInput
    upsert?: RequirementUpsertWithoutProceduresInput
    disconnect?: RequirementWhereInput | boolean
    delete?: RequirementWhereInput | boolean
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutProceduresInput, RequirementUpdateWithoutProceduresInput>, RequirementUncheckedUpdateWithoutProceduresInput>
  }

  export type LabourProfileUpdateOneWithoutProceduresNestedInput = {
    create?: XOR<LabourProfileCreateWithoutProceduresInput, LabourProfileUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutProceduresInput
    upsert?: LabourProfileUpsertWithoutProceduresInput
    disconnect?: LabourProfileWhereInput | boolean
    delete?: LabourProfileWhereInput | boolean
    connect?: LabourProfileWhereUniqueInput
    update?: XOR<XOR<LabourProfileUpdateToOneWithWhereWithoutProceduresInput, LabourProfileUpdateWithoutProceduresInput>, LabourProfileUncheckedUpdateWithoutProceduresInput>
  }

  export type LabourProfileCreateNestedOneWithoutStatusLogsInput = {
    create?: XOR<LabourProfileCreateWithoutStatusLogsInput, LabourProfileUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutStatusLogsInput
    connect?: LabourProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStatusLogsInput = {
    create?: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusLogsInput
    connect?: UserWhereUniqueInput
  }

  export type LabourProfileUpdateOneRequiredWithoutStatusLogsNestedInput = {
    create?: XOR<LabourProfileCreateWithoutStatusLogsInput, LabourProfileUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutStatusLogsInput
    upsert?: LabourProfileUpsertWithoutStatusLogsInput
    connect?: LabourProfileWhereUniqueInput
    update?: XOR<XOR<LabourProfileUpdateToOneWithWhereWithoutStatusLogsInput, LabourProfileUpdateWithoutStatusLogsInput>, LabourProfileUncheckedUpdateWithoutStatusLogsInput>
  }

  export type UserUpdateOneRequiredWithoutStatusLogsNestedInput = {
    create?: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusLogsInput
    upsert?: UserUpsertWithoutStatusLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusLogsInput, UserUpdateWithoutStatusLogsInput>, UserUncheckedUpdateWithoutStatusLogsInput>
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientDocumentsInput = {
    create?: XOR<UserCreateWithoutClientDocumentsInput, UserUncheckedCreateWithoutClientDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type ClientUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutClientDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutClientDocumentsInput, UserUncheckedCreateWithoutClientDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientDocumentsInput
    upsert?: UserUpsertWithoutClientDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientDocumentsInput, UserUpdateWithoutClientDocumentsInput>, UserUncheckedUpdateWithoutClientDocumentsInput>
  }

  export type AgencyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AgencyCreateWithoutDocumentsInput, AgencyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutDocumentsInput
    connect?: AgencyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgencyDocumentsInput = {
    create?: XOR<UserCreateWithoutAgencyDocumentsInput, UserUncheckedCreateWithoutAgencyDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AgencyCreateWithoutDocumentsInput, AgencyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutDocumentsInput
    upsert?: AgencyUpsertWithoutDocumentsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutDocumentsInput, AgencyUpdateWithoutDocumentsInput>, AgencyUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutAgencyDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutAgencyDocumentsInput, UserUncheckedCreateWithoutAgencyDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyDocumentsInput
    upsert?: UserUpsertWithoutAgencyDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyDocumentsInput, UserUpdateWithoutAgencyDocumentsInput>, UserUncheckedUpdateWithoutAgencyDocumentsInput>
  }

  export type RequirementCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<RequirementCreateWithoutDocumentsInput, RequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutDocumentsInput
    connect?: RequirementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequirementDocumentsInput = {
    create?: XOR<UserCreateWithoutRequirementDocumentsInput, UserUncheckedCreateWithoutRequirementDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<RequirementCreateWithoutDocumentsInput, RequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutDocumentsInput
    upsert?: RequirementUpsertWithoutDocumentsInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutDocumentsInput, RequirementUpdateWithoutDocumentsInput>, RequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutRequirementDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutRequirementDocumentsInput, UserUncheckedCreateWithoutRequirementDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementDocumentsInput
    upsert?: UserUpsertWithoutRequirementDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequirementDocumentsInput, UserUpdateWithoutRequirementDocumentsInput>, UserUncheckedUpdateWithoutRequirementDocumentsInput>
  }

  export type AuditLogCreateaffectedFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type AuditLogUpdateaffectedFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumDeletionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableFilter<$PrismaModel> | $Enums.DeletionType | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeletionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompanySectorFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorFilter<$PrismaModel> | $Enums.CompanySector
  }

  export type NestedEnumCompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeFilter<$PrismaModel> | $Enums.CompanySize
  }

  export type NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel> | $Enums.CompanySector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySectorFilter<$PrismaModel>
    _max?: NestedEnumCompanySectorFilter<$PrismaModel>
  }

  export type NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type NestedEnumExperienceLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperienceLevel | EnumExperienceLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExperienceLevelNullableFilter<$PrismaModel> | $Enums.ExperienceLevel | null
  }

  export type NestedEnumTicketTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTicketTypeNullableFilter<$PrismaModel> | $Enums.TicketType | null
  }

  export type NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type NestedEnumExperienceLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperienceLevel | EnumExperienceLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExperienceLevel[] | ListEnumExperienceLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExperienceLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExperienceLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExperienceLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumExperienceLevelNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTicketTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTicketTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TicketType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractDurationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableFilter<$PrismaModel> | $Enums.ContractDuration | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractDuration | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractDurationNullableFilter<$PrismaModel>
    _max?: NestedEnumContractDurationNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumLabourProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusFilter<$PrismaModel> | $Enums.LabourProfileStatus
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabourProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
  }

  export type NestedEnumProcedureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusFilter<$PrismaModel> | $Enums.ProcedureStatus
  }

  export type NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcedureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcedureStatusFilter<$PrismaModel>
    _max?: NestedEnumProcedureStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementCreateNestedManyWithoutClientInput
    documents?: ClientDocumentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutClientInput
    documents?: ClientDocumentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type AgencyCreateWithoutUserInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfiles?: LabourProfileCreateNestedManyWithoutAgencyInput
    requirements?: RequirementCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUserInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUserInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput>
  }

  export type AuditLogCreateManyPerformedByInputEnvelope = {
    data: AuditLogCreateManyPerformedByInput | AuditLogCreateManyPerformedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type LabourStatusLogCreateWithoutChangedByInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    labourProfile: LabourProfileCreateNestedOneWithoutStatusLogsInput
  }

  export type LabourStatusLogUncheckedCreateWithoutChangedByInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId: string
    createdAt?: Date | string
  }

  export type LabourStatusLogCreateOrConnectWithoutChangedByInput = {
    where: LabourStatusLogWhereUniqueInput
    create: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput>
  }

  export type LabourStatusLogCreateManyChangedByInputEnvelope = {
    data: LabourStatusLogCreateManyChangedByInput | LabourStatusLogCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type ClientDocumentCreateWithoutVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDocumentsInput
  }

  export type ClientDocumentUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientDocumentCreateOrConnectWithoutVerifiedByInput = {
    where: ClientDocumentWhereUniqueInput
    create: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type ClientDocumentCreateManyVerifiedByInputEnvelope = {
    data: ClientDocumentCreateManyVerifiedByInput | ClientDocumentCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type AgencyDocumentCreateWithoutVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutDocumentsInput
  }

  export type AgencyDocumentUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyDocumentCreateOrConnectWithoutVerifiedByInput = {
    where: AgencyDocumentWhereUniqueInput
    create: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type AgencyDocumentCreateManyVerifiedByInputEnvelope = {
    data: AgencyDocumentCreateManyVerifiedByInput | AgencyDocumentCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type RequirementDocumentCreateWithoutUploadedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutDocumentsInput
  }

  export type RequirementDocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    requirementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentCreateOrConnectWithoutUploadedByInput = {
    where: RequirementDocumentWhereUniqueInput
    create: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type RequirementDocumentCreateManyUploadedByInputEnvelope = {
    data: RequirementDocumentCreateManyUploadedByInput | RequirementDocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUpdateManyWithoutClientNestedInput
    documents?: ClientDocumentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutClientNestedInput
    documents?: ClientDocumentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgencyUpsertWithoutUserInput = {
    update: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUserInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfiles?: LabourProfileUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutPerformedByInput, AuditLogUncheckedUpdateWithoutPerformedByInput>
    create: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutPerformedByInput, AuditLogUncheckedUpdateWithoutPerformedByInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutPerformedByInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutPerformedByInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    recipientId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type LabourStatusLogUpsertWithWhereUniqueWithoutChangedByInput = {
    where: LabourStatusLogWhereUniqueInput
    update: XOR<LabourStatusLogUpdateWithoutChangedByInput, LabourStatusLogUncheckedUpdateWithoutChangedByInput>
    create: XOR<LabourStatusLogCreateWithoutChangedByInput, LabourStatusLogUncheckedCreateWithoutChangedByInput>
  }

  export type LabourStatusLogUpdateWithWhereUniqueWithoutChangedByInput = {
    where: LabourStatusLogWhereUniqueInput
    data: XOR<LabourStatusLogUpdateWithoutChangedByInput, LabourStatusLogUncheckedUpdateWithoutChangedByInput>
  }

  export type LabourStatusLogUpdateManyWithWhereWithoutChangedByInput = {
    where: LabourStatusLogScalarWhereInput
    data: XOR<LabourStatusLogUpdateManyMutationInput, LabourStatusLogUncheckedUpdateManyWithoutChangedByInput>
  }

  export type LabourStatusLogScalarWhereInput = {
    AND?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
    OR?: LabourStatusLogScalarWhereInput[]
    NOT?: LabourStatusLogScalarWhereInput | LabourStatusLogScalarWhereInput[]
    id?: StringFilter<"LabourStatusLog"> | string
    status?: EnumLabourProfileStatusFilter<"LabourStatusLog"> | $Enums.LabourProfileStatus
    comments?: StringNullableFilter<"LabourStatusLog"> | string | null
    metadata?: JsonNullableFilter<"LabourStatusLog">
    labourProfileId?: StringFilter<"LabourStatusLog"> | string
    changedById?: StringFilter<"LabourStatusLog"> | string
    createdAt?: DateTimeFilter<"LabourStatusLog"> | Date | string
  }

  export type ClientDocumentUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: ClientDocumentWhereUniqueInput
    update: XOR<ClientDocumentUpdateWithoutVerifiedByInput, ClientDocumentUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<ClientDocumentCreateWithoutVerifiedByInput, ClientDocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type ClientDocumentUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: ClientDocumentWhereUniqueInput
    data: XOR<ClientDocumentUpdateWithoutVerifiedByInput, ClientDocumentUncheckedUpdateWithoutVerifiedByInput>
  }

  export type ClientDocumentUpdateManyWithWhereWithoutVerifiedByInput = {
    where: ClientDocumentScalarWhereInput
    data: XOR<ClientDocumentUpdateManyMutationInput, ClientDocumentUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type ClientDocumentScalarWhereInput = {
    AND?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
    OR?: ClientDocumentScalarWhereInput[]
    NOT?: ClientDocumentScalarWhereInput | ClientDocumentScalarWhereInput[]
    id?: StringFilter<"ClientDocument"> | string
    type?: EnumDocumentTypeFilter<"ClientDocument"> | $Enums.DocumentType
    url?: StringFilter<"ClientDocument"> | string
    name?: StringNullableFilter<"ClientDocument"> | string | null
    description?: StringNullableFilter<"ClientDocument"> | string | null
    verified?: BoolFilter<"ClientDocument"> | boolean
    comments?: StringNullableFilter<"ClientDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"ClientDocument"> | Date | string | null
    clientId?: StringFilter<"ClientDocument"> | string
    verifiedById?: StringNullableFilter<"ClientDocument"> | string | null
    createdAt?: DateTimeFilter<"ClientDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ClientDocument"> | Date | string
  }

  export type AgencyDocumentUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: AgencyDocumentWhereUniqueInput
    update: XOR<AgencyDocumentUpdateWithoutVerifiedByInput, AgencyDocumentUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<AgencyDocumentCreateWithoutVerifiedByInput, AgencyDocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type AgencyDocumentUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: AgencyDocumentWhereUniqueInput
    data: XOR<AgencyDocumentUpdateWithoutVerifiedByInput, AgencyDocumentUncheckedUpdateWithoutVerifiedByInput>
  }

  export type AgencyDocumentUpdateManyWithWhereWithoutVerifiedByInput = {
    where: AgencyDocumentScalarWhereInput
    data: XOR<AgencyDocumentUpdateManyMutationInput, AgencyDocumentUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type AgencyDocumentScalarWhereInput = {
    AND?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
    OR?: AgencyDocumentScalarWhereInput[]
    NOT?: AgencyDocumentScalarWhereInput | AgencyDocumentScalarWhereInput[]
    id?: StringFilter<"AgencyDocument"> | string
    type?: EnumDocumentTypeFilter<"AgencyDocument"> | $Enums.DocumentType
    url?: StringFilter<"AgencyDocument"> | string
    name?: StringNullableFilter<"AgencyDocument"> | string | null
    description?: StringNullableFilter<"AgencyDocument"> | string | null
    verified?: BoolFilter<"AgencyDocument"> | boolean
    comments?: StringNullableFilter<"AgencyDocument"> | string | null
    expiryDate?: DateTimeNullableFilter<"AgencyDocument"> | Date | string | null
    agencyId?: StringFilter<"AgencyDocument"> | string
    verifiedById?: StringNullableFilter<"AgencyDocument"> | string | null
    createdAt?: DateTimeFilter<"AgencyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyDocument"> | Date | string
  }

  export type RequirementDocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: RequirementDocumentWhereUniqueInput
    update: XOR<RequirementDocumentUpdateWithoutUploadedByInput, RequirementDocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<RequirementDocumentCreateWithoutUploadedByInput, RequirementDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type RequirementDocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: RequirementDocumentWhereUniqueInput
    data: XOR<RequirementDocumentUpdateWithoutUploadedByInput, RequirementDocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type RequirementDocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: RequirementDocumentScalarWhereInput
    data: XOR<RequirementDocumentUpdateManyMutationInput, RequirementDocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type RequirementDocumentScalarWhereInput = {
    AND?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
    OR?: RequirementDocumentScalarWhereInput[]
    NOT?: RequirementDocumentScalarWhereInput | RequirementDocumentScalarWhereInput[]
    id?: StringFilter<"RequirementDocument"> | string
    type?: EnumDocumentTypeFilter<"RequirementDocument"> | $Enums.DocumentType
    url?: StringFilter<"RequirementDocument"> | string
    name?: StringNullableFilter<"RequirementDocument"> | string | null
    description?: StringNullableFilter<"RequirementDocument"> | string | null
    requirementId?: StringFilter<"RequirementDocument"> | string
    uploadedById?: StringFilter<"RequirementDocument"> | string
    createdAt?: DateTimeFilter<"RequirementDocument"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementDocument"> | Date | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type RequirementCreateWithoutClientInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutClientInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutClientInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput>
  }

  export type RequirementCreateManyClientInputEnvelope = {
    data: RequirementCreateManyClientInput | RequirementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientDocumentCreateWithoutClientInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifiedBy?: UserCreateNestedOneWithoutClientDocumentsInput
  }

  export type ClientDocumentUncheckedCreateWithoutClientInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientDocumentCreateOrConnectWithoutClientInput = {
    where: ClientDocumentWhereUniqueInput
    create: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput>
  }

  export type ClientDocumentCreateManyClientInputEnvelope = {
    data: ClientDocumentCreateManyClientInput | ClientDocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type RequirementUpsertWithWhereUniqueWithoutClientInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutClientInput, RequirementUncheckedUpdateWithoutClientInput>
    create: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutClientInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutClientInput, RequirementUncheckedUpdateWithoutClientInput>
  }

  export type RequirementUpdateManyWithWhereWithoutClientInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutClientInput>
  }

  export type RequirementScalarWhereInput = {
    AND?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    OR?: RequirementScalarWhereInput[]
    NOT?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    id?: StringFilter<"Requirement"> | string
    specialNotes?: StringNullableFilter<"Requirement"> | string | null
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    languages?: StringNullableListFilter<"Requirement">
    minExperience?: EnumExperienceLevelNullableFilter<"Requirement"> | $Enums.ExperienceLevel | null
    maxAge?: IntNullableFilter<"Requirement"> | number | null
    ticketType?: EnumTicketTypeNullableFilter<"Requirement"> | $Enums.TicketType | null
    ticketProvided?: BoolFilter<"Requirement"> | boolean
    clientId?: StringFilter<"Requirement"> | string
    assignedAgencyId?: StringNullableFilter<"Requirement"> | string | null
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    submittedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
  }

  export type ClientDocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientDocumentWhereUniqueInput
    update: XOR<ClientDocumentUpdateWithoutClientInput, ClientDocumentUncheckedUpdateWithoutClientInput>
    create: XOR<ClientDocumentCreateWithoutClientInput, ClientDocumentUncheckedCreateWithoutClientInput>
  }

  export type ClientDocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientDocumentWhereUniqueInput
    data: XOR<ClientDocumentUpdateWithoutClientInput, ClientDocumentUncheckedUpdateWithoutClientInput>
  }

  export type ClientDocumentUpdateManyWithWhereWithoutClientInput = {
    where: ClientDocumentScalarWhereInput
    data: XOR<ClientDocumentUpdateManyMutationInput, ClientDocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type UserCreateWithoutAgencyProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAgencyProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAgencyProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
  }

  export type LabourProfileCreateWithoutAgencyInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutLabourProfilesInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileCreateOrConnectWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput>
  }

  export type LabourProfileCreateManyAgencyInputEnvelope = {
    data: LabourProfileCreateManyAgencyInput | LabourProfileCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type RequirementCreateWithoutAssignedAgencyInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutAssignedAgencyInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutAssignedAgencyInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput>
  }

  export type RequirementCreateManyAssignedAgencyInputEnvelope = {
    data: RequirementCreateManyAssignedAgencyInput | RequirementCreateManyAssignedAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencyDocumentCreateWithoutAgencyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifiedBy?: UserCreateNestedOneWithoutAgencyDocumentsInput
  }

  export type AgencyDocumentUncheckedCreateWithoutAgencyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyDocumentCreateOrConnectWithoutAgencyInput = {
    where: AgencyDocumentWhereUniqueInput
    create: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyDocumentCreateManyAgencyInputEnvelope = {
    data: AgencyDocumentCreateManyAgencyInput | AgencyDocumentCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgencyProfileInput = {
    update: XOR<UserUpdateWithoutAgencyProfileInput, UserUncheckedUpdateWithoutAgencyProfileInput>
    create: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyProfileInput, UserUncheckedUpdateWithoutAgencyProfileInput>
  }

  export type UserUpdateWithoutAgencyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type LabourProfileUpsertWithWhereUniqueWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    update: XOR<LabourProfileUpdateWithoutAgencyInput, LabourProfileUncheckedUpdateWithoutAgencyInput>
    create: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput>
  }

  export type LabourProfileUpdateWithWhereUniqueWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    data: XOR<LabourProfileUpdateWithoutAgencyInput, LabourProfileUncheckedUpdateWithoutAgencyInput>
  }

  export type LabourProfileUpdateManyWithWhereWithoutAgencyInput = {
    where: LabourProfileScalarWhereInput
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyWithoutAgencyInput>
  }

  export type LabourProfileScalarWhereInput = {
    AND?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
    OR?: LabourProfileScalarWhereInput[]
    NOT?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
    id?: StringFilter<"LabourProfile"> | string
    name?: StringFilter<"LabourProfile"> | string
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    maritalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experienceYears?: IntFilter<"LabourProfile"> | number
    education?: StringNullableFilter<"LabourProfile"> | string | null
    currentPosition?: StringNullableFilter<"LabourProfile"> | string | null
    currentCompany?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    englishProficiency?: StringNullableFilter<"LabourProfile"> | string | null
    email?: StringNullableFilter<"LabourProfile"> | string | null
    phone?: StringFilter<"LabourProfile"> | string
    address?: StringNullableFilter<"LabourProfile"> | string | null
    city?: StringNullableFilter<"LabourProfile"> | string | null
    country?: StringNullableFilter<"LabourProfile"> | string | null
    cvUrl?: StringFilter<"LabourProfile"> | string
    passportNumber?: StringNullableFilter<"LabourProfile"> | string | null
    passportExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    medicalStatus?: StringNullableFilter<"LabourProfile"> | string | null
    medicalExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    photo?: StringNullableFilter<"LabourProfile"> | string | null
    otherDocs?: StringNullableListFilter<"LabourProfile">
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    statusReason?: StringNullableFilter<"LabourProfile"> | string | null
    requirementId?: StringFilter<"LabourProfile"> | string
    agencyId?: StringFilter<"LabourProfile"> | string
    deploymentDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractStartDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
  }

  export type RequirementUpsertWithWhereUniqueWithoutAssignedAgencyInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutAssignedAgencyInput, RequirementUncheckedUpdateWithoutAssignedAgencyInput>
    create: XOR<RequirementCreateWithoutAssignedAgencyInput, RequirementUncheckedCreateWithoutAssignedAgencyInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutAssignedAgencyInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutAssignedAgencyInput, RequirementUncheckedUpdateWithoutAssignedAgencyInput>
  }

  export type RequirementUpdateManyWithWhereWithoutAssignedAgencyInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutAssignedAgencyInput>
  }

  export type AgencyDocumentUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencyDocumentWhereUniqueInput
    update: XOR<AgencyDocumentUpdateWithoutAgencyInput, AgencyDocumentUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencyDocumentCreateWithoutAgencyInput, AgencyDocumentUncheckedCreateWithoutAgencyInput>
  }

  export type AgencyDocumentUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencyDocumentWhereUniqueInput
    data: XOR<AgencyDocumentUpdateWithoutAgencyInput, AgencyDocumentUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencyDocumentUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencyDocumentScalarWhereInput
    data: XOR<AgencyDocumentUpdateManyMutationInput, AgencyDocumentUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserCreateWithoutAdminProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ClientCreateWithoutRequirementsInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    documents?: ClientDocumentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutRequirementsInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ClientDocumentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRequirementsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
  }

  export type AgencyCreateWithoutRequirementsInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutAgencyInput
    documents?: AgencyDocumentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutRequirementsInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    documents?: AgencyDocumentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutRequirementsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutRequirementsInput, AgencyUncheckedCreateWithoutRequirementsInput>
  }

  export type JobRoleCreateWithoutRequirementInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleUncheckedCreateWithoutRequirementInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleCreateOrConnectWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    create: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput>
  }

  export type JobRoleCreateManyRequirementInputEnvelope = {
    data: JobRoleCreateManyRequirementInput | JobRoleCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type LabourProfileCreateWithoutRequirementInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutLabourProfilesInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateWithoutRequirementInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutLabourProfileInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileCreateOrConnectWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput>
  }

  export type LabourProfileCreateManyRequirementInputEnvelope = {
    data: LabourProfileCreateManyRequirementInput | LabourProfileCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureCreateWithoutRequirementInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfile?: LabourProfileCreateNestedOneWithoutProceduresInput
  }

  export type ProcedureUncheckedCreateWithoutRequirementInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureCreateOrConnectWithoutRequirementInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput>
  }

  export type ProcedureCreateManyRequirementInputEnvelope = {
    data: ProcedureCreateManyRequirementInput | ProcedureCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type RequirementDocumentCreateWithoutRequirementInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutRequirementDocumentsInput
  }

  export type RequirementDocumentUncheckedCreateWithoutRequirementInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentCreateOrConnectWithoutRequirementInput = {
    where: RequirementDocumentWhereUniqueInput
    create: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementDocumentCreateManyRequirementInputEnvelope = {
    data: RequirementDocumentCreateManyRequirementInput | RequirementDocumentCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutRequirementsInput = {
    update: XOR<ClientUpdateWithoutRequirementsInput, ClientUncheckedUpdateWithoutRequirementsInput>
    create: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRequirementsInput, ClientUncheckedUpdateWithoutRequirementsInput>
  }

  export type ClientUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    documents?: ClientDocumentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ClientDocumentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgencyUpsertWithoutRequirementsInput = {
    update: XOR<AgencyUpdateWithoutRequirementsInput, AgencyUncheckedUpdateWithoutRequirementsInput>
    create: XOR<AgencyCreateWithoutRequirementsInput, AgencyUncheckedCreateWithoutRequirementsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutRequirementsInput, AgencyUncheckedUpdateWithoutRequirementsInput>
  }

  export type AgencyUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutAgencyNestedInput
    documents?: AgencyDocumentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    documents?: AgencyDocumentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type JobRoleUpsertWithWhereUniqueWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    update: XOR<JobRoleUpdateWithoutRequirementInput, JobRoleUncheckedUpdateWithoutRequirementInput>
    create: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput>
  }

  export type JobRoleUpdateWithWhereUniqueWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    data: XOR<JobRoleUpdateWithoutRequirementInput, JobRoleUncheckedUpdateWithoutRequirementInput>
  }

  export type JobRoleUpdateManyWithWhereWithoutRequirementInput = {
    where: JobRoleScalarWhereInput
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyWithoutRequirementInput>
  }

  export type JobRoleScalarWhereInput = {
    AND?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
    OR?: JobRoleScalarWhereInput[]
    NOT?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
    id?: StringFilter<"JobRole"> | string
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    salary?: FloatNullableFilter<"JobRole"> | number | null
    salaryCurrency?: StringFilter<"JobRole"> | string
    startDate?: DateTimeNullableFilter<"JobRole"> | Date | string | null
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    requirementId?: StringFilter<"JobRole"> | string
    createdAt?: DateTimeFilter<"JobRole"> | Date | string
    updatedAt?: DateTimeFilter<"JobRole"> | Date | string
  }

  export type LabourProfileUpsertWithWhereUniqueWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    update: XOR<LabourProfileUpdateWithoutRequirementInput, LabourProfileUncheckedUpdateWithoutRequirementInput>
    create: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput>
  }

  export type LabourProfileUpdateWithWhereUniqueWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    data: XOR<LabourProfileUpdateWithoutRequirementInput, LabourProfileUncheckedUpdateWithoutRequirementInput>
  }

  export type LabourProfileUpdateManyWithWhereWithoutRequirementInput = {
    where: LabourProfileScalarWhereInput
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyWithoutRequirementInput>
  }

  export type ProcedureUpsertWithWhereUniqueWithoutRequirementInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutRequirementInput, ProcedureUncheckedUpdateWithoutRequirementInput>
    create: XOR<ProcedureCreateWithoutRequirementInput, ProcedureUncheckedCreateWithoutRequirementInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutRequirementInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutRequirementInput, ProcedureUncheckedUpdateWithoutRequirementInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutRequirementInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutRequirementInput>
  }

  export type ProcedureScalarWhereInput = {
    AND?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    OR?: ProcedureScalarWhereInput[]
    NOT?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    id?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    description?: StringFilter<"Procedure"> | string
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    dueDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    comments?: StringNullableFilter<"Procedure"> | string | null
    metadata?: JsonNullableFilter<"Procedure">
    requirementId?: StringNullableFilter<"Procedure"> | string | null
    labourProfileId?: StringNullableFilter<"Procedure"> | string | null
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
  }

  export type RequirementDocumentUpsertWithWhereUniqueWithoutRequirementInput = {
    where: RequirementDocumentWhereUniqueInput
    update: XOR<RequirementDocumentUpdateWithoutRequirementInput, RequirementDocumentUncheckedUpdateWithoutRequirementInput>
    create: XOR<RequirementDocumentCreateWithoutRequirementInput, RequirementDocumentUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementDocumentUpdateWithWhereUniqueWithoutRequirementInput = {
    where: RequirementDocumentWhereUniqueInput
    data: XOR<RequirementDocumentUpdateWithoutRequirementInput, RequirementDocumentUncheckedUpdateWithoutRequirementInput>
  }

  export type RequirementDocumentUpdateManyWithWhereWithoutRequirementInput = {
    where: RequirementDocumentScalarWhereInput
    data: XOR<RequirementDocumentUpdateManyMutationInput, RequirementDocumentUncheckedUpdateManyWithoutRequirementInput>
  }

  export type RequirementCreateWithoutJobRolesInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutJobRolesInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutJobRolesInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
  }

  export type RequirementUpsertWithoutJobRolesInput = {
    update: XOR<RequirementUpdateWithoutJobRolesInput, RequirementUncheckedUpdateWithoutJobRolesInput>
    create: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutJobRolesInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutJobRolesInput, RequirementUncheckedUpdateWithoutJobRolesInput>
  }

  export type RequirementUpdateWithoutJobRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutJobRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementCreateWithoutLabourProfilesInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutLabourProfilesInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutLabourProfilesInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutLabourProfilesInput, RequirementUncheckedCreateWithoutLabourProfilesInput>
  }

  export type AgencyCreateWithoutLabourProfilesInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    requirements?: RequirementCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutLabourProfilesInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutAssignedAgencyInput
    documents?: AgencyDocumentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutLabourProfilesInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutLabourProfilesInput, AgencyUncheckedCreateWithoutLabourProfilesInput>
  }

  export type LabourStatusLogCreateWithoutLabourProfileInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    changedBy: UserCreateNestedOneWithoutStatusLogsInput
  }

  export type LabourStatusLogUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    changedById: string
    createdAt?: Date | string
  }

  export type LabourStatusLogCreateOrConnectWithoutLabourProfileInput = {
    where: LabourStatusLogWhereUniqueInput
    create: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput>
  }

  export type LabourStatusLogCreateManyLabourProfileInputEnvelope = {
    data: LabourStatusLogCreateManyLabourProfileInput | LabourStatusLogCreateManyLabourProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureCreateWithoutLabourProfileInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement?: RequirementCreateNestedOneWithoutProceduresInput
  }

  export type ProcedureUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureCreateOrConnectWithoutLabourProfileInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput>
  }

  export type ProcedureCreateManyLabourProfileInputEnvelope = {
    data: ProcedureCreateManyLabourProfileInput | ProcedureCreateManyLabourProfileInput[]
    skipDuplicates?: boolean
  }

  export type RequirementUpsertWithoutLabourProfilesInput = {
    update: XOR<RequirementUpdateWithoutLabourProfilesInput, RequirementUncheckedUpdateWithoutLabourProfilesInput>
    create: XOR<RequirementCreateWithoutLabourProfilesInput, RequirementUncheckedCreateWithoutLabourProfilesInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutLabourProfilesInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutLabourProfilesInput, RequirementUncheckedUpdateWithoutLabourProfilesInput>
  }

  export type RequirementUpdateWithoutLabourProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutLabourProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type AgencyUpsertWithoutLabourProfilesInput = {
    update: XOR<AgencyUpdateWithoutLabourProfilesInput, AgencyUncheckedUpdateWithoutLabourProfilesInput>
    create: XOR<AgencyCreateWithoutLabourProfilesInput, AgencyUncheckedCreateWithoutLabourProfilesInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutLabourProfilesInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutLabourProfilesInput, AgencyUncheckedUpdateWithoutLabourProfilesInput>
  }

  export type AgencyUpdateWithoutLabourProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    requirements?: RequirementUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutLabourProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    documents?: AgencyDocumentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type LabourStatusLogUpsertWithWhereUniqueWithoutLabourProfileInput = {
    where: LabourStatusLogWhereUniqueInput
    update: XOR<LabourStatusLogUpdateWithoutLabourProfileInput, LabourStatusLogUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<LabourStatusLogCreateWithoutLabourProfileInput, LabourStatusLogUncheckedCreateWithoutLabourProfileInput>
  }

  export type LabourStatusLogUpdateWithWhereUniqueWithoutLabourProfileInput = {
    where: LabourStatusLogWhereUniqueInput
    data: XOR<LabourStatusLogUpdateWithoutLabourProfileInput, LabourStatusLogUncheckedUpdateWithoutLabourProfileInput>
  }

  export type LabourStatusLogUpdateManyWithWhereWithoutLabourProfileInput = {
    where: LabourStatusLogScalarWhereInput
    data: XOR<LabourStatusLogUpdateManyMutationInput, LabourStatusLogUncheckedUpdateManyWithoutLabourProfileInput>
  }

  export type ProcedureUpsertWithWhereUniqueWithoutLabourProfileInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutLabourProfileInput, ProcedureUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<ProcedureCreateWithoutLabourProfileInput, ProcedureUncheckedCreateWithoutLabourProfileInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutLabourProfileInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutLabourProfileInput, ProcedureUncheckedUpdateWithoutLabourProfileInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutLabourProfileInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutLabourProfileInput>
  }

  export type RequirementCreateWithoutProceduresInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutProceduresInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    documents?: RequirementDocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutProceduresInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutProceduresInput, RequirementUncheckedCreateWithoutProceduresInput>
  }

  export type LabourProfileCreateWithoutProceduresInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutLabourProfilesInput
    agency: AgencyCreateNestedOneWithoutLabourProfilesInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileCreateOrConnectWithoutProceduresInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutProceduresInput, LabourProfileUncheckedCreateWithoutProceduresInput>
  }

  export type RequirementUpsertWithoutProceduresInput = {
    update: XOR<RequirementUpdateWithoutProceduresInput, RequirementUncheckedUpdateWithoutProceduresInput>
    create: XOR<RequirementCreateWithoutProceduresInput, RequirementUncheckedCreateWithoutProceduresInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutProceduresInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutProceduresInput, RequirementUncheckedUpdateWithoutProceduresInput>
  }

  export type RequirementUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type LabourProfileUpsertWithoutProceduresInput = {
    update: XOR<LabourProfileUpdateWithoutProceduresInput, LabourProfileUncheckedUpdateWithoutProceduresInput>
    create: XOR<LabourProfileCreateWithoutProceduresInput, LabourProfileUncheckedCreateWithoutProceduresInput>
    where?: LabourProfileWhereInput
  }

  export type LabourProfileUpdateToOneWithWhereWithoutProceduresInput = {
    where?: LabourProfileWhereInput
    data: XOR<LabourProfileUpdateWithoutProceduresInput, LabourProfileUncheckedUpdateWithoutProceduresInput>
  }

  export type LabourProfileUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutLabourProfilesNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfilesNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileCreateWithoutStatusLogsInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutLabourProfilesInput
    agency: AgencyCreateNestedOneWithoutLabourProfilesInput
    procedures?: ProcedureCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateWithoutStatusLogsInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileCreateOrConnectWithoutStatusLogsInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutStatusLogsInput, LabourProfileUncheckedCreateWithoutStatusLogsInput>
  }

  export type UserCreateWithoutStatusLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutStatusLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutStatusLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
  }

  export type LabourProfileUpsertWithoutStatusLogsInput = {
    update: XOR<LabourProfileUpdateWithoutStatusLogsInput, LabourProfileUncheckedUpdateWithoutStatusLogsInput>
    create: XOR<LabourProfileCreateWithoutStatusLogsInput, LabourProfileUncheckedCreateWithoutStatusLogsInput>
    where?: LabourProfileWhereInput
  }

  export type LabourProfileUpdateToOneWithWhereWithoutStatusLogsInput = {
    where?: LabourProfileWhereInput
    data: XOR<LabourProfileUpdateWithoutStatusLogsInput, LabourProfileUncheckedUpdateWithoutStatusLogsInput>
  }

  export type LabourProfileUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutLabourProfilesNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfilesNestedInput
    procedures?: ProcedureUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type UserUpsertWithoutStatusLogsInput = {
    update: XOR<UserUpdateWithoutStatusLogsInput, UserUncheckedUpdateWithoutStatusLogsInput>
    create: XOR<UserCreateWithoutStatusLogsInput, UserUncheckedCreateWithoutStatusLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusLogsInput, UserUncheckedUpdateWithoutStatusLogsInput>
  }

  export type UserUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    requirements?: RequirementCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutClientDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutClientDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutClientDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientDocumentsInput, UserUncheckedCreateWithoutClientDocumentsInput>
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    requirements?: RequirementUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutClientDocumentsInput = {
    update: XOR<UserUpdateWithoutClientDocumentsInput, UserUncheckedUpdateWithoutClientDocumentsInput>
    create: XOR<UserCreateWithoutClientDocumentsInput, UserUncheckedCreateWithoutClientDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientDocumentsInput, UserUncheckedUpdateWithoutClientDocumentsInput>
  }

  export type UserUpdateWithoutClientDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AgencyCreateWithoutDocumentsInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutAgencyInput
    requirements?: RequirementCreateNestedManyWithoutAssignedAgencyInput
  }

  export type AgencyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutAssignedAgencyInput
  }

  export type AgencyCreateOrConnectWithoutDocumentsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutDocumentsInput, AgencyUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutAgencyDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAgencyDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAgencyDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyDocumentsInput, UserUncheckedCreateWithoutAgencyDocumentsInput>
  }

  export type AgencyUpsertWithoutDocumentsInput = {
    update: XOR<AgencyUpdateWithoutDocumentsInput, AgencyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AgencyCreateWithoutDocumentsInput, AgencyUncheckedCreateWithoutDocumentsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutDocumentsInput, AgencyUncheckedUpdateWithoutDocumentsInput>
  }

  export type AgencyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUpdateManyWithoutAssignedAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutAssignedAgencyNestedInput
  }

  export type UserUpsertWithoutAgencyDocumentsInput = {
    update: XOR<UserUpdateWithoutAgencyDocumentsInput, UserUncheckedUpdateWithoutAgencyDocumentsInput>
    create: XOR<UserCreateWithoutAgencyDocumentsInput, UserUncheckedCreateWithoutAgencyDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyDocumentsInput, UserUncheckedUpdateWithoutAgencyDocumentsInput>
  }

  export type UserUpdateWithoutAgencyDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type RequirementCreateWithoutDocumentsInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    client: ClientCreateNestedOneWithoutRequirementsInput
    assignedAgency?: AgencyCreateNestedOneWithoutRequirementsInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutDocumentsInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    labourProfiles?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutDocumentsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutDocumentsInput, RequirementUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutRequirementDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutRequirementDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutRequirementDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequirementDocumentsInput, UserUncheckedCreateWithoutRequirementDocumentsInput>
  }

  export type RequirementUpsertWithoutDocumentsInput = {
    update: XOR<RequirementUpdateWithoutDocumentsInput, RequirementUncheckedUpdateWithoutDocumentsInput>
    create: XOR<RequirementCreateWithoutDocumentsInput, RequirementUncheckedCreateWithoutDocumentsInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutDocumentsInput, RequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type RequirementUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type UserUpsertWithoutRequirementDocumentsInput = {
    update: XOR<UserUpdateWithoutRequirementDocumentsInput, UserUncheckedUpdateWithoutRequirementDocumentsInput>
    create: XOR<UserCreateWithoutRequirementDocumentsInput, UserUncheckedCreateWithoutRequirementDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequirementDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequirementDocumentsInput, UserUncheckedUpdateWithoutRequirementDocumentsInput>
  }

  export type UserUpdateWithoutRequirementDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRequirementDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    statusLogs?: LabourStatusLogCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    statusLogs?: LabourStatusLogUncheckedCreateNestedManyWithoutChangedByInput
    clientDocuments?: ClientDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    agencyDocuments?: AgencyDocumentUncheckedCreateNestedManyWithoutVerifiedByInput
    requirementDocuments?: RequirementDocumentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
  }

  export type AuditLogCreateManyPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type LabourStatusLogCreateManyChangedByInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId: string
    createdAt?: Date | string
  }

  export type ClientDocumentCreateManyVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyDocumentCreateManyVerifiedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentCreateManyUploadedByInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    requirementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutChangedByNestedInput
    clientDocuments?: ClientDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    agencyDocuments?: AgencyDocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
    requirementDocuments?: RequirementDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabourStatusLogUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfile?: LabourProfileUpdateOneRequiredWithoutStatusLogsNestedInput
  }

  export type LabourStatusLogUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ClientDocumentUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type AgencyDocumentUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type RequirementDocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateManyClientInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    assignedAgencyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
  }

  export type ClientDocumentCreateManyClientInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgency?: AgencyUpdateOneWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientDocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: UserUpdateOneWithoutClientDocumentsNestedInput
  }

  export type ClientDocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientDocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileCreateManyAgencyInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    requirementId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementCreateManyAssignedAgencyInput = {
    id?: string
    specialNotes?: string | null
    status?: $Enums.RequirementStatus
    languages?: RequirementCreatelanguagesInput | string[]
    minExperience?: $Enums.ExperienceLevel | null
    maxAge?: number | null
    ticketType?: $Enums.TicketType | null
    ticketProvided?: boolean
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
  }

  export type AgencyDocumentCreateManyAgencyInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    verified?: boolean
    comments?: string | null
    expiryDate?: Date | string | null
    verifiedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourProfileUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutLabourProfilesNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    requirementId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUpdateWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    labourProfiles?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutRequirementNestedInput
    documents?: RequirementDocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    languages?: RequirementUpdatelanguagesInput | string[]
    minExperience?: NullableEnumExperienceLevelFieldUpdateOperationsInput | $Enums.ExperienceLevel | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    ticketType?: NullableEnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType | null
    ticketProvided?: BoolFieldUpdateOperationsInput | boolean
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgencyDocumentUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: UserUpdateOneWithoutAgencyDocumentsNestedInput
  }

  export type AgencyDocumentUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyDocumentUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleCreateManyRequirementInput = {
    id?: string
    title: string
    quantity?: number
    nationality: string
    salary?: number | null
    salaryCurrency?: string
    startDate?: Date | string | null
    contractDuration?: $Enums.ContractDuration | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourProfileCreateManyRequirementInput = {
    id?: string
    name: string
    age: number
    gender: $Enums.Gender
    nationality: string
    maritalStatus?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experienceYears: number
    education?: string | null
    currentPosition?: string | null
    currentCompany?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    englishProficiency?: string | null
    email?: string | null
    phone: string
    address?: string | null
    city?: string | null
    country?: string | null
    cvUrl: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    visaType?: string | null
    visaExpiry?: Date | string | null
    medicalStatus?: string | null
    medicalExpiry?: Date | string | null
    photo?: string | null
    otherDocs?: LabourProfileCreateotherDocsInput | string[]
    status?: $Enums.LabourProfileStatus
    statusReason?: string | null
    agencyId: string
    deploymentDate?: Date | string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureCreateManyRequirementInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementDocumentCreateManyRequirementInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    name?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    salaryCurrency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutLabourProfilesNestedInput
    statusLogs?: LabourStatusLogUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusLogs?: LabourStatusLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experienceYears?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    currentPosition?: NullableStringFieldUpdateOperationsInput | string | null
    currentCompany?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    englishProficiency?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    medicalExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    otherDocs?: LabourProfileUpdateotherDocsInput | string[]
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    deploymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfile?: LabourProfileUpdateOneWithoutProceduresNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutRequirementDocumentsNestedInput
  }

  export type RequirementDocumentUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementDocumentUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogCreateManyLabourProfileInput = {
    id?: string
    status: $Enums.LabourProfileStatus
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    changedById: string
    createdAt?: Date | string
  }

  export type ProcedureCreateManyLabourProfileInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.ProcedureStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    comments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourStatusLogUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneRequiredWithoutStatusLogsNestedInput
  }

  export type LabourStatusLogUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStatusLogUncheckedUpdateManyWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneWithoutProceduresNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUncheckedUpdateManyWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}