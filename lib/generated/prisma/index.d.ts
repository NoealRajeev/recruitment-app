
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentRequirement
 * 
 */
export type DocumentRequirement = $Result.DefaultSelection<Prisma.$DocumentRequirementPayload>
/**
 * Model Requirement
 * 
 */
export type Requirement = $Result.DefaultSelection<Prisma.$RequirementPayload>
/**
 * Model JobRole
 * A single row in the "table" of roles for one requirement
 */
export type JobRole = $Result.DefaultSelection<Prisma.$JobRolePayload>
/**
 * Model LabourProfile
 * 
 */
export type LabourProfile = $Result.DefaultSelection<Prisma.$LabourProfilePayload>
/**
 * Model LabourAssignment
 * 
 */
export type LabourAssignment = $Result.DefaultSelection<Prisma.$LabourAssignmentPayload>
/**
 * Model LabourStageHistory
 * 
 */
export type LabourStageHistory = $Result.DefaultSelection<Prisma.$LabourStageHistoryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model JobRoleForwarding
 * 
 */
export type JobRoleForwarding = $Result.DefaultSelection<Prisma.$JobRoleForwardingPayload>
/**
 * Model OfferLetterDetails
 * 
 */
export type OfferLetterDetails = $Result.DefaultSelection<Prisma.$OfferLetterDetailsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  RECRUITMENT_ADMIN: 'RECRUITMENT_ADMIN',
  CLIENT_ADMIN: 'CLIENT_ADMIN',
  RECRUITMENT_AGENCY: 'RECRUITMENT_AGENCY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountStatus: {
  SUBMITTED: 'SUBMITTED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  NOT_VERIFIED: 'NOT_VERIFIED',
  SUSPENDED: 'SUSPENDED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const DocumentType: {
  PROFILE_IMAGE: 'PROFILE_IMAGE',
  LICENSE: 'LICENSE',
  INSURANCE: 'INSURANCE',
  ID_PROOF: 'ID_PROOF',
  ADDRESS_PROOF: 'ADDRESS_PROOF',
  COMPANY_REGISTRATION: 'COMPANY_REGISTRATION',
  PASSPORT: 'PASSPORT',
  CV: 'CV',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const DocumentCategory: {
  IMPORTANT: 'IMPORTANT',
  SUPPORTING: 'SUPPORTING'
};

export type DocumentCategory = (typeof DocumentCategory)[keyof typeof DocumentCategory]


export const CompanySector: {
  IT: 'IT',
  REAL_ESTATE: 'REAL_ESTATE',
  HEALTHCARE: 'HEALTHCARE',
  FINANCE: 'FINANCE',
  MANUFACTURING: 'MANUFACTURING',
  RETAIL: 'RETAIL',
  CONSTRUCTION: 'CONSTRUCTION',
  EDUCATION: 'EDUCATION',
  HOSPITALITY: 'HOSPITALITY',
  OIL_GAS: 'OIL_GAS',
  TRANSPORTATION: 'TRANSPORTATION',
  OTHER: 'OTHER'
};

export type CompanySector = (typeof CompanySector)[keyof typeof CompanySector]


export const CompanySize: {
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  ENTERPRISE: 'ENTERPRISE'
};

export type CompanySize = (typeof CompanySize)[keyof typeof CompanySize]


export const AuditAction: {
  USER_CREATE: 'USER_CREATE',
  USER_READ: 'USER_READ',
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  CLIENT_CREATE: 'CLIENT_CREATE',
  CLIENT_READ: 'CLIENT_READ',
  CLIENT_UPDATE: 'CLIENT_UPDATE',
  CLIENT_DELETE: 'CLIENT_DELETE',
  AGENCY_CREATE: 'AGENCY_CREATE',
  AGENCY_READ: 'AGENCY_READ',
  AGENCY_UPDATE: 'AGENCY_UPDATE',
  AGENCY_DELETE: 'AGENCY_DELETE',
  REQUIREMENT_CREATE: 'REQUIREMENT_CREATE',
  REQUIREMENT_READ: 'REQUIREMENT_READ',
  REQUIREMENT_UPDATE: 'REQUIREMENT_UPDATE',
  REQUIREMENT_DELETE: 'REQUIREMENT_DELETE',
  LABOUR_PROFILE_CREATE: 'LABOUR_PROFILE_CREATE',
  LABOUR_PROFILE_READ: 'LABOUR_PROFILE_READ',
  LABOUR_PROFILE_UPDATE: 'LABOUR_PROFILE_UPDATE',
  LABOUR_PROFILE_DELETE: 'LABOUR_PROFILE_DELETE',
  LABOUR_PROFILE_DOCUMENT_UPLOAD: 'LABOUR_PROFILE_DOCUMENT_UPLOAD',
  LABOUR_PROFILE_STATUS_CHANGE: 'LABOUR_PROFILE_STATUS_CHANGE',
  LABOUR_PROFILE_VERIFICATION_CHANGE: 'LABOUR_PROFILE_VERIFICATION_CHANGE',
  DOCUMENT_CREATE: 'DOCUMENT_CREATE',
  DOCUMENT_READ: 'DOCUMENT_READ',
  DOCUMENT_UPDATE: 'DOCUMENT_UPDATE',
  DOCUMENT_DELETE: 'DOCUMENT_DELETE',
  OTP_CREATE: 'OTP_CREATE',
  OTP_READ: 'OTP_READ',
  OTP_UPDATE: 'OTP_UPDATE',
  OTP_DELETE: 'OTP_DELETE',
  NOTIFICATION_CREATE: 'NOTIFICATION_CREATE',
  NOTIFICATION_READ: 'NOTIFICATION_READ',
  NOTIFICATION_UPDATE: 'NOTIFICATION_UPDATE',
  NOTIFICATION_DELETE: 'NOTIFICATION_DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  ACCOUNT_RECOVERY: 'ACCOUNT_RECOVERY'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const NotificationType: {
  USER_REGISTERED: 'USER_REGISTERED',
  USER_VERIFIED: 'USER_VERIFIED',
  USER_SUSPENDED: 'USER_SUSPENDED',
  USER_DELETED: 'USER_DELETED',
  PASSWORD_CHANGED: 'PASSWORD_CHANGED',
  ACCOUNT_RECOVERY: 'ACCOUNT_RECOVERY',
  REQUIREMENT_CREATED: 'REQUIREMENT_CREATED',
  REQUIREMENT_UPDATED: 'REQUIREMENT_UPDATED',
  REQUIREMENT_STATUS_CHANGED: 'REQUIREMENT_STATUS_CHANGED',
  REQUIREMENT_FORWARDED_TO_AGENCY: 'REQUIREMENT_FORWARDED_TO_AGENCY',
  REQUIREMENT_ACCEPTED: 'REQUIREMENT_ACCEPTED',
  REQUIREMENT_REJECTED: 'REQUIREMENT_REJECTED',
  REQUIREMENT_NEEDS_REVISION: 'REQUIREMENT_NEEDS_REVISION',
  LABOUR_PROFILE_CREATED: 'LABOUR_PROFILE_CREATED',
  LABOUR_PROFILE_STATUS_CHANGED: 'LABOUR_PROFILE_STATUS_CHANGED',
  LABOUR_PROFILE_VERIFIED: 'LABOUR_PROFILE_VERIFIED',
  LABOUR_PROFILE_DOCUMENT_UPLOADED: 'LABOUR_PROFILE_DOCUMENT_UPLOADED',
  LABOUR_PROFILE_STAGE_UPDATED: 'LABOUR_PROFILE_STAGE_UPDATED',
  ASSIGNMENT_CREATED: 'ASSIGNMENT_CREATED',
  ASSIGNMENT_STATUS_CHANGED: 'ASSIGNMENT_STATUS_CHANGED',
  ASSIGNMENT_FEEDBACK_RECEIVED: 'ASSIGNMENT_FEEDBACK_RECEIVED',
  DOCUMENT_UPLOADED: 'DOCUMENT_UPLOADED',
  DOCUMENT_VERIFIED: 'DOCUMENT_VERIFIED',
  DOCUMENT_REJECTED: 'DOCUMENT_REJECTED',
  OFFER_LETTER_GENERATED: 'OFFER_LETTER_GENERATED',
  OFFER_LETTER_SIGNED: 'OFFER_LETTER_SIGNED',
  VISA_UPLOADED: 'VISA_UPLOADED',
  TRAVEL_DOCUMENTS_UPLOADED: 'TRAVEL_DOCUMENTS_UPLOADED',
  STAGE_COMPLETED: 'STAGE_COMPLETED',
  STAGE_FAILED: 'STAGE_FAILED',
  STAGE_PENDING_ACTION: 'STAGE_PENDING_ACTION',
  TRAVEL_CONFIRMED: 'TRAVEL_CONFIRMED',
  ARRIVAL_CONFIRMED: 'ARRIVAL_CONFIRMED',
  LABOUR_DEPLOYED: 'LABOUR_DEPLOYED',
  AGENCY_ASSIGNED: 'AGENCY_ASSIGNED',
  AGENCY_RESPONSE_RECEIVED: 'AGENCY_RESPONSE_RECEIVED',
  AGENCY_STATUS_CHANGED: 'AGENCY_STATUS_CHANGED',
  SYSTEM_MAINTENANCE: 'SYSTEM_MAINTENANCE',
  SYSTEM_UPDATE: 'SYSTEM_UPDATE',
  SECURITY_ALERT: 'SECURITY_ALERT',
  WELCOME_MESSAGE: 'WELCOME_MESSAGE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const StageStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REJECTED: 'REJECTED',
  PAID: 'PAID',
  SIGNED: 'SIGNED',
  REFUSED: 'REFUSED',
  FIT: 'FIT',
  UNFIT: 'UNFIT',
  PASSED: 'PASSED',
  FILLED: 'FILLED',
  TRAVELED: 'TRAVELED',
  RESCHEDULED: 'RESCHEDULED',
  CANCELED: 'CANCELED',
  ARRIVED: 'ARRIVED',
  NOT_ARRIVED: 'NOT_ARRIVED',
  VISA_PRINTED: 'VISA_PRINTED'
};

export type StageStatus = (typeof StageStatus)[keyof typeof StageStatus]


export const LabourStage: {
  OFFER_LETTER_SIGN: 'OFFER_LETTER_SIGN',
  VISA_APPLYING: 'VISA_APPLYING',
  QVC_PAYMENT: 'QVC_PAYMENT',
  CONTRACT_SIGN: 'CONTRACT_SIGN',
  MEDICAL_STATUS: 'MEDICAL_STATUS',
  FINGERPRINT: 'FINGERPRINT',
  VISA_PRINTING: 'VISA_PRINTING',
  READY_TO_TRAVEL: 'READY_TO_TRAVEL',
  TRAVEL_CONFIRMATION: 'TRAVEL_CONFIRMATION',
  ARRIVAL_CONFIRMATION: 'ARRIVAL_CONFIRMATION',
  DEPLOYED: 'DEPLOYED'
};

export type LabourStage = (typeof LabourStage)[keyof typeof LabourStage]


export const DeletionType: {
  SCHEDULED: 'SCHEDULED',
  IMMEDIATE: 'IMMEDIATE'
};

export type DeletionType = (typeof DeletionType)[keyof typeof DeletionType]


export const RequirementStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  PARTIALLY_SUBMITTED: 'PARTIALLY_SUBMITTED',
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  FORWARDED: 'FORWARDED',
  ACCEPTED: 'ACCEPTED',
  PARTIALLY_ACCEPTED: 'PARTIALLY_ACCEPTED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  CLIENT_REVIEW: 'CLIENT_REVIEW',
  SUBMITTED_TO_CLIENT: 'SUBMITTED_TO_CLIENT',
  NEEDS_REVISION: 'NEEDS_REVISION',
  AGENCY_REJECTED: 'AGENCY_REJECTED'
};

export type RequirementStatus = (typeof RequirementStatus)[keyof typeof RequirementStatus]


export const ContractDuration: {
  ONE_MONTH: 'ONE_MONTH',
  THREE_MONTHS: 'THREE_MONTHS',
  SIX_MONTHS: 'SIX_MONTHS',
  ONE_YEAR: 'ONE_YEAR',
  TWO_YEARS: 'TWO_YEARS',
  THREE_YEARS: 'THREE_YEARS',
  FIVE_PLUS_YEARS: 'FIVE_PLUS_YEARS'
};

export type ContractDuration = (typeof ContractDuration)[keyof typeof ContractDuration]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const LabourProfileStatus: {
  RECEIVED: 'RECEIVED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SHORTLISTED: 'SHORTLISTED',
  DEPLOYED: 'DEPLOYED'
};

export type LabourProfileStatus = (typeof LabourProfileStatus)[keyof typeof LabourProfileStatus]


export const DocumentVerificationStatus: {
  PENDING: 'PENDING',
  PARTIALLY_VERIFIED: 'PARTIALLY_VERIFIED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type DocumentVerificationStatus = (typeof DocumentVerificationStatus)[keyof typeof DocumentVerificationStatus]


export const NotificationPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type DocumentCategory = $Enums.DocumentCategory

export const DocumentCategory: typeof $Enums.DocumentCategory

export type CompanySector = $Enums.CompanySector

export const CompanySector: typeof $Enums.CompanySector

export type CompanySize = $Enums.CompanySize

export const CompanySize: typeof $Enums.CompanySize

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type StageStatus = $Enums.StageStatus

export const StageStatus: typeof $Enums.StageStatus

export type LabourStage = $Enums.LabourStage

export const LabourStage: typeof $Enums.LabourStage

export type DeletionType = $Enums.DeletionType

export const DeletionType: typeof $Enums.DeletionType

export type RequirementStatus = $Enums.RequirementStatus

export const RequirementStatus: typeof $Enums.RequirementStatus

export type ContractDuration = $Enums.ContractDuration

export const ContractDuration: typeof $Enums.ContractDuration

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type LabourProfileStatus = $Enums.LabourProfileStatus

export const LabourProfileStatus: typeof $Enums.LabourProfileStatus

export type DocumentVerificationStatus = $Enums.DocumentVerificationStatus

export const DocumentVerificationStatus: typeof $Enums.DocumentVerificationStatus

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentRequirement`: Exposes CRUD operations for the **DocumentRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentRequirements
    * const documentRequirements = await prisma.documentRequirement.findMany()
    * ```
    */
  get documentRequirement(): Prisma.DocumentRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirement.findMany()
    * ```
    */
  get requirement(): Prisma.RequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRole`: Exposes CRUD operations for the **JobRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRoles
    * const jobRoles = await prisma.jobRole.findMany()
    * ```
    */
  get jobRole(): Prisma.JobRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourProfile`: Exposes CRUD operations for the **LabourProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourProfiles
    * const labourProfiles = await prisma.labourProfile.findMany()
    * ```
    */
  get labourProfile(): Prisma.LabourProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourAssignment`: Exposes CRUD operations for the **LabourAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourAssignments
    * const labourAssignments = await prisma.labourAssignment.findMany()
    * ```
    */
  get labourAssignment(): Prisma.LabourAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourStageHistory`: Exposes CRUD operations for the **LabourStageHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourStageHistories
    * const labourStageHistories = await prisma.labourStageHistory.findMany()
    * ```
    */
  get labourStageHistory(): Prisma.LabourStageHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRoleForwarding`: Exposes CRUD operations for the **JobRoleForwarding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRoleForwardings
    * const jobRoleForwardings = await prisma.jobRoleForwarding.findMany()
    * ```
    */
  get jobRoleForwarding(): Prisma.JobRoleForwardingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offerLetterDetails`: Exposes CRUD operations for the **OfferLetterDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferLetterDetails
    * const offerLetterDetails = await prisma.offerLetterDetails.findMany()
    * ```
    */
  get offerLetterDetails(): Prisma.OfferLetterDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Agency: 'Agency',
    Admin: 'Admin',
    Document: 'Document',
    DocumentRequirement: 'DocumentRequirement',
    Requirement: 'Requirement',
    JobRole: 'JobRole',
    LabourProfile: 'LabourProfile',
    LabourAssignment: 'LabourAssignment',
    LabourStageHistory: 'LabourStageHistory',
    AuditLog: 'AuditLog',
    JobRoleForwarding: 'JobRoleForwarding',
    OfferLetterDetails: 'OfferLetterDetails',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "agency" | "admin" | "document" | "documentRequirement" | "requirement" | "jobRole" | "labourProfile" | "labourAssignment" | "labourStageHistory" | "auditLog" | "jobRoleForwarding" | "offerLetterDetails" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentRequirement: {
        payload: Prisma.$DocumentRequirementPayload<ExtArgs>
        fields: Prisma.DocumentRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          findFirst: {
            args: Prisma.DocumentRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          findMany: {
            args: Prisma.DocumentRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>[]
          }
          create: {
            args: Prisma.DocumentRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          createMany: {
            args: Prisma.DocumentRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>[]
          }
          delete: {
            args: Prisma.DocumentRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          update: {
            args: Prisma.DocumentRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          deleteMany: {
            args: Prisma.DocumentRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>[]
          }
          upsert: {
            args: Prisma.DocumentRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          aggregate: {
            args: Prisma.DocumentRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentRequirement>
          }
          groupBy: {
            args: Prisma.DocumentRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentRequirementCountAggregateOutputType> | number
          }
        }
      }
      Requirement: {
        payload: Prisma.$RequirementPayload<ExtArgs>
        fields: Prisma.RequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findFirst: {
            args: Prisma.RequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findMany: {
            args: Prisma.RequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          create: {
            args: Prisma.RequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          createMany: {
            args: Prisma.RequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          delete: {
            args: Prisma.RequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          update: {
            args: Prisma.RequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          deleteMany: {
            args: Prisma.RequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          upsert: {
            args: Prisma.RequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          aggregate: {
            args: Prisma.RequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirement>
          }
          groupBy: {
            args: Prisma.RequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementCountAggregateOutputType> | number
          }
        }
      }
      JobRole: {
        payload: Prisma.$JobRolePayload<ExtArgs>
        fields: Prisma.JobRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          findFirst: {
            args: Prisma.JobRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          findMany: {
            args: Prisma.JobRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          create: {
            args: Prisma.JobRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          createMany: {
            args: Prisma.JobRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          delete: {
            args: Prisma.JobRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          update: {
            args: Prisma.JobRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          deleteMany: {
            args: Prisma.JobRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>[]
          }
          upsert: {
            args: Prisma.JobRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRolePayload>
          }
          aggregate: {
            args: Prisma.JobRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRole>
          }
          groupBy: {
            args: Prisma.JobRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRoleCountArgs<ExtArgs>
            result: $Utils.Optional<JobRoleCountAggregateOutputType> | number
          }
        }
      }
      LabourProfile: {
        payload: Prisma.$LabourProfilePayload<ExtArgs>
        fields: Prisma.LabourProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          findFirst: {
            args: Prisma.LabourProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          findMany: {
            args: Prisma.LabourProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          create: {
            args: Prisma.LabourProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          createMany: {
            args: Prisma.LabourProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          delete: {
            args: Prisma.LabourProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          update: {
            args: Prisma.LabourProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          deleteMany: {
            args: Prisma.LabourProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>[]
          }
          upsert: {
            args: Prisma.LabourProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourProfilePayload>
          }
          aggregate: {
            args: Prisma.LabourProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourProfile>
          }
          groupBy: {
            args: Prisma.LabourProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LabourProfileCountAggregateOutputType> | number
          }
        }
      }
      LabourAssignment: {
        payload: Prisma.$LabourAssignmentPayload<ExtArgs>
        fields: Prisma.LabourAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          findFirst: {
            args: Prisma.LabourAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          findMany: {
            args: Prisma.LabourAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>[]
          }
          create: {
            args: Prisma.LabourAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          createMany: {
            args: Prisma.LabourAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>[]
          }
          delete: {
            args: Prisma.LabourAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          update: {
            args: Prisma.LabourAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.LabourAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.LabourAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAssignmentPayload>
          }
          aggregate: {
            args: Prisma.LabourAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourAssignment>
          }
          groupBy: {
            args: Prisma.LabourAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<LabourAssignmentCountAggregateOutputType> | number
          }
        }
      }
      LabourStageHistory: {
        payload: Prisma.$LabourStageHistoryPayload<ExtArgs>
        fields: Prisma.LabourStageHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourStageHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourStageHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          findFirst: {
            args: Prisma.LabourStageHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourStageHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          findMany: {
            args: Prisma.LabourStageHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>[]
          }
          create: {
            args: Prisma.LabourStageHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          createMany: {
            args: Prisma.LabourStageHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourStageHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>[]
          }
          delete: {
            args: Prisma.LabourStageHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          update: {
            args: Prisma.LabourStageHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LabourStageHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourStageHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourStageHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>[]
          }
          upsert: {
            args: Prisma.LabourStageHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourStageHistoryPayload>
          }
          aggregate: {
            args: Prisma.LabourStageHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourStageHistory>
          }
          groupBy: {
            args: Prisma.LabourStageHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourStageHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourStageHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LabourStageHistoryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      JobRoleForwarding: {
        payload: Prisma.$JobRoleForwardingPayload<ExtArgs>
        fields: Prisma.JobRoleForwardingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRoleForwardingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRoleForwardingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          findFirst: {
            args: Prisma.JobRoleForwardingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRoleForwardingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          findMany: {
            args: Prisma.JobRoleForwardingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>[]
          }
          create: {
            args: Prisma.JobRoleForwardingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          createMany: {
            args: Prisma.JobRoleForwardingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobRoleForwardingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>[]
          }
          delete: {
            args: Prisma.JobRoleForwardingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          update: {
            args: Prisma.JobRoleForwardingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          deleteMany: {
            args: Prisma.JobRoleForwardingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRoleForwardingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobRoleForwardingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>[]
          }
          upsert: {
            args: Prisma.JobRoleForwardingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRoleForwardingPayload>
          }
          aggregate: {
            args: Prisma.JobRoleForwardingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRoleForwarding>
          }
          groupBy: {
            args: Prisma.JobRoleForwardingGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRoleForwardingGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRoleForwardingCountArgs<ExtArgs>
            result: $Utils.Optional<JobRoleForwardingCountAggregateOutputType> | number
          }
        }
      }
      OfferLetterDetails: {
        payload: Prisma.$OfferLetterDetailsPayload<ExtArgs>
        fields: Prisma.OfferLetterDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferLetterDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferLetterDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          findFirst: {
            args: Prisma.OfferLetterDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferLetterDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          findMany: {
            args: Prisma.OfferLetterDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>[]
          }
          create: {
            args: Prisma.OfferLetterDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          createMany: {
            args: Prisma.OfferLetterDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferLetterDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>[]
          }
          delete: {
            args: Prisma.OfferLetterDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          update: {
            args: Prisma.OfferLetterDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OfferLetterDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferLetterDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferLetterDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>[]
          }
          upsert: {
            args: Prisma.OfferLetterDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferLetterDetailsPayload>
          }
          aggregate: {
            args: Prisma.OfferLetterDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferLetterDetails>
          }
          groupBy: {
            args: Prisma.OfferLetterDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferLetterDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferLetterDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OfferLetterDetailsCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    agency?: AgencyOmit
    admin?: AdminOmit
    document?: DocumentOmit
    documentRequirement?: DocumentRequirementOmit
    requirement?: RequirementOmit
    jobRole?: JobRoleOmit
    labourProfile?: LabourProfileOmit
    labourAssignment?: LabourAssignmentOmit
    labourStageHistory?: LabourStageHistoryOmit
    auditLog?: AuditLogOmit
    jobRoleForwarding?: JobRoleForwardingOmit
    offerLetterDetails?: OfferLetterDetailsOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    auditLogs: number
    notifications: number
    sentNotifications: number
    Document: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    Document?: boolean | UserCountOutputTypeCountDocumentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    Requirement: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Requirement?: boolean | ClientCountOutputTypeCountRequirementArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    JobRole: number
    LabourProfile: number
    LabourAssignment: number
    jobRoleForwardings: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JobRole?: boolean | AgencyCountOutputTypeCountJobRoleArgs
    LabourProfile?: boolean | AgencyCountOutputTypeCountLabourProfileArgs
    LabourAssignment?: boolean | AgencyCountOutputTypeCountLabourAssignmentArgs
    jobRoleForwardings?: boolean | AgencyCountOutputTypeCountJobRoleForwardingsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountJobRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountLabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountLabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAssignmentWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountJobRoleForwardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleForwardingWhereInput
  }


  /**
   * Count Type DocumentRequirementCountOutputType
   */

  export type DocumentRequirementCountOutputType = {
    documents: number
  }

  export type DocumentRequirementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | DocumentRequirementCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentRequirementCountOutputType without action
   */
  export type DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirementCountOutputType
     */
    select?: DocumentRequirementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentRequirementCountOutputType without action
   */
  export type DocumentRequirementCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type RequirementCountOutputType
   */

  export type RequirementCountOutputType = {
    jobRoles: number
    auditLogs: number
    LabourProfile: number
  }

  export type RequirementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRoles?: boolean | RequirementCountOutputTypeCountJobRolesArgs
    auditLogs?: boolean | RequirementCountOutputTypeCountAuditLogsArgs
    LabourProfile?: boolean | RequirementCountOutputTypeCountLabourProfileArgs
  }

  // Custom InputTypes
  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementCountOutputType
     */
    select?: RequirementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountJobRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountLabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
  }


  /**
   * Count Type JobRoleCountOutputType
   */

  export type JobRoleCountOutputType = {
    LabourAssignment: number
    forwardings: number
  }

  export type JobRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LabourAssignment?: boolean | JobRoleCountOutputTypeCountLabourAssignmentArgs
    forwardings?: boolean | JobRoleCountOutputTypeCountForwardingsArgs
  }

  // Custom InputTypes
  /**
   * JobRoleCountOutputType without action
   */
  export type JobRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleCountOutputType
     */
    select?: JobRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobRoleCountOutputType without action
   */
  export type JobRoleCountOutputTypeCountLabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAssignmentWhereInput
  }

  /**
   * JobRoleCountOutputType without action
   */
  export type JobRoleCountOutputTypeCountForwardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleForwardingWhereInput
  }


  /**
   * Count Type LabourProfileCountOutputType
   */

  export type LabourProfileCountOutputType = {
    stages: number
    auditLogs: number
    Document: number
    LabourAssignment: number
  }

  export type LabourProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | LabourProfileCountOutputTypeCountStagesArgs
    auditLogs?: boolean | LabourProfileCountOutputTypeCountAuditLogsArgs
    Document?: boolean | LabourProfileCountOutputTypeCountDocumentArgs
    LabourAssignment?: boolean | LabourProfileCountOutputTypeCountLabourAssignmentArgs
  }

  // Custom InputTypes
  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfileCountOutputType
     */
    select?: LabourProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourStageHistoryWhereInput
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * LabourProfileCountOutputType without action
   */
  export type LabourProfileCountOutputTypeCountLabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAssignmentWhereInput
  }


  /**
   * Count Type AuditLogCountOutputType
   */

  export type AuditLogCountOutputType = {
    Requirement: number
    LabourProfile: number
  }

  export type AuditLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Requirement?: boolean | AuditLogCountOutputTypeCountRequirementArgs
    LabourProfile?: boolean | AuditLogCountOutputTypeCountLabourProfileArgs
  }

  // Custom InputTypes
  /**
   * AuditLogCountOutputType without action
   */
  export type AuditLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogCountOutputType
     */
    select?: AuditLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditLogCountOutputType without action
   */
  export type AuditLogCountOutputTypeCountRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * AuditLogCountOutputType without action
   */
  export type AuditLogCountOutputTypeCountLabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    tempPassword: string | null
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    resetRequired: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    tempPassword: string | null
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    resetRequired: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    tempPassword: number
    phone: number
    altContact: number
    profilePicture: number
    role: number
    status: number
    resetRequired: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    deleteAt: number
    deletionType: number
    deletionReason: number
    deletionRequestedBy: number
    createdById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    tempPassword?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    tempPassword?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    tempPassword?: true
    phone?: true
    altContact?: true
    profilePicture?: true
    role?: true
    status?: true
    resetRequired?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    deleteAt?: true
    deletionType?: true
    deletionReason?: true
    deletionRequestedBy?: true
    createdById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    tempPassword: string | null
    phone: string | null
    altContact: string | null
    profilePicture: string | null
    role: $Enums.UserRole
    status: $Enums.AccountStatus
    resetRequired: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    deleteAt: Date | null
    deletionType: $Enums.DeletionType | null
    deletionReason: string | null
    deletionRequestedBy: string | null
    createdById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    tempPassword?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    agencyProfile?: boolean | User$agencyProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    Document?: boolean | User$DocumentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    tempPassword?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    tempPassword?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    tempPassword?: boolean
    phone?: boolean
    altContact?: boolean
    profilePicture?: boolean
    role?: boolean
    status?: boolean
    resetRequired?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleteAt?: boolean
    deletionType?: boolean
    deletionReason?: boolean
    deletionRequestedBy?: boolean
    createdById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "tempPassword" | "phone" | "altContact" | "profilePicture" | "role" | "status" | "resetRequired" | "lastLogin" | "createdAt" | "updatedAt" | "deleteAt" | "deletionType" | "deletionReason" | "deletionRequestedBy" | "createdById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    agencyProfile?: boolean | User$agencyProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    Document?: boolean | User$DocumentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientProfile: Prisma.$ClientPayload<ExtArgs> | null
      agencyProfile: Prisma.$AgencyPayload<ExtArgs> | null
      adminProfile: Prisma.$AdminPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      Document: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      tempPassword: string | null
      phone: string | null
      altContact: string | null
      profilePicture: string | null
      role: $Enums.UserRole
      status: $Enums.AccountStatus
      resetRequired: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      deleteAt: Date | null
      deletionType: $Enums.DeletionType | null
      deletionReason: string | null
      deletionRequestedBy: string | null
      createdById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agencyProfile<T extends User$agencyProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyProfileArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Document<T extends User$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly tempPassword: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly altContact: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'AccountStatus'>
    readonly resetRequired: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deleteAt: FieldRef<"User", 'DateTime'>
    readonly deletionType: FieldRef<"User", 'DeletionType'>
    readonly deletionReason: FieldRef<"User", 'String'>
    readonly deletionRequestedBy: FieldRef<"User", 'String'>
    readonly createdById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.agencyProfile
   */
  export type User$agencyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.Document
   */
  export type User$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    registrationNo: string | null
    companySector: $Enums.CompanySector | null
    companySize: $Enums.CompanySize | null
    website: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    registrationNo: string | null
    companySector: $Enums.CompanySector | null
    companySize: $Enums.CompanySize | null
    website: string | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    registrationNo: number
    companySector: number
    companySize: number
    website: number
    address: number
    city: number
    country: number
    postalCode: number
    designation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    registrationNo?: true
    companySector?: true
    companySize?: true
    website?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string
    companyName: string
    registrationNo: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website: string | null
    address: string
    city: string
    country: string
    postalCode: string | null
    designation: string
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Requirement?: boolean | Client$RequirementArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    registrationNo?: boolean
    companySector?: boolean
    companySize?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "registrationNo" | "companySector" | "companySize" | "website" | "address" | "city" | "country" | "postalCode" | "designation" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Requirement?: boolean | Client$RequirementArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Requirement: Prisma.$RequirementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string
      registrationNo: string | null
      companySector: $Enums.CompanySector
      companySize: $Enums.CompanySize
      website: string | null
      address: string
      city: string
      country: string
      postalCode: string | null
      designation: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Requirement<T extends Client$RequirementArgs<ExtArgs> = {}>(args?: Subset<T, Client$RequirementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly registrationNo: FieldRef<"Client", 'String'>
    readonly companySector: FieldRef<"Client", 'CompanySector'>
    readonly companySize: FieldRef<"Client", 'CompanySize'>
    readonly website: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly postalCode: FieldRef<"Client", 'String'>
    readonly designation: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.Requirement
   */
  export type Client$RequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyName: string | null
    registrationNo: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    country: string | null
    website: string | null
    address: string | null
    city: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agencyName: string | null
    registrationNo: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    country: string | null
    website: string | null
    address: string | null
    city: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    userId: number
    agencyName: number
    registrationNo: number
    licenseNumber: number
    licenseExpiry: number
    country: number
    website: number
    address: number
    city: number
    postalCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyMinAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    userId?: true
    agencyName?: true
    registrationNo?: true
    licenseNumber?: true
    licenseExpiry?: true
    country?: true
    website?: true
    address?: true
    city?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    userId: string
    agencyName: string
    registrationNo: string | null
    licenseNumber: string
    licenseExpiry: Date
    country: string
    website: string | null
    address: string
    city: string
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    JobRole?: boolean | Agency$JobRoleArgs<ExtArgs>
    LabourProfile?: boolean | Agency$LabourProfileArgs<ExtArgs>
    LabourAssignment?: boolean | Agency$LabourAssignmentArgs<ExtArgs>
    jobRoleForwardings?: boolean | Agency$jobRoleForwardingsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    userId?: boolean
    agencyName?: boolean
    registrationNo?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    country?: boolean
    website?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agencyName" | "registrationNo" | "licenseNumber" | "licenseExpiry" | "country" | "website" | "address" | "city" | "postalCode" | "createdAt" | "updatedAt", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    JobRole?: boolean | Agency$JobRoleArgs<ExtArgs>
    LabourProfile?: boolean | Agency$LabourProfileArgs<ExtArgs>
    LabourAssignment?: boolean | Agency$LabourAssignmentArgs<ExtArgs>
    jobRoleForwardings?: boolean | Agency$jobRoleForwardingsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      JobRole: Prisma.$JobRolePayload<ExtArgs>[]
      LabourProfile: Prisma.$LabourProfilePayload<ExtArgs>[]
      LabourAssignment: Prisma.$LabourAssignmentPayload<ExtArgs>[]
      jobRoleForwardings: Prisma.$JobRoleForwardingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agencyName: string
      registrationNo: string | null
      licenseNumber: string
      licenseExpiry: Date
      country: string
      website: string | null
      address: string
      city: string
      postalCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    JobRole<T extends Agency$JobRoleArgs<ExtArgs> = {}>(args?: Subset<T, Agency$JobRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LabourProfile<T extends Agency$LabourProfileArgs<ExtArgs> = {}>(args?: Subset<T, Agency$LabourProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LabourAssignment<T extends Agency$LabourAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Agency$LabourAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobRoleForwardings<T extends Agency$jobRoleForwardingsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$jobRoleForwardingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly userId: FieldRef<"Agency", 'String'>
    readonly agencyName: FieldRef<"Agency", 'String'>
    readonly registrationNo: FieldRef<"Agency", 'String'>
    readonly licenseNumber: FieldRef<"Agency", 'String'>
    readonly licenseExpiry: FieldRef<"Agency", 'DateTime'>
    readonly country: FieldRef<"Agency", 'String'>
    readonly website: FieldRef<"Agency", 'String'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly city: FieldRef<"Agency", 'String'>
    readonly postalCode: FieldRef<"Agency", 'String'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.JobRole
   */
  export type Agency$JobRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    where?: JobRoleWhereInput
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    cursor?: JobRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * Agency.LabourProfile
   */
  export type Agency$LabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    cursor?: LabourProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * Agency.LabourAssignment
   */
  export type Agency$LabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    where?: LabourAssignmentWhereInput
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    cursor?: LabourAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * Agency.jobRoleForwardings
   */
  export type Agency$jobRoleForwardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    where?: JobRoleForwardingWhereInput
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    cursor?: JobRoleForwardingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRoleForwardingScalarFieldEnum | JobRoleForwardingScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    department: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    department?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    name: string
    department: string | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "department" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      department: string | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly department: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'Json'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    type: $Enums.DocumentType | null
    url: string | null
    labourProfileId: string | null
    status: $Enums.AccountStatus | null
    category: $Enums.DocumentCategory | null
    requirementId: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    type: $Enums.DocumentType | null
    url: string | null
    labourProfileId: string | null
    status: $Enums.AccountStatus | null
    category: $Enums.DocumentCategory | null
    requirementId: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    ownerId: number
    type: number
    url: number
    labourProfileId: number
    status: number
    category: number
    requirementId: number
    uploadedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    url?: true
    labourProfileId?: true
    status?: true
    category?: true
    requirementId?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    url?: true
    labourProfileId?: true
    status?: true
    category?: true
    requirementId?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    url?: true
    labourProfileId?: true
    status?: true
    category?: true
    requirementId?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    labourProfileId: string | null
    status: $Enums.AccountStatus
    category: $Enums.DocumentCategory
    requirementId: string | null
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    type?: boolean
    url?: boolean
    labourProfileId?: boolean
    status?: boolean
    category?: boolean
    requirementId?: boolean
    uploadedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    type?: boolean
    url?: boolean
    labourProfileId?: boolean
    status?: boolean
    category?: boolean
    requirementId?: boolean
    uploadedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    type?: boolean
    url?: boolean
    labourProfileId?: boolean
    status?: boolean
    category?: boolean
    requirementId?: boolean
    uploadedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    ownerId?: boolean
    type?: boolean
    url?: boolean
    labourProfileId?: boolean
    status?: boolean
    category?: boolean
    requirementId?: boolean
    uploadedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "type" | "url" | "labourProfileId" | "status" | "category" | "requirementId" | "uploadedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    labourProfile?: boolean | Document$labourProfileArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      labourProfile: Prisma.$LabourProfilePayload<ExtArgs> | null
      requirement: Prisma.$DocumentRequirementPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      type: $Enums.DocumentType
      url: string
      labourProfileId: string | null
      status: $Enums.AccountStatus
      category: $Enums.DocumentCategory
      requirementId: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labourProfile<T extends Document$labourProfileArgs<ExtArgs> = {}>(args?: Subset<T, Document$labourProfileArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requirement<T extends Document$requirementArgs<ExtArgs> = {}>(args?: Subset<T, Document$requirementArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly ownerId: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly url: FieldRef<"Document", 'String'>
    readonly labourProfileId: FieldRef<"Document", 'String'>
    readonly status: FieldRef<"Document", 'AccountStatus'>
    readonly category: FieldRef<"Document", 'DocumentCategory'>
    readonly requirementId: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.labourProfile
   */
  export type Document$labourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
  }

  /**
   * Document.requirement
   */
  export type Document$requirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    where?: DocumentRequirementWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentRequirement
   */

  export type AggregateDocumentRequirement = {
    _count: DocumentRequirementCountAggregateOutputType | null
    _min: DocumentRequirementMinAggregateOutputType | null
    _max: DocumentRequirementMaxAggregateOutputType | null
  }

  export type DocumentRequirementMinAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    documentType: $Enums.DocumentType | null
    category: $Enums.DocumentCategory | null
    createdAt: Date | null
  }

  export type DocumentRequirementMaxAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    documentType: $Enums.DocumentType | null
    category: $Enums.DocumentCategory | null
    createdAt: Date | null
  }

  export type DocumentRequirementCountAggregateOutputType = {
    id: number
    role: number
    documentType: number
    category: number
    createdAt: number
    _all: number
  }


  export type DocumentRequirementMinAggregateInputType = {
    id?: true
    role?: true
    documentType?: true
    category?: true
    createdAt?: true
  }

  export type DocumentRequirementMaxAggregateInputType = {
    id?: true
    role?: true
    documentType?: true
    category?: true
    createdAt?: true
  }

  export type DocumentRequirementCountAggregateInputType = {
    id?: true
    role?: true
    documentType?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRequirement to aggregate.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentRequirements
    **/
    _count?: true | DocumentRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentRequirementMaxAggregateInputType
  }

  export type GetDocumentRequirementAggregateType<T extends DocumentRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentRequirement[P]>
      : GetScalarType<T[P], AggregateDocumentRequirement[P]>
  }




  export type DocumentRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRequirementWhereInput
    orderBy?: DocumentRequirementOrderByWithAggregationInput | DocumentRequirementOrderByWithAggregationInput[]
    by: DocumentRequirementScalarFieldEnum[] | DocumentRequirementScalarFieldEnum
    having?: DocumentRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentRequirementCountAggregateInputType | true
    _min?: DocumentRequirementMinAggregateInputType
    _max?: DocumentRequirementMaxAggregateInputType
  }

  export type DocumentRequirementGroupByOutputType = {
    id: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category: $Enums.DocumentCategory
    createdAt: Date
    _count: DocumentRequirementCountAggregateOutputType | null
    _min: DocumentRequirementMinAggregateOutputType | null
    _max: DocumentRequirementMaxAggregateOutputType | null
  }

  type GetDocumentRequirementGroupByPayload<T extends DocumentRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentRequirementGroupByOutputType[P]>
        }
      >
    >


  export type DocumentRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    documentType?: boolean
    category?: boolean
    createdAt?: boolean
    documents?: boolean | DocumentRequirement$documentsArgs<ExtArgs>
    _count?: boolean | DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRequirement"]>

  export type DocumentRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    documentType?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["documentRequirement"]>

  export type DocumentRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    documentType?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["documentRequirement"]>

  export type DocumentRequirementSelectScalar = {
    id?: boolean
    role?: boolean
    documentType?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type DocumentRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "documentType" | "category" | "createdAt", ExtArgs["result"]["documentRequirement"]>
  export type DocumentRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | DocumentRequirement$documentsArgs<ExtArgs>
    _count?: boolean | DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentRequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentRequirement"
    objects: {
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.UserRole
      documentType: $Enums.DocumentType
      category: $Enums.DocumentCategory
      createdAt: Date
    }, ExtArgs["result"]["documentRequirement"]>
    composites: {}
  }

  type DocumentRequirementGetPayload<S extends boolean | null | undefined | DocumentRequirementDefaultArgs> = $Result.GetResult<Prisma.$DocumentRequirementPayload, S>

  type DocumentRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentRequirementCountAggregateInputType | true
    }

  export interface DocumentRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentRequirement'], meta: { name: 'DocumentRequirement' } }
    /**
     * Find zero or one DocumentRequirement that matches the filter.
     * @param {DocumentRequirementFindUniqueArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentRequirementFindUniqueArgs>(args: SelectSubset<T, DocumentRequirementFindUniqueArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentRequirementFindUniqueOrThrowArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindFirstArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentRequirementFindFirstArgs>(args?: SelectSubset<T, DocumentRequirementFindFirstArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindFirstOrThrowArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentRequirements
     * const documentRequirements = await prisma.documentRequirement.findMany()
     * 
     * // Get first 10 DocumentRequirements
     * const documentRequirements = await prisma.documentRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentRequirementWithIdOnly = await prisma.documentRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentRequirementFindManyArgs>(args?: SelectSubset<T, DocumentRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentRequirement.
     * @param {DocumentRequirementCreateArgs} args - Arguments to create a DocumentRequirement.
     * @example
     * // Create one DocumentRequirement
     * const DocumentRequirement = await prisma.documentRequirement.create({
     *   data: {
     *     // ... data to create a DocumentRequirement
     *   }
     * })
     * 
     */
    create<T extends DocumentRequirementCreateArgs>(args: SelectSubset<T, DocumentRequirementCreateArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentRequirements.
     * @param {DocumentRequirementCreateManyArgs} args - Arguments to create many DocumentRequirements.
     * @example
     * // Create many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentRequirementCreateManyArgs>(args?: SelectSubset<T, DocumentRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentRequirements and returns the data saved in the database.
     * @param {DocumentRequirementCreateManyAndReturnArgs} args - Arguments to create many DocumentRequirements.
     * @example
     * // Create many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentRequirements and only return the `id`
     * const documentRequirementWithIdOnly = await prisma.documentRequirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentRequirement.
     * @param {DocumentRequirementDeleteArgs} args - Arguments to delete one DocumentRequirement.
     * @example
     * // Delete one DocumentRequirement
     * const DocumentRequirement = await prisma.documentRequirement.delete({
     *   where: {
     *     // ... filter to delete one DocumentRequirement
     *   }
     * })
     * 
     */
    delete<T extends DocumentRequirementDeleteArgs>(args: SelectSubset<T, DocumentRequirementDeleteArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentRequirement.
     * @param {DocumentRequirementUpdateArgs} args - Arguments to update one DocumentRequirement.
     * @example
     * // Update one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentRequirementUpdateArgs>(args: SelectSubset<T, DocumentRequirementUpdateArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentRequirements.
     * @param {DocumentRequirementDeleteManyArgs} args - Arguments to filter DocumentRequirements to delete.
     * @example
     * // Delete a few DocumentRequirements
     * const { count } = await prisma.documentRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentRequirementDeleteManyArgs>(args?: SelectSubset<T, DocumentRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentRequirementUpdateManyArgs>(args: SelectSubset<T, DocumentRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRequirements and returns the data updated in the database.
     * @param {DocumentRequirementUpdateManyAndReturnArgs} args - Arguments to update many DocumentRequirements.
     * @example
     * // Update many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentRequirements and only return the `id`
     * const documentRequirementWithIdOnly = await prisma.documentRequirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentRequirement.
     * @param {DocumentRequirementUpsertArgs} args - Arguments to update or create a DocumentRequirement.
     * @example
     * // Update or create a DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.upsert({
     *   create: {
     *     // ... data to create a DocumentRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentRequirement we want to update
     *   }
     * })
     */
    upsert<T extends DocumentRequirementUpsertArgs>(args: SelectSubset<T, DocumentRequirementUpsertArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementCountArgs} args - Arguments to filter DocumentRequirements to count.
     * @example
     * // Count the number of DocumentRequirements
     * const count = await prisma.documentRequirement.count({
     *   where: {
     *     // ... the filter for the DocumentRequirements we want to count
     *   }
     * })
    **/
    count<T extends DocumentRequirementCountArgs>(
      args?: Subset<T, DocumentRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentRequirementAggregateArgs>(args: Subset<T, DocumentRequirementAggregateArgs>): Prisma.PrismaPromise<GetDocumentRequirementAggregateType<T>>

    /**
     * Group by DocumentRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentRequirementGroupByArgs['orderBy'] }
        : { orderBy?: DocumentRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentRequirement model
   */
  readonly fields: DocumentRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends DocumentRequirement$documentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentRequirement$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentRequirement model
   */
  interface DocumentRequirementFieldRefs {
    readonly id: FieldRef<"DocumentRequirement", 'String'>
    readonly role: FieldRef<"DocumentRequirement", 'UserRole'>
    readonly documentType: FieldRef<"DocumentRequirement", 'DocumentType'>
    readonly category: FieldRef<"DocumentRequirement", 'DocumentCategory'>
    readonly createdAt: FieldRef<"DocumentRequirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentRequirement findUnique
   */
  export type DocumentRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement findUniqueOrThrow
   */
  export type DocumentRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement findFirst
   */
  export type DocumentRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRequirements.
     */
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement findFirstOrThrow
   */
  export type DocumentRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRequirements.
     */
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement findMany
   */
  export type DocumentRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirements to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement create
   */
  export type DocumentRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentRequirement.
     */
    data: XOR<DocumentRequirementCreateInput, DocumentRequirementUncheckedCreateInput>
  }

  /**
   * DocumentRequirement createMany
   */
  export type DocumentRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentRequirements.
     */
    data: DocumentRequirementCreateManyInput | DocumentRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentRequirement createManyAndReturn
   */
  export type DocumentRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentRequirements.
     */
    data: DocumentRequirementCreateManyInput | DocumentRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentRequirement update
   */
  export type DocumentRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentRequirement.
     */
    data: XOR<DocumentRequirementUpdateInput, DocumentRequirementUncheckedUpdateInput>
    /**
     * Choose, which DocumentRequirement to update.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement updateMany
   */
  export type DocumentRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentRequirements.
     */
    data: XOR<DocumentRequirementUpdateManyMutationInput, DocumentRequirementUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRequirements to update
     */
    where?: DocumentRequirementWhereInput
    /**
     * Limit how many DocumentRequirements to update.
     */
    limit?: number
  }

  /**
   * DocumentRequirement updateManyAndReturn
   */
  export type DocumentRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * The data used to update DocumentRequirements.
     */
    data: XOR<DocumentRequirementUpdateManyMutationInput, DocumentRequirementUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRequirements to update
     */
    where?: DocumentRequirementWhereInput
    /**
     * Limit how many DocumentRequirements to update.
     */
    limit?: number
  }

  /**
   * DocumentRequirement upsert
   */
  export type DocumentRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentRequirement to update in case it exists.
     */
    where: DocumentRequirementWhereUniqueInput
    /**
     * In case the DocumentRequirement found by the `where` argument doesn't exist, create a new DocumentRequirement with this data.
     */
    create: XOR<DocumentRequirementCreateInput, DocumentRequirementUncheckedCreateInput>
    /**
     * In case the DocumentRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentRequirementUpdateInput, DocumentRequirementUncheckedUpdateInput>
  }

  /**
   * DocumentRequirement delete
   */
  export type DocumentRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter which DocumentRequirement to delete.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement deleteMany
   */
  export type DocumentRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRequirements to delete
     */
    where?: DocumentRequirementWhereInput
    /**
     * Limit how many DocumentRequirements to delete.
     */
    limit?: number
  }

  /**
   * DocumentRequirement.documents
   */
  export type DocumentRequirement$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * DocumentRequirement without action
   */
  export type DocumentRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRequirement
     */
    omit?: DocumentRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
  }


  /**
   * Model Requirement
   */

  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  export type RequirementMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    status: $Enums.RequirementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    status: $Enums.RequirementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementCountAggregateOutputType = {
    id: number
    clientId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequirementMinAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementMaxAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementCountAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirement to aggregate.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requirements
    **/
    _count?: true | RequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementMaxAggregateInputType
  }

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement[P]>
      : GetScalarType<T[P], AggregateRequirement[P]>
  }




  export type RequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithAggregationInput | RequirementOrderByWithAggregationInput[]
    by: RequirementScalarFieldEnum[] | RequirementScalarFieldEnum
    having?: RequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementCountAggregateInputType | true
    _min?: RequirementMinAggregateInputType
    _max?: RequirementMaxAggregateInputType
  }

  export type RequirementGroupByOutputType = {
    id: string
    clientId: string
    status: $Enums.RequirementStatus
    createdAt: Date
    updatedAt: Date
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>
        }
      >
    >


  export type RequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    jobRoles?: boolean | Requirement$jobRolesArgs<ExtArgs>
    auditLogs?: boolean | Requirement$auditLogsArgs<ExtArgs>
    LabourProfile?: boolean | Requirement$LabourProfileArgs<ExtArgs>
    OfferLetterDetails?: boolean | Requirement$OfferLetterDetailsArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectScalar = {
    id?: boolean
    clientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["requirement"]>
  export type RequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    jobRoles?: boolean | Requirement$jobRolesArgs<ExtArgs>
    auditLogs?: boolean | Requirement$auditLogsArgs<ExtArgs>
    LabourProfile?: boolean | Requirement$LabourProfileArgs<ExtArgs>
    OfferLetterDetails?: boolean | Requirement$OfferLetterDetailsArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $RequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requirement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      /**
       * one requirement can have many job roles
       */
      jobRoles: Prisma.$JobRolePayload<ExtArgs>[]
      /**
       * history / audit
       */
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      LabourProfile: Prisma.$LabourProfilePayload<ExtArgs>[]
      OfferLetterDetails: Prisma.$OfferLetterDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      status: $Enums.RequirementStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requirement"]>
    composites: {}
  }

  type RequirementGetPayload<S extends boolean | null | undefined | RequirementDefaultArgs> = $Result.GetResult<Prisma.$RequirementPayload, S>

  type RequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementCountAggregateInputType | true
    }

  export interface RequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requirement'], meta: { name: 'Requirement' } }
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementFindUniqueArgs>(args: SelectSubset<T, RequirementFindUniqueArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementFindUniqueOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementFindFirstArgs>(args?: SelectSubset<T, RequirementFindFirstArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementFindManyArgs>(args?: SelectSubset<T, RequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     * 
     */
    create<T extends RequirementCreateArgs>(args: SelectSubset<T, RequirementCreateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirements.
     * @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementCreateManyArgs>(args?: SelectSubset<T, RequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {RequirementCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     * 
     */
    delete<T extends RequirementDeleteArgs>(args: SelectSubset<T, RequirementDeleteArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementUpdateArgs>(args: SelectSubset<T, RequirementUpdateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementDeleteManyArgs>(args?: SelectSubset<T, RequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementUpdateManyArgs>(args: SelectSubset<T, RequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {RequirementUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
     */
    upsert<T extends RequirementUpsertArgs>(args: SelectSubset<T, RequirementUpsertArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAggregateArgs>(args: Subset<T, RequirementAggregateArgs>): Prisma.PrismaPromise<GetRequirementAggregateType<T>>

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requirement model
   */
  readonly fields: RequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobRoles<T extends Requirement$jobRolesArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$jobRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Requirement$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LabourProfile<T extends Requirement$LabourProfileArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$LabourProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OfferLetterDetails<T extends Requirement$OfferLetterDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$OfferLetterDetailsArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requirement model
   */
  interface RequirementFieldRefs {
    readonly id: FieldRef<"Requirement", 'String'>
    readonly clientId: FieldRef<"Requirement", 'String'>
    readonly status: FieldRef<"Requirement", 'RequirementStatus'>
    readonly createdAt: FieldRef<"Requirement", 'DateTime'>
    readonly updatedAt: FieldRef<"Requirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findUniqueOrThrow
   */
  export type RequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findFirstOrThrow
   */
  export type RequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirements to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement create
   */
  export type RequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a Requirement.
     */
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
  }

  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Requirement createManyAndReturn
   */
  export type RequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement update
   */
  export type RequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a Requirement.
     */
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
    /**
     * Choose, which Requirement to update.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
  }

  /**
   * Requirement updateManyAndReturn
   */
  export type RequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the Requirement to update in case it exists.
     */
    where: RequirementWhereUniqueInput
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     */
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
  }

  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter which Requirement to delete.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirements to delete
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to delete.
     */
    limit?: number
  }

  /**
   * Requirement.jobRoles
   */
  export type Requirement$jobRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    where?: JobRoleWhereInput
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    cursor?: JobRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * Requirement.auditLogs
   */
  export type Requirement$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Requirement.LabourProfile
   */
  export type Requirement$LabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    cursor?: LabourProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * Requirement.OfferLetterDetails
   */
  export type Requirement$OfferLetterDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    where?: OfferLetterDetailsWhereInput
  }

  /**
   * Requirement without action
   */
  export type RequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
  }


  /**
   * Model JobRole
   */

  export type AggregateJobRole = {
    _count: JobRoleCountAggregateOutputType | null
    _avg: JobRoleAvgAggregateOutputType | null
    _sum: JobRoleSumAggregateOutputType | null
    _min: JobRoleMinAggregateOutputType | null
    _max: JobRoleMaxAggregateOutputType | null
  }

  export type JobRoleAvgAggregateOutputType = {
    quantity: number | null
    basicSalary: number | null
    foodAllowance: number | null
    housingAllowance: number | null
    transportationAllowance: number | null
    mobileAllowance: number | null
    natureOfWorkAllowance: number | null
    otherAllowance: number | null
    totalExperienceYears: number | null
    preferredAge: number | null
  }

  export type JobRoleSumAggregateOutputType = {
    quantity: number | null
    basicSalary: number | null
    foodAllowance: number | null
    housingAllowance: number | null
    transportationAllowance: number | null
    mobileAllowance: number | null
    natureOfWorkAllowance: number | null
    otherAllowance: number | null
    totalExperienceYears: number | null
    preferredAge: number | null
  }

  export type JobRoleMinAggregateOutputType = {
    id: string | null
    requirementId: string | null
    title: string | null
    quantity: number | null
    nationality: string | null
    startDate: Date | null
    contractDuration: $Enums.ContractDuration | null
    salaryCurrency: string | null
    basicSalary: number | null
    foodAllowance: number | null
    foodProvidedByCompany: boolean | null
    housingAllowance: number | null
    housingProvidedByCompany: boolean | null
    transportationAllowance: number | null
    transportationProvidedByCompany: boolean | null
    healthInsurance: string | null
    mobileAllowance: number | null
    mobileProvidedByCompany: boolean | null
    natureOfWorkAllowance: number | null
    otherAllowance: number | null
    ticketFrequency: string | null
    workLocations: string | null
    previousExperience: string | null
    totalExperienceYears: number | null
    preferredAge: number | null
    specialRequirements: string | null
    assignedAgencyId: string | null
    agencyStatus: $Enums.RequirementStatus | null
    adminStatus: $Enums.RequirementStatus | null
    needsMoreLabour: boolean | null
  }

  export type JobRoleMaxAggregateOutputType = {
    id: string | null
    requirementId: string | null
    title: string | null
    quantity: number | null
    nationality: string | null
    startDate: Date | null
    contractDuration: $Enums.ContractDuration | null
    salaryCurrency: string | null
    basicSalary: number | null
    foodAllowance: number | null
    foodProvidedByCompany: boolean | null
    housingAllowance: number | null
    housingProvidedByCompany: boolean | null
    transportationAllowance: number | null
    transportationProvidedByCompany: boolean | null
    healthInsurance: string | null
    mobileAllowance: number | null
    mobileProvidedByCompany: boolean | null
    natureOfWorkAllowance: number | null
    otherAllowance: number | null
    ticketFrequency: string | null
    workLocations: string | null
    previousExperience: string | null
    totalExperienceYears: number | null
    preferredAge: number | null
    specialRequirements: string | null
    assignedAgencyId: string | null
    agencyStatus: $Enums.RequirementStatus | null
    adminStatus: $Enums.RequirementStatus | null
    needsMoreLabour: boolean | null
  }

  export type JobRoleCountAggregateOutputType = {
    id: number
    requirementId: number
    title: number
    quantity: number
    nationality: number
    startDate: number
    contractDuration: number
    salaryCurrency: number
    basicSalary: number
    foodAllowance: number
    foodProvidedByCompany: number
    housingAllowance: number
    housingProvidedByCompany: number
    transportationAllowance: number
    transportationProvidedByCompany: number
    healthInsurance: number
    mobileAllowance: number
    mobileProvidedByCompany: number
    natureOfWorkAllowance: number
    otherAllowance: number
    ticketFrequency: number
    workLocations: number
    previousExperience: number
    totalExperienceYears: number
    preferredAge: number
    languageRequirements: number
    specialRequirements: number
    assignedAgencyId: number
    agencyStatus: number
    adminStatus: number
    needsMoreLabour: number
    _all: number
  }


  export type JobRoleAvgAggregateInputType = {
    quantity?: true
    basicSalary?: true
    foodAllowance?: true
    housingAllowance?: true
    transportationAllowance?: true
    mobileAllowance?: true
    natureOfWorkAllowance?: true
    otherAllowance?: true
    totalExperienceYears?: true
    preferredAge?: true
  }

  export type JobRoleSumAggregateInputType = {
    quantity?: true
    basicSalary?: true
    foodAllowance?: true
    housingAllowance?: true
    transportationAllowance?: true
    mobileAllowance?: true
    natureOfWorkAllowance?: true
    otherAllowance?: true
    totalExperienceYears?: true
    preferredAge?: true
  }

  export type JobRoleMinAggregateInputType = {
    id?: true
    requirementId?: true
    title?: true
    quantity?: true
    nationality?: true
    startDate?: true
    contractDuration?: true
    salaryCurrency?: true
    basicSalary?: true
    foodAllowance?: true
    foodProvidedByCompany?: true
    housingAllowance?: true
    housingProvidedByCompany?: true
    transportationAllowance?: true
    transportationProvidedByCompany?: true
    healthInsurance?: true
    mobileAllowance?: true
    mobileProvidedByCompany?: true
    natureOfWorkAllowance?: true
    otherAllowance?: true
    ticketFrequency?: true
    workLocations?: true
    previousExperience?: true
    totalExperienceYears?: true
    preferredAge?: true
    specialRequirements?: true
    assignedAgencyId?: true
    agencyStatus?: true
    adminStatus?: true
    needsMoreLabour?: true
  }

  export type JobRoleMaxAggregateInputType = {
    id?: true
    requirementId?: true
    title?: true
    quantity?: true
    nationality?: true
    startDate?: true
    contractDuration?: true
    salaryCurrency?: true
    basicSalary?: true
    foodAllowance?: true
    foodProvidedByCompany?: true
    housingAllowance?: true
    housingProvidedByCompany?: true
    transportationAllowance?: true
    transportationProvidedByCompany?: true
    healthInsurance?: true
    mobileAllowance?: true
    mobileProvidedByCompany?: true
    natureOfWorkAllowance?: true
    otherAllowance?: true
    ticketFrequency?: true
    workLocations?: true
    previousExperience?: true
    totalExperienceYears?: true
    preferredAge?: true
    specialRequirements?: true
    assignedAgencyId?: true
    agencyStatus?: true
    adminStatus?: true
    needsMoreLabour?: true
  }

  export type JobRoleCountAggregateInputType = {
    id?: true
    requirementId?: true
    title?: true
    quantity?: true
    nationality?: true
    startDate?: true
    contractDuration?: true
    salaryCurrency?: true
    basicSalary?: true
    foodAllowance?: true
    foodProvidedByCompany?: true
    housingAllowance?: true
    housingProvidedByCompany?: true
    transportationAllowance?: true
    transportationProvidedByCompany?: true
    healthInsurance?: true
    mobileAllowance?: true
    mobileProvidedByCompany?: true
    natureOfWorkAllowance?: true
    otherAllowance?: true
    ticketFrequency?: true
    workLocations?: true
    previousExperience?: true
    totalExperienceYears?: true
    preferredAge?: true
    languageRequirements?: true
    specialRequirements?: true
    assignedAgencyId?: true
    agencyStatus?: true
    adminStatus?: true
    needsMoreLabour?: true
    _all?: true
  }

  export type JobRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRole to aggregate.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRoles
    **/
    _count?: true | JobRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRoleMaxAggregateInputType
  }

  export type GetJobRoleAggregateType<T extends JobRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRole[P]>
      : GetScalarType<T[P], AggregateJobRole[P]>
  }




  export type JobRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleWhereInput
    orderBy?: JobRoleOrderByWithAggregationInput | JobRoleOrderByWithAggregationInput[]
    by: JobRoleScalarFieldEnum[] | JobRoleScalarFieldEnum
    having?: JobRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRoleCountAggregateInputType | true
    _avg?: JobRoleAvgAggregateInputType
    _sum?: JobRoleSumAggregateInputType
    _min?: JobRoleMinAggregateInputType
    _max?: JobRoleMaxAggregateInputType
  }

  export type JobRoleGroupByOutputType = {
    id: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date
    contractDuration: $Enums.ContractDuration | null
    salaryCurrency: string | null
    basicSalary: number
    foodAllowance: number | null
    foodProvidedByCompany: boolean
    housingAllowance: number | null
    housingProvidedByCompany: boolean
    transportationAllowance: number | null
    transportationProvidedByCompany: boolean
    healthInsurance: string
    mobileAllowance: number | null
    mobileProvidedByCompany: boolean
    natureOfWorkAllowance: number | null
    otherAllowance: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears: number | null
    preferredAge: number | null
    languageRequirements: string[]
    specialRequirements: string | null
    assignedAgencyId: string | null
    agencyStatus: $Enums.RequirementStatus
    adminStatus: $Enums.RequirementStatus
    needsMoreLabour: boolean
    _count: JobRoleCountAggregateOutputType | null
    _avg: JobRoleAvgAggregateOutputType | null
    _sum: JobRoleSumAggregateOutputType | null
    _min: JobRoleMinAggregateOutputType | null
    _max: JobRoleMaxAggregateOutputType | null
  }

  type GetJobRoleGroupByPayload<T extends JobRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRoleGroupByOutputType[P]>
            : GetScalarType<T[P], JobRoleGroupByOutputType[P]>
        }
      >
    >


  export type JobRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    startDate?: boolean
    contractDuration?: boolean
    salaryCurrency?: boolean
    basicSalary?: boolean
    foodAllowance?: boolean
    foodProvidedByCompany?: boolean
    housingAllowance?: boolean
    housingProvidedByCompany?: boolean
    transportationAllowance?: boolean
    transportationProvidedByCompany?: boolean
    healthInsurance?: boolean
    mobileAllowance?: boolean
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: boolean
    otherAllowance?: boolean
    ticketFrequency?: boolean
    workLocations?: boolean
    previousExperience?: boolean
    totalExperienceYears?: boolean
    preferredAge?: boolean
    languageRequirements?: boolean
    specialRequirements?: boolean
    assignedAgencyId?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    needsMoreLabour?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
    LabourAssignment?: boolean | JobRole$LabourAssignmentArgs<ExtArgs>
    forwardings?: boolean | JobRole$forwardingsArgs<ExtArgs>
    _count?: boolean | JobRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    startDate?: boolean
    contractDuration?: boolean
    salaryCurrency?: boolean
    basicSalary?: boolean
    foodAllowance?: boolean
    foodProvidedByCompany?: boolean
    housingAllowance?: boolean
    housingProvidedByCompany?: boolean
    transportationAllowance?: boolean
    transportationProvidedByCompany?: boolean
    healthInsurance?: boolean
    mobileAllowance?: boolean
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: boolean
    otherAllowance?: boolean
    ticketFrequency?: boolean
    workLocations?: boolean
    previousExperience?: boolean
    totalExperienceYears?: boolean
    preferredAge?: boolean
    languageRequirements?: boolean
    specialRequirements?: boolean
    assignedAgencyId?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    needsMoreLabour?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    startDate?: boolean
    contractDuration?: boolean
    salaryCurrency?: boolean
    basicSalary?: boolean
    foodAllowance?: boolean
    foodProvidedByCompany?: boolean
    housingAllowance?: boolean
    housingProvidedByCompany?: boolean
    transportationAllowance?: boolean
    transportationProvidedByCompany?: boolean
    healthInsurance?: boolean
    mobileAllowance?: boolean
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: boolean
    otherAllowance?: boolean
    ticketFrequency?: boolean
    workLocations?: boolean
    previousExperience?: boolean
    totalExperienceYears?: boolean
    preferredAge?: boolean
    languageRequirements?: boolean
    specialRequirements?: boolean
    assignedAgencyId?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    needsMoreLabour?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
  }, ExtArgs["result"]["jobRole"]>

  export type JobRoleSelectScalar = {
    id?: boolean
    requirementId?: boolean
    title?: boolean
    quantity?: boolean
    nationality?: boolean
    startDate?: boolean
    contractDuration?: boolean
    salaryCurrency?: boolean
    basicSalary?: boolean
    foodAllowance?: boolean
    foodProvidedByCompany?: boolean
    housingAllowance?: boolean
    housingProvidedByCompany?: boolean
    transportationAllowance?: boolean
    transportationProvidedByCompany?: boolean
    healthInsurance?: boolean
    mobileAllowance?: boolean
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: boolean
    otherAllowance?: boolean
    ticketFrequency?: boolean
    workLocations?: boolean
    previousExperience?: boolean
    totalExperienceYears?: boolean
    preferredAge?: boolean
    languageRequirements?: boolean
    specialRequirements?: boolean
    assignedAgencyId?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    needsMoreLabour?: boolean
  }

  export type JobRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requirementId" | "title" | "quantity" | "nationality" | "startDate" | "contractDuration" | "salaryCurrency" | "basicSalary" | "foodAllowance" | "foodProvidedByCompany" | "housingAllowance" | "housingProvidedByCompany" | "transportationAllowance" | "transportationProvidedByCompany" | "healthInsurance" | "mobileAllowance" | "mobileProvidedByCompany" | "natureOfWorkAllowance" | "otherAllowance" | "ticketFrequency" | "workLocations" | "previousExperience" | "totalExperienceYears" | "preferredAge" | "languageRequirements" | "specialRequirements" | "assignedAgencyId" | "agencyStatus" | "adminStatus" | "needsMoreLabour", ExtArgs["result"]["jobRole"]>
  export type JobRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
    LabourAssignment?: boolean | JobRole$LabourAssignmentArgs<ExtArgs>
    forwardings?: boolean | JobRole$forwardingsArgs<ExtArgs>
    _count?: boolean | JobRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
  }
  export type JobRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    assignedAgency?: boolean | JobRole$assignedAgencyArgs<ExtArgs>
  }

  export type $JobRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRole"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs>
      assignedAgency: Prisma.$AgencyPayload<ExtArgs> | null
      LabourAssignment: Prisma.$LabourAssignmentPayload<ExtArgs>[]
      forwardings: Prisma.$JobRoleForwardingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requirementId: string
      title: string
      quantity: number
      nationality: string
      startDate: Date
      contractDuration: $Enums.ContractDuration | null
      salaryCurrency: string | null
      basicSalary: number
      foodAllowance: number | null
      foodProvidedByCompany: boolean
      housingAllowance: number | null
      housingProvidedByCompany: boolean
      transportationAllowance: number | null
      transportationProvidedByCompany: boolean
      healthInsurance: string
      mobileAllowance: number | null
      mobileProvidedByCompany: boolean
      natureOfWorkAllowance: number | null
      otherAllowance: number | null
      ticketFrequency: string
      workLocations: string
      previousExperience: string
      totalExperienceYears: number | null
      preferredAge: number | null
      languageRequirements: string[]
      specialRequirements: string | null
      /**
       * Which agency (if any) this role has been forwarded to
       */
      assignedAgencyId: string | null
      /**
       * If forwarded, track agency's response status
       */
      agencyStatus: $Enums.RequirementStatus
      adminStatus: $Enums.RequirementStatus
      needsMoreLabour: boolean
    }, ExtArgs["result"]["jobRole"]>
    composites: {}
  }

  type JobRoleGetPayload<S extends boolean | null | undefined | JobRoleDefaultArgs> = $Result.GetResult<Prisma.$JobRolePayload, S>

  type JobRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRoleCountAggregateInputType | true
    }

  export interface JobRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRole'], meta: { name: 'JobRole' } }
    /**
     * Find zero or one JobRole that matches the filter.
     * @param {JobRoleFindUniqueArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRoleFindUniqueArgs>(args: SelectSubset<T, JobRoleFindUniqueArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRoleFindUniqueOrThrowArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindFirstArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRoleFindFirstArgs>(args?: SelectSubset<T, JobRoleFindFirstArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindFirstOrThrowArgs} args - Arguments to find a JobRole
     * @example
     * // Get one JobRole
     * const jobRole = await prisma.jobRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRoles
     * const jobRoles = await prisma.jobRole.findMany()
     * 
     * // Get first 10 JobRoles
     * const jobRoles = await prisma.jobRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobRoleFindManyArgs>(args?: SelectSubset<T, JobRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRole.
     * @param {JobRoleCreateArgs} args - Arguments to create a JobRole.
     * @example
     * // Create one JobRole
     * const JobRole = await prisma.jobRole.create({
     *   data: {
     *     // ... data to create a JobRole
     *   }
     * })
     * 
     */
    create<T extends JobRoleCreateArgs>(args: SelectSubset<T, JobRoleCreateArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRoles.
     * @param {JobRoleCreateManyArgs} args - Arguments to create many JobRoles.
     * @example
     * // Create many JobRoles
     * const jobRole = await prisma.jobRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRoleCreateManyArgs>(args?: SelectSubset<T, JobRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobRoles and returns the data saved in the database.
     * @param {JobRoleCreateManyAndReturnArgs} args - Arguments to create many JobRoles.
     * @example
     * // Create many JobRoles
     * const jobRole = await prisma.jobRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobRoles and only return the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, JobRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobRole.
     * @param {JobRoleDeleteArgs} args - Arguments to delete one JobRole.
     * @example
     * // Delete one JobRole
     * const JobRole = await prisma.jobRole.delete({
     *   where: {
     *     // ... filter to delete one JobRole
     *   }
     * })
     * 
     */
    delete<T extends JobRoleDeleteArgs>(args: SelectSubset<T, JobRoleDeleteArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRole.
     * @param {JobRoleUpdateArgs} args - Arguments to update one JobRole.
     * @example
     * // Update one JobRole
     * const jobRole = await prisma.jobRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRoleUpdateArgs>(args: SelectSubset<T, JobRoleUpdateArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRoles.
     * @param {JobRoleDeleteManyArgs} args - Arguments to filter JobRoles to delete.
     * @example
     * // Delete a few JobRoles
     * const { count } = await prisma.jobRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRoleDeleteManyArgs>(args?: SelectSubset<T, JobRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRoles
     * const jobRole = await prisma.jobRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRoleUpdateManyArgs>(args: SelectSubset<T, JobRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoles and returns the data updated in the database.
     * @param {JobRoleUpdateManyAndReturnArgs} args - Arguments to update many JobRoles.
     * @example
     * // Update many JobRoles
     * const jobRole = await prisma.jobRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobRoles and only return the `id`
     * const jobRoleWithIdOnly = await prisma.jobRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, JobRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobRole.
     * @param {JobRoleUpsertArgs} args - Arguments to update or create a JobRole.
     * @example
     * // Update or create a JobRole
     * const jobRole = await prisma.jobRole.upsert({
     *   create: {
     *     // ... data to create a JobRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRole we want to update
     *   }
     * })
     */
    upsert<T extends JobRoleUpsertArgs>(args: SelectSubset<T, JobRoleUpsertArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleCountArgs} args - Arguments to filter JobRoles to count.
     * @example
     * // Count the number of JobRoles
     * const count = await prisma.jobRole.count({
     *   where: {
     *     // ... the filter for the JobRoles we want to count
     *   }
     * })
    **/
    count<T extends JobRoleCountArgs>(
      args?: Subset<T, JobRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRoleAggregateArgs>(args: Subset<T, JobRoleAggregateArgs>): Prisma.PrismaPromise<GetJobRoleAggregateType<T>>

    /**
     * Group by JobRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRoleGroupByArgs['orderBy'] }
        : { orderBy?: JobRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRole model
   */
  readonly fields: JobRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedAgency<T extends JobRole$assignedAgencyArgs<ExtArgs> = {}>(args?: Subset<T, JobRole$assignedAgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    LabourAssignment<T extends JobRole$LabourAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, JobRole$LabourAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forwardings<T extends JobRole$forwardingsArgs<ExtArgs> = {}>(args?: Subset<T, JobRole$forwardingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRole model
   */
  interface JobRoleFieldRefs {
    readonly id: FieldRef<"JobRole", 'String'>
    readonly requirementId: FieldRef<"JobRole", 'String'>
    readonly title: FieldRef<"JobRole", 'String'>
    readonly quantity: FieldRef<"JobRole", 'Int'>
    readonly nationality: FieldRef<"JobRole", 'String'>
    readonly startDate: FieldRef<"JobRole", 'DateTime'>
    readonly contractDuration: FieldRef<"JobRole", 'ContractDuration'>
    readonly salaryCurrency: FieldRef<"JobRole", 'String'>
    readonly basicSalary: FieldRef<"JobRole", 'Float'>
    readonly foodAllowance: FieldRef<"JobRole", 'Float'>
    readonly foodProvidedByCompany: FieldRef<"JobRole", 'Boolean'>
    readonly housingAllowance: FieldRef<"JobRole", 'Float'>
    readonly housingProvidedByCompany: FieldRef<"JobRole", 'Boolean'>
    readonly transportationAllowance: FieldRef<"JobRole", 'Float'>
    readonly transportationProvidedByCompany: FieldRef<"JobRole", 'Boolean'>
    readonly healthInsurance: FieldRef<"JobRole", 'String'>
    readonly mobileAllowance: FieldRef<"JobRole", 'Float'>
    readonly mobileProvidedByCompany: FieldRef<"JobRole", 'Boolean'>
    readonly natureOfWorkAllowance: FieldRef<"JobRole", 'Float'>
    readonly otherAllowance: FieldRef<"JobRole", 'Float'>
    readonly ticketFrequency: FieldRef<"JobRole", 'String'>
    readonly workLocations: FieldRef<"JobRole", 'String'>
    readonly previousExperience: FieldRef<"JobRole", 'String'>
    readonly totalExperienceYears: FieldRef<"JobRole", 'Int'>
    readonly preferredAge: FieldRef<"JobRole", 'Int'>
    readonly languageRequirements: FieldRef<"JobRole", 'String[]'>
    readonly specialRequirements: FieldRef<"JobRole", 'String'>
    readonly assignedAgencyId: FieldRef<"JobRole", 'String'>
    readonly agencyStatus: FieldRef<"JobRole", 'RequirementStatus'>
    readonly adminStatus: FieldRef<"JobRole", 'RequirementStatus'>
    readonly needsMoreLabour: FieldRef<"JobRole", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * JobRole findUnique
   */
  export type JobRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole findUniqueOrThrow
   */
  export type JobRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole findFirst
   */
  export type JobRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoles.
     */
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole findFirstOrThrow
   */
  export type JobRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRole to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoles.
     */
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole findMany
   */
  export type JobRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter, which JobRoles to fetch.
     */
    where?: JobRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoles to fetch.
     */
    orderBy?: JobRoleOrderByWithRelationInput | JobRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRoles.
     */
    cursor?: JobRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoles.
     */
    skip?: number
    distinct?: JobRoleScalarFieldEnum | JobRoleScalarFieldEnum[]
  }

  /**
   * JobRole create
   */
  export type JobRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a JobRole.
     */
    data: XOR<JobRoleCreateInput, JobRoleUncheckedCreateInput>
  }

  /**
   * JobRole createMany
   */
  export type JobRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRoles.
     */
    data: JobRoleCreateManyInput | JobRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRole createManyAndReturn
   */
  export type JobRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * The data used to create many JobRoles.
     */
    data: JobRoleCreateManyInput | JobRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRole update
   */
  export type JobRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a JobRole.
     */
    data: XOR<JobRoleUpdateInput, JobRoleUncheckedUpdateInput>
    /**
     * Choose, which JobRole to update.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole updateMany
   */
  export type JobRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRoles.
     */
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyInput>
    /**
     * Filter which JobRoles to update
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to update.
     */
    limit?: number
  }

  /**
   * JobRole updateManyAndReturn
   */
  export type JobRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * The data used to update JobRoles.
     */
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyInput>
    /**
     * Filter which JobRoles to update
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRole upsert
   */
  export type JobRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the JobRole to update in case it exists.
     */
    where: JobRoleWhereUniqueInput
    /**
     * In case the JobRole found by the `where` argument doesn't exist, create a new JobRole with this data.
     */
    create: XOR<JobRoleCreateInput, JobRoleUncheckedCreateInput>
    /**
     * In case the JobRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRoleUpdateInput, JobRoleUncheckedUpdateInput>
  }

  /**
   * JobRole delete
   */
  export type JobRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
    /**
     * Filter which JobRole to delete.
     */
    where: JobRoleWhereUniqueInput
  }

  /**
   * JobRole deleteMany
   */
  export type JobRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRoles to delete
     */
    where?: JobRoleWhereInput
    /**
     * Limit how many JobRoles to delete.
     */
    limit?: number
  }

  /**
   * JobRole.assignedAgency
   */
  export type JobRole$assignedAgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * JobRole.LabourAssignment
   */
  export type JobRole$LabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    where?: LabourAssignmentWhereInput
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    cursor?: LabourAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * JobRole.forwardings
   */
  export type JobRole$forwardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    where?: JobRoleForwardingWhereInput
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    cursor?: JobRoleForwardingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRoleForwardingScalarFieldEnum | JobRoleForwardingScalarFieldEnum[]
  }

  /**
   * JobRole without action
   */
  export type JobRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRole
     */
    select?: JobRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRole
     */
    omit?: JobRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleInclude<ExtArgs> | null
  }


  /**
   * Model LabourProfile
   */

  export type AggregateLabourProfile = {
    _count: LabourProfileCountAggregateOutputType | null
    _avg: LabourProfileAvgAggregateOutputType | null
    _sum: LabourProfileSumAggregateOutputType | null
    _min: LabourProfileMinAggregateOutputType | null
    _max: LabourProfileMaxAggregateOutputType | null
  }

  export type LabourProfileAvgAggregateOutputType = {
    age: number | null
  }

  export type LabourProfileSumAggregateOutputType = {
    age: number | null
  }

  export type LabourProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    profileImage: string | null
    age: number | null
    gender: $Enums.Gender | null
    nationality: string | null
    email: string | null
    phone: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    passportVerified: boolean | null
    visaType: string | null
    visaExpiry: Date | null
    visaVerified: boolean | null
    medicalReport: string | null
    medicalVerified: boolean | null
    policeClearance: string | null
    policeVerified: boolean | null
    contractVerified: boolean | null
    status: $Enums.LabourProfileStatus | null
    verificationStatus: $Enums.DocumentVerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    documentsSubmittedAt: Date | null
    documentsVerifiedAt: Date | null
    jobRole: string | null
    experience: string | null
    education: string | null
    requirementId: string | null
    agencyId: string | null
    currentStage: $Enums.LabourStage | null
  }

  export type LabourProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    profileImage: string | null
    age: number | null
    gender: $Enums.Gender | null
    nationality: string | null
    email: string | null
    phone: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    passportVerified: boolean | null
    visaType: string | null
    visaExpiry: Date | null
    visaVerified: boolean | null
    medicalReport: string | null
    medicalVerified: boolean | null
    policeClearance: string | null
    policeVerified: boolean | null
    contractVerified: boolean | null
    status: $Enums.LabourProfileStatus | null
    verificationStatus: $Enums.DocumentVerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    documentsSubmittedAt: Date | null
    documentsVerifiedAt: Date | null
    jobRole: string | null
    experience: string | null
    education: string | null
    requirementId: string | null
    agencyId: string | null
    currentStage: $Enums.LabourStage | null
  }

  export type LabourProfileCountAggregateOutputType = {
    id: number
    name: number
    profileImage: number
    age: number
    gender: number
    nationality: number
    email: number
    phone: number
    passportNumber: number
    passportExpiry: number
    passportVerified: number
    visaType: number
    visaExpiry: number
    visaVerified: number
    medicalReport: number
    medicalVerified: number
    policeClearance: number
    policeVerified: number
    contractVerified: number
    status: number
    verificationStatus: number
    createdAt: number
    updatedAt: number
    documentsSubmittedAt: number
    documentsVerifiedAt: number
    jobRole: number
    skills: number
    experience: number
    education: number
    languages: number
    requirementId: number
    agencyId: number
    currentStage: number
    _all: number
  }


  export type LabourProfileAvgAggregateInputType = {
    age?: true
  }

  export type LabourProfileSumAggregateInputType = {
    age?: true
  }

  export type LabourProfileMinAggregateInputType = {
    id?: true
    name?: true
    profileImage?: true
    age?: true
    gender?: true
    nationality?: true
    email?: true
    phone?: true
    passportNumber?: true
    passportExpiry?: true
    passportVerified?: true
    visaType?: true
    visaExpiry?: true
    visaVerified?: true
    medicalReport?: true
    medicalVerified?: true
    policeClearance?: true
    policeVerified?: true
    contractVerified?: true
    status?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
    documentsSubmittedAt?: true
    documentsVerifiedAt?: true
    jobRole?: true
    experience?: true
    education?: true
    requirementId?: true
    agencyId?: true
    currentStage?: true
  }

  export type LabourProfileMaxAggregateInputType = {
    id?: true
    name?: true
    profileImage?: true
    age?: true
    gender?: true
    nationality?: true
    email?: true
    phone?: true
    passportNumber?: true
    passportExpiry?: true
    passportVerified?: true
    visaType?: true
    visaExpiry?: true
    visaVerified?: true
    medicalReport?: true
    medicalVerified?: true
    policeClearance?: true
    policeVerified?: true
    contractVerified?: true
    status?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
    documentsSubmittedAt?: true
    documentsVerifiedAt?: true
    jobRole?: true
    experience?: true
    education?: true
    requirementId?: true
    agencyId?: true
    currentStage?: true
  }

  export type LabourProfileCountAggregateInputType = {
    id?: true
    name?: true
    profileImage?: true
    age?: true
    gender?: true
    nationality?: true
    email?: true
    phone?: true
    passportNumber?: true
    passportExpiry?: true
    passportVerified?: true
    visaType?: true
    visaExpiry?: true
    visaVerified?: true
    medicalReport?: true
    medicalVerified?: true
    policeClearance?: true
    policeVerified?: true
    contractVerified?: true
    status?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
    documentsSubmittedAt?: true
    documentsVerifiedAt?: true
    jobRole?: true
    skills?: true
    experience?: true
    education?: true
    languages?: true
    requirementId?: true
    agencyId?: true
    currentStage?: true
    _all?: true
  }

  export type LabourProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourProfile to aggregate.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourProfiles
    **/
    _count?: true | LabourProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabourProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabourProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourProfileMaxAggregateInputType
  }

  export type GetLabourProfileAggregateType<T extends LabourProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourProfile[P]>
      : GetScalarType<T[P], AggregateLabourProfile[P]>
  }




  export type LabourProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithAggregationInput | LabourProfileOrderByWithAggregationInput[]
    by: LabourProfileScalarFieldEnum[] | LabourProfileScalarFieldEnum
    having?: LabourProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourProfileCountAggregateInputType | true
    _avg?: LabourProfileAvgAggregateInputType
    _sum?: LabourProfileSumAggregateInputType
    _min?: LabourProfileMinAggregateInputType
    _max?: LabourProfileMaxAggregateInputType
  }

  export type LabourProfileGroupByOutputType = {
    id: string
    name: string
    profileImage: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email: string | null
    phone: string | null
    passportNumber: string
    passportExpiry: Date
    passportVerified: boolean
    visaType: string | null
    visaExpiry: Date | null
    visaVerified: boolean
    medicalReport: string | null
    medicalVerified: boolean
    policeClearance: string | null
    policeVerified: boolean
    contractVerified: boolean
    status: $Enums.LabourProfileStatus
    verificationStatus: $Enums.DocumentVerificationStatus
    createdAt: Date
    updatedAt: Date
    documentsSubmittedAt: Date | null
    documentsVerifiedAt: Date | null
    jobRole: string | null
    skills: string[]
    experience: string | null
    education: string | null
    languages: string[]
    requirementId: string | null
    agencyId: string
    currentStage: $Enums.LabourStage
    _count: LabourProfileCountAggregateOutputType | null
    _avg: LabourProfileAvgAggregateOutputType | null
    _sum: LabourProfileSumAggregateOutputType | null
    _min: LabourProfileMinAggregateOutputType | null
    _max: LabourProfileMaxAggregateOutputType | null
  }

  type GetLabourProfileGroupByPayload<T extends LabourProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LabourProfileGroupByOutputType[P]>
        }
      >
    >


  export type LabourProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profileImage?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    email?: boolean
    phone?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportVerified?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    visaVerified?: boolean
    medicalReport?: boolean
    medicalVerified?: boolean
    policeClearance?: boolean
    policeVerified?: boolean
    contractVerified?: boolean
    status?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentsSubmittedAt?: boolean
    documentsVerifiedAt?: boolean
    jobRole?: boolean
    skills?: boolean
    experience?: boolean
    education?: boolean
    languages?: boolean
    requirementId?: boolean
    agencyId?: boolean
    currentStage?: boolean
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    stages?: boolean | LabourProfile$stagesArgs<ExtArgs>
    auditLogs?: boolean | LabourProfile$auditLogsArgs<ExtArgs>
    Document?: boolean | LabourProfile$DocumentArgs<ExtArgs>
    LabourAssignment?: boolean | LabourProfile$LabourAssignmentArgs<ExtArgs>
    _count?: boolean | LabourProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profileImage?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    email?: boolean
    phone?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportVerified?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    visaVerified?: boolean
    medicalReport?: boolean
    medicalVerified?: boolean
    policeClearance?: boolean
    policeVerified?: boolean
    contractVerified?: boolean
    status?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentsSubmittedAt?: boolean
    documentsVerifiedAt?: boolean
    jobRole?: boolean
    skills?: boolean
    experience?: boolean
    education?: boolean
    languages?: boolean
    requirementId?: boolean
    agencyId?: boolean
    currentStage?: boolean
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    profileImage?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    email?: boolean
    phone?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportVerified?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    visaVerified?: boolean
    medicalReport?: boolean
    medicalVerified?: boolean
    policeClearance?: boolean
    policeVerified?: boolean
    contractVerified?: boolean
    status?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentsSubmittedAt?: boolean
    documentsVerifiedAt?: boolean
    jobRole?: boolean
    skills?: boolean
    experience?: boolean
    education?: boolean
    languages?: boolean
    requirementId?: boolean
    agencyId?: boolean
    currentStage?: boolean
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourProfile"]>

  export type LabourProfileSelectScalar = {
    id?: boolean
    name?: boolean
    profileImage?: boolean
    age?: boolean
    gender?: boolean
    nationality?: boolean
    email?: boolean
    phone?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportVerified?: boolean
    visaType?: boolean
    visaExpiry?: boolean
    visaVerified?: boolean
    medicalReport?: boolean
    medicalVerified?: boolean
    policeClearance?: boolean
    policeVerified?: boolean
    contractVerified?: boolean
    status?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentsSubmittedAt?: boolean
    documentsVerifiedAt?: boolean
    jobRole?: boolean
    skills?: boolean
    experience?: boolean
    education?: boolean
    languages?: boolean
    requirementId?: boolean
    agencyId?: boolean
    currentStage?: boolean
  }

  export type LabourProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "profileImage" | "age" | "gender" | "nationality" | "email" | "phone" | "passportNumber" | "passportExpiry" | "passportVerified" | "visaType" | "visaExpiry" | "visaVerified" | "medicalReport" | "medicalVerified" | "policeClearance" | "policeVerified" | "contractVerified" | "status" | "verificationStatus" | "createdAt" | "updatedAt" | "documentsSubmittedAt" | "documentsVerifiedAt" | "jobRole" | "skills" | "experience" | "education" | "languages" | "requirementId" | "agencyId" | "currentStage", ExtArgs["result"]["labourProfile"]>
  export type LabourProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    stages?: boolean | LabourProfile$stagesArgs<ExtArgs>
    auditLogs?: boolean | LabourProfile$auditLogsArgs<ExtArgs>
    Document?: boolean | LabourProfile$DocumentArgs<ExtArgs>
    LabourAssignment?: boolean | LabourProfile$LabourAssignmentArgs<ExtArgs>
    _count?: boolean | LabourProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabourProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type LabourProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | LabourProfile$requirementArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $LabourProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourProfile"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs> | null
      agency: Prisma.$AgencyPayload<ExtArgs>
      stages: Prisma.$LabourStageHistoryPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      Document: Prisma.$DocumentPayload<ExtArgs>[]
      LabourAssignment: Prisma.$LabourAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      profileImage: string | null
      age: number
      gender: $Enums.Gender
      nationality: string
      email: string | null
      phone: string | null
      passportNumber: string
      passportExpiry: Date
      passportVerified: boolean
      visaType: string | null
      visaExpiry: Date | null
      visaVerified: boolean
      medicalReport: string | null
      medicalVerified: boolean
      policeClearance: string | null
      policeVerified: boolean
      contractVerified: boolean
      status: $Enums.LabourProfileStatus
      verificationStatus: $Enums.DocumentVerificationStatus
      createdAt: Date
      updatedAt: Date
      documentsSubmittedAt: Date | null
      documentsVerifiedAt: Date | null
      jobRole: string | null
      skills: string[]
      experience: string | null
      education: string | null
      languages: string[]
      requirementId: string | null
      agencyId: string
      currentStage: $Enums.LabourStage
    }, ExtArgs["result"]["labourProfile"]>
    composites: {}
  }

  type LabourProfileGetPayload<S extends boolean | null | undefined | LabourProfileDefaultArgs> = $Result.GetResult<Prisma.$LabourProfilePayload, S>

  type LabourProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourProfileCountAggregateInputType | true
    }

  export interface LabourProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourProfile'], meta: { name: 'LabourProfile' } }
    /**
     * Find zero or one LabourProfile that matches the filter.
     * @param {LabourProfileFindUniqueArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourProfileFindUniqueArgs>(args: SelectSubset<T, LabourProfileFindUniqueArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourProfileFindUniqueOrThrowArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindFirstArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourProfileFindFirstArgs>(args?: SelectSubset<T, LabourProfileFindFirstArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindFirstOrThrowArgs} args - Arguments to find a LabourProfile
     * @example
     * // Get one LabourProfile
     * const labourProfile = await prisma.labourProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourProfiles
     * const labourProfiles = await prisma.labourProfile.findMany()
     * 
     * // Get first 10 LabourProfiles
     * const labourProfiles = await prisma.labourProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourProfileFindManyArgs>(args?: SelectSubset<T, LabourProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourProfile.
     * @param {LabourProfileCreateArgs} args - Arguments to create a LabourProfile.
     * @example
     * // Create one LabourProfile
     * const LabourProfile = await prisma.labourProfile.create({
     *   data: {
     *     // ... data to create a LabourProfile
     *   }
     * })
     * 
     */
    create<T extends LabourProfileCreateArgs>(args: SelectSubset<T, LabourProfileCreateArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourProfiles.
     * @param {LabourProfileCreateManyArgs} args - Arguments to create many LabourProfiles.
     * @example
     * // Create many LabourProfiles
     * const labourProfile = await prisma.labourProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourProfileCreateManyArgs>(args?: SelectSubset<T, LabourProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourProfiles and returns the data saved in the database.
     * @param {LabourProfileCreateManyAndReturnArgs} args - Arguments to create many LabourProfiles.
     * @example
     * // Create many LabourProfiles
     * const labourProfile = await prisma.labourProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourProfiles and only return the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourProfile.
     * @param {LabourProfileDeleteArgs} args - Arguments to delete one LabourProfile.
     * @example
     * // Delete one LabourProfile
     * const LabourProfile = await prisma.labourProfile.delete({
     *   where: {
     *     // ... filter to delete one LabourProfile
     *   }
     * })
     * 
     */
    delete<T extends LabourProfileDeleteArgs>(args: SelectSubset<T, LabourProfileDeleteArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourProfile.
     * @param {LabourProfileUpdateArgs} args - Arguments to update one LabourProfile.
     * @example
     * // Update one LabourProfile
     * const labourProfile = await prisma.labourProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourProfileUpdateArgs>(args: SelectSubset<T, LabourProfileUpdateArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourProfiles.
     * @param {LabourProfileDeleteManyArgs} args - Arguments to filter LabourProfiles to delete.
     * @example
     * // Delete a few LabourProfiles
     * const { count } = await prisma.labourProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourProfileDeleteManyArgs>(args?: SelectSubset<T, LabourProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourProfiles
     * const labourProfile = await prisma.labourProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourProfileUpdateManyArgs>(args: SelectSubset<T, LabourProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourProfiles and returns the data updated in the database.
     * @param {LabourProfileUpdateManyAndReturnArgs} args - Arguments to update many LabourProfiles.
     * @example
     * // Update many LabourProfiles
     * const labourProfile = await prisma.labourProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourProfiles and only return the `id`
     * const labourProfileWithIdOnly = await prisma.labourProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourProfile.
     * @param {LabourProfileUpsertArgs} args - Arguments to update or create a LabourProfile.
     * @example
     * // Update or create a LabourProfile
     * const labourProfile = await prisma.labourProfile.upsert({
     *   create: {
     *     // ... data to create a LabourProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourProfile we want to update
     *   }
     * })
     */
    upsert<T extends LabourProfileUpsertArgs>(args: SelectSubset<T, LabourProfileUpsertArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileCountArgs} args - Arguments to filter LabourProfiles to count.
     * @example
     * // Count the number of LabourProfiles
     * const count = await prisma.labourProfile.count({
     *   where: {
     *     // ... the filter for the LabourProfiles we want to count
     *   }
     * })
    **/
    count<T extends LabourProfileCountArgs>(
      args?: Subset<T, LabourProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourProfileAggregateArgs>(args: Subset<T, LabourProfileAggregateArgs>): Prisma.PrismaPromise<GetLabourProfileAggregateType<T>>

    /**
     * Group by LabourProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourProfileGroupByArgs['orderBy'] }
        : { orderBy?: LabourProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourProfile model
   */
  readonly fields: LabourProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends LabourProfile$requirementArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$requirementArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stages<T extends LabourProfile$stagesArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends LabourProfile$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Document<T extends LabourProfile$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LabourAssignment<T extends LabourProfile$LabourAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfile$LabourAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourProfile model
   */
  interface LabourProfileFieldRefs {
    readonly id: FieldRef<"LabourProfile", 'String'>
    readonly name: FieldRef<"LabourProfile", 'String'>
    readonly profileImage: FieldRef<"LabourProfile", 'String'>
    readonly age: FieldRef<"LabourProfile", 'Int'>
    readonly gender: FieldRef<"LabourProfile", 'Gender'>
    readonly nationality: FieldRef<"LabourProfile", 'String'>
    readonly email: FieldRef<"LabourProfile", 'String'>
    readonly phone: FieldRef<"LabourProfile", 'String'>
    readonly passportNumber: FieldRef<"LabourProfile", 'String'>
    readonly passportExpiry: FieldRef<"LabourProfile", 'DateTime'>
    readonly passportVerified: FieldRef<"LabourProfile", 'Boolean'>
    readonly visaType: FieldRef<"LabourProfile", 'String'>
    readonly visaExpiry: FieldRef<"LabourProfile", 'DateTime'>
    readonly visaVerified: FieldRef<"LabourProfile", 'Boolean'>
    readonly medicalReport: FieldRef<"LabourProfile", 'String'>
    readonly medicalVerified: FieldRef<"LabourProfile", 'Boolean'>
    readonly policeClearance: FieldRef<"LabourProfile", 'String'>
    readonly policeVerified: FieldRef<"LabourProfile", 'Boolean'>
    readonly contractVerified: FieldRef<"LabourProfile", 'Boolean'>
    readonly status: FieldRef<"LabourProfile", 'LabourProfileStatus'>
    readonly verificationStatus: FieldRef<"LabourProfile", 'DocumentVerificationStatus'>
    readonly createdAt: FieldRef<"LabourProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LabourProfile", 'DateTime'>
    readonly documentsSubmittedAt: FieldRef<"LabourProfile", 'DateTime'>
    readonly documentsVerifiedAt: FieldRef<"LabourProfile", 'DateTime'>
    readonly jobRole: FieldRef<"LabourProfile", 'String'>
    readonly skills: FieldRef<"LabourProfile", 'String[]'>
    readonly experience: FieldRef<"LabourProfile", 'String'>
    readonly education: FieldRef<"LabourProfile", 'String'>
    readonly languages: FieldRef<"LabourProfile", 'String[]'>
    readonly requirementId: FieldRef<"LabourProfile", 'String'>
    readonly agencyId: FieldRef<"LabourProfile", 'String'>
    readonly currentStage: FieldRef<"LabourProfile", 'LabourStage'>
  }
    

  // Custom InputTypes
  /**
   * LabourProfile findUnique
   */
  export type LabourProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile findUniqueOrThrow
   */
  export type LabourProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile findFirst
   */
  export type LabourProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourProfiles.
     */
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile findFirstOrThrow
   */
  export type LabourProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfile to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourProfiles.
     */
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile findMany
   */
  export type LabourProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabourProfiles to fetch.
     */
    where?: LabourProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourProfiles to fetch.
     */
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourProfiles.
     */
    cursor?: LabourProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourProfiles.
     */
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * LabourProfile create
   */
  export type LabourProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourProfile.
     */
    data: XOR<LabourProfileCreateInput, LabourProfileUncheckedCreateInput>
  }

  /**
   * LabourProfile createMany
   */
  export type LabourProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourProfiles.
     */
    data: LabourProfileCreateManyInput | LabourProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourProfile createManyAndReturn
   */
  export type LabourProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LabourProfiles.
     */
    data: LabourProfileCreateManyInput | LabourProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourProfile update
   */
  export type LabourProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourProfile.
     */
    data: XOR<LabourProfileUpdateInput, LabourProfileUncheckedUpdateInput>
    /**
     * Choose, which LabourProfile to update.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile updateMany
   */
  export type LabourProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourProfiles.
     */
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabourProfiles to update
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to update.
     */
    limit?: number
  }

  /**
   * LabourProfile updateManyAndReturn
   */
  export type LabourProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * The data used to update LabourProfiles.
     */
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabourProfiles to update
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourProfile upsert
   */
  export type LabourProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourProfile to update in case it exists.
     */
    where: LabourProfileWhereUniqueInput
    /**
     * In case the LabourProfile found by the `where` argument doesn't exist, create a new LabourProfile with this data.
     */
    create: XOR<LabourProfileCreateInput, LabourProfileUncheckedCreateInput>
    /**
     * In case the LabourProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourProfileUpdateInput, LabourProfileUncheckedUpdateInput>
  }

  /**
   * LabourProfile delete
   */
  export type LabourProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    /**
     * Filter which LabourProfile to delete.
     */
    where: LabourProfileWhereUniqueInput
  }

  /**
   * LabourProfile deleteMany
   */
  export type LabourProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourProfiles to delete
     */
    where?: LabourProfileWhereInput
    /**
     * Limit how many LabourProfiles to delete.
     */
    limit?: number
  }

  /**
   * LabourProfile.requirement
   */
  export type LabourProfile$requirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
  }

  /**
   * LabourProfile.stages
   */
  export type LabourProfile$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    where?: LabourStageHistoryWhereInput
    orderBy?: LabourStageHistoryOrderByWithRelationInput | LabourStageHistoryOrderByWithRelationInput[]
    cursor?: LabourStageHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourStageHistoryScalarFieldEnum | LabourStageHistoryScalarFieldEnum[]
  }

  /**
   * LabourProfile.auditLogs
   */
  export type LabourProfile$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * LabourProfile.Document
   */
  export type LabourProfile$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * LabourProfile.LabourAssignment
   */
  export type LabourProfile$LabourAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    where?: LabourAssignmentWhereInput
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    cursor?: LabourAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * LabourProfile without action
   */
  export type LabourProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
  }


  /**
   * Model LabourAssignment
   */

  export type AggregateLabourAssignment = {
    _count: LabourAssignmentCountAggregateOutputType | null
    _min: LabourAssignmentMinAggregateOutputType | null
    _max: LabourAssignmentMaxAggregateOutputType | null
  }

  export type LabourAssignmentMinAggregateOutputType = {
    id: string | null
    jobRoleId: string | null
    agencyId: string | null
    labourId: string | null
    isBackup: boolean | null
    agencyStatus: $Enums.RequirementStatus | null
    adminStatus: $Enums.RequirementStatus | null
    clientStatus: $Enums.RequirementStatus | null
    adminFeedback: string | null
    clientFeedback: string | null
    signedOfferLetterUrl: string | null
    visaUrl: string | null
    travelDate: Date | null
    flightTicketUrl: string | null
    medicalCertificateUrl: string | null
    policeClearanceUrl: string | null
    employmentContractUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabourAssignmentMaxAggregateOutputType = {
    id: string | null
    jobRoleId: string | null
    agencyId: string | null
    labourId: string | null
    isBackup: boolean | null
    agencyStatus: $Enums.RequirementStatus | null
    adminStatus: $Enums.RequirementStatus | null
    clientStatus: $Enums.RequirementStatus | null
    adminFeedback: string | null
    clientFeedback: string | null
    signedOfferLetterUrl: string | null
    visaUrl: string | null
    travelDate: Date | null
    flightTicketUrl: string | null
    medicalCertificateUrl: string | null
    policeClearanceUrl: string | null
    employmentContractUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabourAssignmentCountAggregateOutputType = {
    id: number
    jobRoleId: number
    agencyId: number
    labourId: number
    isBackup: number
    agencyStatus: number
    adminStatus: number
    clientStatus: number
    adminFeedback: number
    clientFeedback: number
    signedOfferLetterUrl: number
    visaUrl: number
    travelDate: number
    flightTicketUrl: number
    medicalCertificateUrl: number
    policeClearanceUrl: number
    employmentContractUrl: number
    additionalDocumentsUrls: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabourAssignmentMinAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    labourId?: true
    isBackup?: true
    agencyStatus?: true
    adminStatus?: true
    clientStatus?: true
    adminFeedback?: true
    clientFeedback?: true
    signedOfferLetterUrl?: true
    visaUrl?: true
    travelDate?: true
    flightTicketUrl?: true
    medicalCertificateUrl?: true
    policeClearanceUrl?: true
    employmentContractUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabourAssignmentMaxAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    labourId?: true
    isBackup?: true
    agencyStatus?: true
    adminStatus?: true
    clientStatus?: true
    adminFeedback?: true
    clientFeedback?: true
    signedOfferLetterUrl?: true
    visaUrl?: true
    travelDate?: true
    flightTicketUrl?: true
    medicalCertificateUrl?: true
    policeClearanceUrl?: true
    employmentContractUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabourAssignmentCountAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    labourId?: true
    isBackup?: true
    agencyStatus?: true
    adminStatus?: true
    clientStatus?: true
    adminFeedback?: true
    clientFeedback?: true
    signedOfferLetterUrl?: true
    visaUrl?: true
    travelDate?: true
    flightTicketUrl?: true
    medicalCertificateUrl?: true
    policeClearanceUrl?: true
    employmentContractUrl?: true
    additionalDocumentsUrls?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabourAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourAssignment to aggregate.
     */
    where?: LabourAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAssignments to fetch.
     */
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourAssignments
    **/
    _count?: true | LabourAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourAssignmentMaxAggregateInputType
  }

  export type GetLabourAssignmentAggregateType<T extends LabourAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourAssignment[P]>
      : GetScalarType<T[P], AggregateLabourAssignment[P]>
  }




  export type LabourAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAssignmentWhereInput
    orderBy?: LabourAssignmentOrderByWithAggregationInput | LabourAssignmentOrderByWithAggregationInput[]
    by: LabourAssignmentScalarFieldEnum[] | LabourAssignmentScalarFieldEnum
    having?: LabourAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourAssignmentCountAggregateInputType | true
    _min?: LabourAssignmentMinAggregateInputType
    _max?: LabourAssignmentMaxAggregateInputType
  }

  export type LabourAssignmentGroupByOutputType = {
    id: string
    jobRoleId: string
    agencyId: string
    labourId: string
    isBackup: boolean
    agencyStatus: $Enums.RequirementStatus
    adminStatus: $Enums.RequirementStatus
    clientStatus: $Enums.RequirementStatus
    adminFeedback: string | null
    clientFeedback: string | null
    signedOfferLetterUrl: string | null
    visaUrl: string | null
    travelDate: Date | null
    flightTicketUrl: string | null
    medicalCertificateUrl: string | null
    policeClearanceUrl: string | null
    employmentContractUrl: string | null
    additionalDocumentsUrls: string[]
    createdAt: Date
    updatedAt: Date
    _count: LabourAssignmentCountAggregateOutputType | null
    _min: LabourAssignmentMinAggregateOutputType | null
    _max: LabourAssignmentMaxAggregateOutputType | null
  }

  type GetLabourAssignmentGroupByPayload<T extends LabourAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], LabourAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type LabourAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    labourId?: boolean
    isBackup?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    clientStatus?: boolean
    adminFeedback?: boolean
    clientFeedback?: boolean
    signedOfferLetterUrl?: boolean
    visaUrl?: boolean
    travelDate?: boolean
    flightTicketUrl?: boolean
    medicalCertificateUrl?: boolean
    policeClearanceUrl?: boolean
    employmentContractUrl?: boolean
    additionalDocumentsUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAssignment"]>

  export type LabourAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    labourId?: boolean
    isBackup?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    clientStatus?: boolean
    adminFeedback?: boolean
    clientFeedback?: boolean
    signedOfferLetterUrl?: boolean
    visaUrl?: boolean
    travelDate?: boolean
    flightTicketUrl?: boolean
    medicalCertificateUrl?: boolean
    policeClearanceUrl?: boolean
    employmentContractUrl?: boolean
    additionalDocumentsUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAssignment"]>

  export type LabourAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    labourId?: boolean
    isBackup?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    clientStatus?: boolean
    adminFeedback?: boolean
    clientFeedback?: boolean
    signedOfferLetterUrl?: boolean
    visaUrl?: boolean
    travelDate?: boolean
    flightTicketUrl?: boolean
    medicalCertificateUrl?: boolean
    policeClearanceUrl?: boolean
    employmentContractUrl?: boolean
    additionalDocumentsUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAssignment"]>

  export type LabourAssignmentSelectScalar = {
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    labourId?: boolean
    isBackup?: boolean
    agencyStatus?: boolean
    adminStatus?: boolean
    clientStatus?: boolean
    adminFeedback?: boolean
    clientFeedback?: boolean
    signedOfferLetterUrl?: boolean
    visaUrl?: boolean
    travelDate?: boolean
    flightTicketUrl?: boolean
    medicalCertificateUrl?: boolean
    policeClearanceUrl?: boolean
    employmentContractUrl?: boolean
    additionalDocumentsUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabourAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobRoleId" | "agencyId" | "labourId" | "isBackup" | "agencyStatus" | "adminStatus" | "clientStatus" | "adminFeedback" | "clientFeedback" | "signedOfferLetterUrl" | "visaUrl" | "travelDate" | "flightTicketUrl" | "medicalCertificateUrl" | "policeClearanceUrl" | "employmentContractUrl" | "additionalDocumentsUrls" | "createdAt" | "updatedAt", ExtArgs["result"]["labourAssignment"]>
  export type LabourAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }
  export type LabourAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }
  export type LabourAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }

  export type $LabourAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourAssignment"
    objects: {
      jobRole: Prisma.$JobRolePayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      labour: Prisma.$LabourProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobRoleId: string
      agencyId: string
      labourId: string
      isBackup: boolean
      agencyStatus: $Enums.RequirementStatus
      adminStatus: $Enums.RequirementStatus
      clientStatus: $Enums.RequirementStatus
      adminFeedback: string | null
      clientFeedback: string | null
      signedOfferLetterUrl: string | null
      visaUrl: string | null
      travelDate: Date | null
      flightTicketUrl: string | null
      medicalCertificateUrl: string | null
      policeClearanceUrl: string | null
      employmentContractUrl: string | null
      additionalDocumentsUrls: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labourAssignment"]>
    composites: {}
  }

  type LabourAssignmentGetPayload<S extends boolean | null | undefined | LabourAssignmentDefaultArgs> = $Result.GetResult<Prisma.$LabourAssignmentPayload, S>

  type LabourAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourAssignmentCountAggregateInputType | true
    }

  export interface LabourAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourAssignment'], meta: { name: 'LabourAssignment' } }
    /**
     * Find zero or one LabourAssignment that matches the filter.
     * @param {LabourAssignmentFindUniqueArgs} args - Arguments to find a LabourAssignment
     * @example
     * // Get one LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourAssignmentFindUniqueArgs>(args: SelectSubset<T, LabourAssignmentFindUniqueArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourAssignmentFindUniqueOrThrowArgs} args - Arguments to find a LabourAssignment
     * @example
     * // Get one LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentFindFirstArgs} args - Arguments to find a LabourAssignment
     * @example
     * // Get one LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourAssignmentFindFirstArgs>(args?: SelectSubset<T, LabourAssignmentFindFirstArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentFindFirstOrThrowArgs} args - Arguments to find a LabourAssignment
     * @example
     * // Get one LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourAssignments
     * const labourAssignments = await prisma.labourAssignment.findMany()
     * 
     * // Get first 10 LabourAssignments
     * const labourAssignments = await prisma.labourAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourAssignmentWithIdOnly = await prisma.labourAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourAssignmentFindManyArgs>(args?: SelectSubset<T, LabourAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourAssignment.
     * @param {LabourAssignmentCreateArgs} args - Arguments to create a LabourAssignment.
     * @example
     * // Create one LabourAssignment
     * const LabourAssignment = await prisma.labourAssignment.create({
     *   data: {
     *     // ... data to create a LabourAssignment
     *   }
     * })
     * 
     */
    create<T extends LabourAssignmentCreateArgs>(args: SelectSubset<T, LabourAssignmentCreateArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourAssignments.
     * @param {LabourAssignmentCreateManyArgs} args - Arguments to create many LabourAssignments.
     * @example
     * // Create many LabourAssignments
     * const labourAssignment = await prisma.labourAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourAssignmentCreateManyArgs>(args?: SelectSubset<T, LabourAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourAssignments and returns the data saved in the database.
     * @param {LabourAssignmentCreateManyAndReturnArgs} args - Arguments to create many LabourAssignments.
     * @example
     * // Create many LabourAssignments
     * const labourAssignment = await prisma.labourAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourAssignments and only return the `id`
     * const labourAssignmentWithIdOnly = await prisma.labourAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourAssignment.
     * @param {LabourAssignmentDeleteArgs} args - Arguments to delete one LabourAssignment.
     * @example
     * // Delete one LabourAssignment
     * const LabourAssignment = await prisma.labourAssignment.delete({
     *   where: {
     *     // ... filter to delete one LabourAssignment
     *   }
     * })
     * 
     */
    delete<T extends LabourAssignmentDeleteArgs>(args: SelectSubset<T, LabourAssignmentDeleteArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourAssignment.
     * @param {LabourAssignmentUpdateArgs} args - Arguments to update one LabourAssignment.
     * @example
     * // Update one LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourAssignmentUpdateArgs>(args: SelectSubset<T, LabourAssignmentUpdateArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourAssignments.
     * @param {LabourAssignmentDeleteManyArgs} args - Arguments to filter LabourAssignments to delete.
     * @example
     * // Delete a few LabourAssignments
     * const { count } = await prisma.labourAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourAssignmentDeleteManyArgs>(args?: SelectSubset<T, LabourAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourAssignments
     * const labourAssignment = await prisma.labourAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourAssignmentUpdateManyArgs>(args: SelectSubset<T, LabourAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourAssignments and returns the data updated in the database.
     * @param {LabourAssignmentUpdateManyAndReturnArgs} args - Arguments to update many LabourAssignments.
     * @example
     * // Update many LabourAssignments
     * const labourAssignment = await prisma.labourAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourAssignments and only return the `id`
     * const labourAssignmentWithIdOnly = await prisma.labourAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourAssignment.
     * @param {LabourAssignmentUpsertArgs} args - Arguments to update or create a LabourAssignment.
     * @example
     * // Update or create a LabourAssignment
     * const labourAssignment = await prisma.labourAssignment.upsert({
     *   create: {
     *     // ... data to create a LabourAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourAssignment we want to update
     *   }
     * })
     */
    upsert<T extends LabourAssignmentUpsertArgs>(args: SelectSubset<T, LabourAssignmentUpsertArgs<ExtArgs>>): Prisma__LabourAssignmentClient<$Result.GetResult<Prisma.$LabourAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentCountArgs} args - Arguments to filter LabourAssignments to count.
     * @example
     * // Count the number of LabourAssignments
     * const count = await prisma.labourAssignment.count({
     *   where: {
     *     // ... the filter for the LabourAssignments we want to count
     *   }
     * })
    **/
    count<T extends LabourAssignmentCountArgs>(
      args?: Subset<T, LabourAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourAssignmentAggregateArgs>(args: Subset<T, LabourAssignmentAggregateArgs>): Prisma.PrismaPromise<GetLabourAssignmentAggregateType<T>>

    /**
     * Group by LabourAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: LabourAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourAssignment model
   */
  readonly fields: LabourAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobRole<T extends JobRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobRoleDefaultArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labour<T extends LabourProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfileDefaultArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourAssignment model
   */
  interface LabourAssignmentFieldRefs {
    readonly id: FieldRef<"LabourAssignment", 'String'>
    readonly jobRoleId: FieldRef<"LabourAssignment", 'String'>
    readonly agencyId: FieldRef<"LabourAssignment", 'String'>
    readonly labourId: FieldRef<"LabourAssignment", 'String'>
    readonly isBackup: FieldRef<"LabourAssignment", 'Boolean'>
    readonly agencyStatus: FieldRef<"LabourAssignment", 'RequirementStatus'>
    readonly adminStatus: FieldRef<"LabourAssignment", 'RequirementStatus'>
    readonly clientStatus: FieldRef<"LabourAssignment", 'RequirementStatus'>
    readonly adminFeedback: FieldRef<"LabourAssignment", 'String'>
    readonly clientFeedback: FieldRef<"LabourAssignment", 'String'>
    readonly signedOfferLetterUrl: FieldRef<"LabourAssignment", 'String'>
    readonly visaUrl: FieldRef<"LabourAssignment", 'String'>
    readonly travelDate: FieldRef<"LabourAssignment", 'DateTime'>
    readonly flightTicketUrl: FieldRef<"LabourAssignment", 'String'>
    readonly medicalCertificateUrl: FieldRef<"LabourAssignment", 'String'>
    readonly policeClearanceUrl: FieldRef<"LabourAssignment", 'String'>
    readonly employmentContractUrl: FieldRef<"LabourAssignment", 'String'>
    readonly additionalDocumentsUrls: FieldRef<"LabourAssignment", 'String[]'>
    readonly createdAt: FieldRef<"LabourAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"LabourAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabourAssignment findUnique
   */
  export type LabourAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which LabourAssignment to fetch.
     */
    where: LabourAssignmentWhereUniqueInput
  }

  /**
   * LabourAssignment findUniqueOrThrow
   */
  export type LabourAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which LabourAssignment to fetch.
     */
    where: LabourAssignmentWhereUniqueInput
  }

  /**
   * LabourAssignment findFirst
   */
  export type LabourAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which LabourAssignment to fetch.
     */
    where?: LabourAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAssignments to fetch.
     */
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourAssignments.
     */
    cursor?: LabourAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourAssignments.
     */
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * LabourAssignment findFirstOrThrow
   */
  export type LabourAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which LabourAssignment to fetch.
     */
    where?: LabourAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAssignments to fetch.
     */
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourAssignments.
     */
    cursor?: LabourAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourAssignments.
     */
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * LabourAssignment findMany
   */
  export type LabourAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which LabourAssignments to fetch.
     */
    where?: LabourAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAssignments to fetch.
     */
    orderBy?: LabourAssignmentOrderByWithRelationInput | LabourAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourAssignments.
     */
    cursor?: LabourAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAssignments.
     */
    skip?: number
    distinct?: LabourAssignmentScalarFieldEnum | LabourAssignmentScalarFieldEnum[]
  }

  /**
   * LabourAssignment create
   */
  export type LabourAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourAssignment.
     */
    data: XOR<LabourAssignmentCreateInput, LabourAssignmentUncheckedCreateInput>
  }

  /**
   * LabourAssignment createMany
   */
  export type LabourAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourAssignments.
     */
    data: LabourAssignmentCreateManyInput | LabourAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourAssignment createManyAndReturn
   */
  export type LabourAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many LabourAssignments.
     */
    data: LabourAssignmentCreateManyInput | LabourAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourAssignment update
   */
  export type LabourAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourAssignment.
     */
    data: XOR<LabourAssignmentUpdateInput, LabourAssignmentUncheckedUpdateInput>
    /**
     * Choose, which LabourAssignment to update.
     */
    where: LabourAssignmentWhereUniqueInput
  }

  /**
   * LabourAssignment updateMany
   */
  export type LabourAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourAssignments.
     */
    data: XOR<LabourAssignmentUpdateManyMutationInput, LabourAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which LabourAssignments to update
     */
    where?: LabourAssignmentWhereInput
    /**
     * Limit how many LabourAssignments to update.
     */
    limit?: number
  }

  /**
   * LabourAssignment updateManyAndReturn
   */
  export type LabourAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update LabourAssignments.
     */
    data: XOR<LabourAssignmentUpdateManyMutationInput, LabourAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which LabourAssignments to update
     */
    where?: LabourAssignmentWhereInput
    /**
     * Limit how many LabourAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourAssignment upsert
   */
  export type LabourAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourAssignment to update in case it exists.
     */
    where: LabourAssignmentWhereUniqueInput
    /**
     * In case the LabourAssignment found by the `where` argument doesn't exist, create a new LabourAssignment with this data.
     */
    create: XOR<LabourAssignmentCreateInput, LabourAssignmentUncheckedCreateInput>
    /**
     * In case the LabourAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourAssignmentUpdateInput, LabourAssignmentUncheckedUpdateInput>
  }

  /**
   * LabourAssignment delete
   */
  export type LabourAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
    /**
     * Filter which LabourAssignment to delete.
     */
    where: LabourAssignmentWhereUniqueInput
  }

  /**
   * LabourAssignment deleteMany
   */
  export type LabourAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourAssignments to delete
     */
    where?: LabourAssignmentWhereInput
    /**
     * Limit how many LabourAssignments to delete.
     */
    limit?: number
  }

  /**
   * LabourAssignment without action
   */
  export type LabourAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAssignment
     */
    select?: LabourAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAssignment
     */
    omit?: LabourAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model LabourStageHistory
   */

  export type AggregateLabourStageHistory = {
    _count: LabourStageHistoryCountAggregateOutputType | null
    _min: LabourStageHistoryMinAggregateOutputType | null
    _max: LabourStageHistoryMaxAggregateOutputType | null
  }

  export type LabourStageHistoryMinAggregateOutputType = {
    id: string | null
    labourId: string | null
    stage: $Enums.LabourStage | null
    status: $Enums.StageStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type LabourStageHistoryMaxAggregateOutputType = {
    id: string | null
    labourId: string | null
    stage: $Enums.LabourStage | null
    status: $Enums.StageStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type LabourStageHistoryCountAggregateOutputType = {
    id: number
    labourId: number
    stage: number
    status: number
    notes: number
    documents: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type LabourStageHistoryMinAggregateInputType = {
    id?: true
    labourId?: true
    stage?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type LabourStageHistoryMaxAggregateInputType = {
    id?: true
    labourId?: true
    stage?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type LabourStageHistoryCountAggregateInputType = {
    id?: true
    labourId?: true
    stage?: true
    status?: true
    notes?: true
    documents?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type LabourStageHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourStageHistory to aggregate.
     */
    where?: LabourStageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStageHistories to fetch.
     */
    orderBy?: LabourStageHistoryOrderByWithRelationInput | LabourStageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourStageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourStageHistories
    **/
    _count?: true | LabourStageHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourStageHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourStageHistoryMaxAggregateInputType
  }

  export type GetLabourStageHistoryAggregateType<T extends LabourStageHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourStageHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourStageHistory[P]>
      : GetScalarType<T[P], AggregateLabourStageHistory[P]>
  }




  export type LabourStageHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourStageHistoryWhereInput
    orderBy?: LabourStageHistoryOrderByWithAggregationInput | LabourStageHistoryOrderByWithAggregationInput[]
    by: LabourStageHistoryScalarFieldEnum[] | LabourStageHistoryScalarFieldEnum
    having?: LabourStageHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourStageHistoryCountAggregateInputType | true
    _min?: LabourStageHistoryMinAggregateInputType
    _max?: LabourStageHistoryMaxAggregateInputType
  }

  export type LabourStageHistoryGroupByOutputType = {
    id: string
    labourId: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes: string | null
    documents: string[]
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: LabourStageHistoryCountAggregateOutputType | null
    _min: LabourStageHistoryMinAggregateOutputType | null
    _max: LabourStageHistoryMaxAggregateOutputType | null
  }

  type GetLabourStageHistoryGroupByPayload<T extends LabourStageHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourStageHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourStageHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourStageHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LabourStageHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LabourStageHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labourId?: boolean
    stage?: boolean
    status?: boolean
    notes?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStageHistory"]>

  export type LabourStageHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labourId?: boolean
    stage?: boolean
    status?: boolean
    notes?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStageHistory"]>

  export type LabourStageHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labourId?: boolean
    stage?: boolean
    status?: boolean
    notes?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourStageHistory"]>

  export type LabourStageHistorySelectScalar = {
    id?: boolean
    labourId?: boolean
    stage?: boolean
    status?: boolean
    notes?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type LabourStageHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "labourId" | "stage" | "status" | "notes" | "documents" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["labourStageHistory"]>
  export type LabourStageHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }
  export type LabourStageHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }
  export type LabourStageHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labour?: boolean | LabourProfileDefaultArgs<ExtArgs>
  }

  export type $LabourStageHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourStageHistory"
    objects: {
      labour: Prisma.$LabourProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      labourId: string
      stage: $Enums.LabourStage
      status: $Enums.StageStatus
      notes: string | null
      documents: string[]
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["labourStageHistory"]>
    composites: {}
  }

  type LabourStageHistoryGetPayload<S extends boolean | null | undefined | LabourStageHistoryDefaultArgs> = $Result.GetResult<Prisma.$LabourStageHistoryPayload, S>

  type LabourStageHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourStageHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourStageHistoryCountAggregateInputType | true
    }

  export interface LabourStageHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourStageHistory'], meta: { name: 'LabourStageHistory' } }
    /**
     * Find zero or one LabourStageHistory that matches the filter.
     * @param {LabourStageHistoryFindUniqueArgs} args - Arguments to find a LabourStageHistory
     * @example
     * // Get one LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourStageHistoryFindUniqueArgs>(args: SelectSubset<T, LabourStageHistoryFindUniqueArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourStageHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourStageHistoryFindUniqueOrThrowArgs} args - Arguments to find a LabourStageHistory
     * @example
     * // Get one LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourStageHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourStageHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourStageHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryFindFirstArgs} args - Arguments to find a LabourStageHistory
     * @example
     * // Get one LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourStageHistoryFindFirstArgs>(args?: SelectSubset<T, LabourStageHistoryFindFirstArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourStageHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryFindFirstOrThrowArgs} args - Arguments to find a LabourStageHistory
     * @example
     * // Get one LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourStageHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourStageHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourStageHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourStageHistories
     * const labourStageHistories = await prisma.labourStageHistory.findMany()
     * 
     * // Get first 10 LabourStageHistories
     * const labourStageHistories = await prisma.labourStageHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourStageHistoryWithIdOnly = await prisma.labourStageHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourStageHistoryFindManyArgs>(args?: SelectSubset<T, LabourStageHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourStageHistory.
     * @param {LabourStageHistoryCreateArgs} args - Arguments to create a LabourStageHistory.
     * @example
     * // Create one LabourStageHistory
     * const LabourStageHistory = await prisma.labourStageHistory.create({
     *   data: {
     *     // ... data to create a LabourStageHistory
     *   }
     * })
     * 
     */
    create<T extends LabourStageHistoryCreateArgs>(args: SelectSubset<T, LabourStageHistoryCreateArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourStageHistories.
     * @param {LabourStageHistoryCreateManyArgs} args - Arguments to create many LabourStageHistories.
     * @example
     * // Create many LabourStageHistories
     * const labourStageHistory = await prisma.labourStageHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourStageHistoryCreateManyArgs>(args?: SelectSubset<T, LabourStageHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourStageHistories and returns the data saved in the database.
     * @param {LabourStageHistoryCreateManyAndReturnArgs} args - Arguments to create many LabourStageHistories.
     * @example
     * // Create many LabourStageHistories
     * const labourStageHistory = await prisma.labourStageHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourStageHistories and only return the `id`
     * const labourStageHistoryWithIdOnly = await prisma.labourStageHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourStageHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourStageHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourStageHistory.
     * @param {LabourStageHistoryDeleteArgs} args - Arguments to delete one LabourStageHistory.
     * @example
     * // Delete one LabourStageHistory
     * const LabourStageHistory = await prisma.labourStageHistory.delete({
     *   where: {
     *     // ... filter to delete one LabourStageHistory
     *   }
     * })
     * 
     */
    delete<T extends LabourStageHistoryDeleteArgs>(args: SelectSubset<T, LabourStageHistoryDeleteArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourStageHistory.
     * @param {LabourStageHistoryUpdateArgs} args - Arguments to update one LabourStageHistory.
     * @example
     * // Update one LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourStageHistoryUpdateArgs>(args: SelectSubset<T, LabourStageHistoryUpdateArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourStageHistories.
     * @param {LabourStageHistoryDeleteManyArgs} args - Arguments to filter LabourStageHistories to delete.
     * @example
     * // Delete a few LabourStageHistories
     * const { count } = await prisma.labourStageHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourStageHistoryDeleteManyArgs>(args?: SelectSubset<T, LabourStageHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourStageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourStageHistories
     * const labourStageHistory = await prisma.labourStageHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourStageHistoryUpdateManyArgs>(args: SelectSubset<T, LabourStageHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourStageHistories and returns the data updated in the database.
     * @param {LabourStageHistoryUpdateManyAndReturnArgs} args - Arguments to update many LabourStageHistories.
     * @example
     * // Update many LabourStageHistories
     * const labourStageHistory = await prisma.labourStageHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourStageHistories and only return the `id`
     * const labourStageHistoryWithIdOnly = await prisma.labourStageHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourStageHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourStageHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourStageHistory.
     * @param {LabourStageHistoryUpsertArgs} args - Arguments to update or create a LabourStageHistory.
     * @example
     * // Update or create a LabourStageHistory
     * const labourStageHistory = await prisma.labourStageHistory.upsert({
     *   create: {
     *     // ... data to create a LabourStageHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourStageHistory we want to update
     *   }
     * })
     */
    upsert<T extends LabourStageHistoryUpsertArgs>(args: SelectSubset<T, LabourStageHistoryUpsertArgs<ExtArgs>>): Prisma__LabourStageHistoryClient<$Result.GetResult<Prisma.$LabourStageHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourStageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryCountArgs} args - Arguments to filter LabourStageHistories to count.
     * @example
     * // Count the number of LabourStageHistories
     * const count = await prisma.labourStageHistory.count({
     *   where: {
     *     // ... the filter for the LabourStageHistories we want to count
     *   }
     * })
    **/
    count<T extends LabourStageHistoryCountArgs>(
      args?: Subset<T, LabourStageHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourStageHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourStageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourStageHistoryAggregateArgs>(args: Subset<T, LabourStageHistoryAggregateArgs>): Prisma.PrismaPromise<GetLabourStageHistoryAggregateType<T>>

    /**
     * Group by LabourStageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourStageHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourStageHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourStageHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LabourStageHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourStageHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourStageHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourStageHistory model
   */
  readonly fields: LabourStageHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourStageHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourStageHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    labour<T extends LabourProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabourProfileDefaultArgs<ExtArgs>>): Prisma__LabourProfileClient<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourStageHistory model
   */
  interface LabourStageHistoryFieldRefs {
    readonly id: FieldRef<"LabourStageHistory", 'String'>
    readonly labourId: FieldRef<"LabourStageHistory", 'String'>
    readonly stage: FieldRef<"LabourStageHistory", 'LabourStage'>
    readonly status: FieldRef<"LabourStageHistory", 'StageStatus'>
    readonly notes: FieldRef<"LabourStageHistory", 'String'>
    readonly documents: FieldRef<"LabourStageHistory", 'String[]'>
    readonly createdAt: FieldRef<"LabourStageHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"LabourStageHistory", 'DateTime'>
    readonly completedAt: FieldRef<"LabourStageHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabourStageHistory findUnique
   */
  export type LabourStageHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LabourStageHistory to fetch.
     */
    where: LabourStageHistoryWhereUniqueInput
  }

  /**
   * LabourStageHistory findUniqueOrThrow
   */
  export type LabourStageHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LabourStageHistory to fetch.
     */
    where: LabourStageHistoryWhereUniqueInput
  }

  /**
   * LabourStageHistory findFirst
   */
  export type LabourStageHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LabourStageHistory to fetch.
     */
    where?: LabourStageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStageHistories to fetch.
     */
    orderBy?: LabourStageHistoryOrderByWithRelationInput | LabourStageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourStageHistories.
     */
    cursor?: LabourStageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourStageHistories.
     */
    distinct?: LabourStageHistoryScalarFieldEnum | LabourStageHistoryScalarFieldEnum[]
  }

  /**
   * LabourStageHistory findFirstOrThrow
   */
  export type LabourStageHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LabourStageHistory to fetch.
     */
    where?: LabourStageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStageHistories to fetch.
     */
    orderBy?: LabourStageHistoryOrderByWithRelationInput | LabourStageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourStageHistories.
     */
    cursor?: LabourStageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourStageHistories.
     */
    distinct?: LabourStageHistoryScalarFieldEnum | LabourStageHistoryScalarFieldEnum[]
  }

  /**
   * LabourStageHistory findMany
   */
  export type LabourStageHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LabourStageHistories to fetch.
     */
    where?: LabourStageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourStageHistories to fetch.
     */
    orderBy?: LabourStageHistoryOrderByWithRelationInput | LabourStageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourStageHistories.
     */
    cursor?: LabourStageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourStageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourStageHistories.
     */
    skip?: number
    distinct?: LabourStageHistoryScalarFieldEnum | LabourStageHistoryScalarFieldEnum[]
  }

  /**
   * LabourStageHistory create
   */
  export type LabourStageHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourStageHistory.
     */
    data: XOR<LabourStageHistoryCreateInput, LabourStageHistoryUncheckedCreateInput>
  }

  /**
   * LabourStageHistory createMany
   */
  export type LabourStageHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourStageHistories.
     */
    data: LabourStageHistoryCreateManyInput | LabourStageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourStageHistory createManyAndReturn
   */
  export type LabourStageHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many LabourStageHistories.
     */
    data: LabourStageHistoryCreateManyInput | LabourStageHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourStageHistory update
   */
  export type LabourStageHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourStageHistory.
     */
    data: XOR<LabourStageHistoryUpdateInput, LabourStageHistoryUncheckedUpdateInput>
    /**
     * Choose, which LabourStageHistory to update.
     */
    where: LabourStageHistoryWhereUniqueInput
  }

  /**
   * LabourStageHistory updateMany
   */
  export type LabourStageHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourStageHistories.
     */
    data: XOR<LabourStageHistoryUpdateManyMutationInput, LabourStageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LabourStageHistories to update
     */
    where?: LabourStageHistoryWhereInput
    /**
     * Limit how many LabourStageHistories to update.
     */
    limit?: number
  }

  /**
   * LabourStageHistory updateManyAndReturn
   */
  export type LabourStageHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * The data used to update LabourStageHistories.
     */
    data: XOR<LabourStageHistoryUpdateManyMutationInput, LabourStageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LabourStageHistories to update
     */
    where?: LabourStageHistoryWhereInput
    /**
     * Limit how many LabourStageHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourStageHistory upsert
   */
  export type LabourStageHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourStageHistory to update in case it exists.
     */
    where: LabourStageHistoryWhereUniqueInput
    /**
     * In case the LabourStageHistory found by the `where` argument doesn't exist, create a new LabourStageHistory with this data.
     */
    create: XOR<LabourStageHistoryCreateInput, LabourStageHistoryUncheckedCreateInput>
    /**
     * In case the LabourStageHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourStageHistoryUpdateInput, LabourStageHistoryUncheckedUpdateInput>
  }

  /**
   * LabourStageHistory delete
   */
  export type LabourStageHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
    /**
     * Filter which LabourStageHistory to delete.
     */
    where: LabourStageHistoryWhereUniqueInput
  }

  /**
   * LabourStageHistory deleteMany
   */
  export type LabourStageHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourStageHistories to delete
     */
    where?: LabourStageHistoryWhereInput
    /**
     * Limit how many LabourStageHistories to delete.
     */
    limit?: number
  }

  /**
   * LabourStageHistory without action
   */
  export type LabourStageHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourStageHistory
     */
    select?: LabourStageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourStageHistory
     */
    omit?: LabourStageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourStageHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.AuditAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    performedById: string | null
    performedAt: Date | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.AuditAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    performedById: string | null
    performedAt: Date | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    description: number
    oldData: number
    newData: number
    affectedFields: number
    ipAddress: number
    userAgent: number
    performedById: number
    performedAt: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    oldData?: true
    newData?: true
    affectedFields?: true
    ipAddress?: true
    userAgent?: true
    performedById?: true
    performedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description: string | null
    oldData: JsonValue | null
    newData: JsonValue | null
    affectedFields: string[]
    ipAddress: string | null
    userAgent: string | null
    performedById: string
    performedAt: Date
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
    Requirement?: boolean | AuditLog$RequirementArgs<ExtArgs>
    LabourProfile?: boolean | AuditLog$LabourProfileArgs<ExtArgs>
    _count?: boolean | AuditLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    description?: boolean
    oldData?: boolean
    newData?: boolean
    affectedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    performedById?: boolean
    performedAt?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "description" | "oldData" | "newData" | "affectedFields" | "ipAddress" | "userAgent" | "performedById" | "performedAt" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
    Requirement?: boolean | AuditLog$RequirementArgs<ExtArgs>
    LabourProfile?: boolean | AuditLog$LabourProfileArgs<ExtArgs>
    _count?: boolean | AuditLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      performedBy: Prisma.$UserPayload<ExtArgs>
      Requirement: Prisma.$RequirementPayload<ExtArgs>[]
      LabourProfile: Prisma.$LabourProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.AuditAction
      entityType: string
      entityId: string
      description: string | null
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      affectedFields: string[]
      ipAddress: string | null
      userAgent: string | null
      performedById: string
      performedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Requirement<T extends AuditLog$RequirementArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$RequirementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LabourProfile<T extends AuditLog$LabourProfileArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$LabourProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly affectedFields: FieldRef<"AuditLog", 'String[]'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly performedById: FieldRef<"AuditLog", 'String'>
    readonly performedAt: FieldRef<"AuditLog", 'DateTime'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.Requirement
   */
  export type AuditLog$RequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * AuditLog.LabourProfile
   */
  export type AuditLog$LabourProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourProfile
     */
    select?: LabourProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourProfile
     */
    omit?: LabourProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourProfileInclude<ExtArgs> | null
    where?: LabourProfileWhereInput
    orderBy?: LabourProfileOrderByWithRelationInput | LabourProfileOrderByWithRelationInput[]
    cursor?: LabourProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourProfileScalarFieldEnum | LabourProfileScalarFieldEnum[]
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model JobRoleForwarding
   */

  export type AggregateJobRoleForwarding = {
    _count: JobRoleForwardingCountAggregateOutputType | null
    _avg: JobRoleForwardingAvgAggregateOutputType | null
    _sum: JobRoleForwardingSumAggregateOutputType | null
    _min: JobRoleForwardingMinAggregateOutputType | null
    _max: JobRoleForwardingMaxAggregateOutputType | null
  }

  export type JobRoleForwardingAvgAggregateOutputType = {
    quantity: number | null
  }

  export type JobRoleForwardingSumAggregateOutputType = {
    quantity: number | null
  }

  export type JobRoleForwardingMinAggregateOutputType = {
    id: string | null
    jobRoleId: string | null
    agencyId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type JobRoleForwardingMaxAggregateOutputType = {
    id: string | null
    jobRoleId: string | null
    agencyId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type JobRoleForwardingCountAggregateOutputType = {
    id: number
    jobRoleId: number
    agencyId: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type JobRoleForwardingAvgAggregateInputType = {
    quantity?: true
  }

  export type JobRoleForwardingSumAggregateInputType = {
    quantity?: true
  }

  export type JobRoleForwardingMinAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    quantity?: true
    createdAt?: true
  }

  export type JobRoleForwardingMaxAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    quantity?: true
    createdAt?: true
  }

  export type JobRoleForwardingCountAggregateInputType = {
    id?: true
    jobRoleId?: true
    agencyId?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type JobRoleForwardingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRoleForwarding to aggregate.
     */
    where?: JobRoleForwardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoleForwardings to fetch.
     */
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRoleForwardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoleForwardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoleForwardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRoleForwardings
    **/
    _count?: true | JobRoleForwardingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRoleForwardingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRoleForwardingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRoleForwardingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRoleForwardingMaxAggregateInputType
  }

  export type GetJobRoleForwardingAggregateType<T extends JobRoleForwardingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRoleForwarding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRoleForwarding[P]>
      : GetScalarType<T[P], AggregateJobRoleForwarding[P]>
  }




  export type JobRoleForwardingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRoleForwardingWhereInput
    orderBy?: JobRoleForwardingOrderByWithAggregationInput | JobRoleForwardingOrderByWithAggregationInput[]
    by: JobRoleForwardingScalarFieldEnum[] | JobRoleForwardingScalarFieldEnum
    having?: JobRoleForwardingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRoleForwardingCountAggregateInputType | true
    _avg?: JobRoleForwardingAvgAggregateInputType
    _sum?: JobRoleForwardingSumAggregateInputType
    _min?: JobRoleForwardingMinAggregateInputType
    _max?: JobRoleForwardingMaxAggregateInputType
  }

  export type JobRoleForwardingGroupByOutputType = {
    id: string
    jobRoleId: string
    agencyId: string
    quantity: number
    createdAt: Date
    _count: JobRoleForwardingCountAggregateOutputType | null
    _avg: JobRoleForwardingAvgAggregateOutputType | null
    _sum: JobRoleForwardingSumAggregateOutputType | null
    _min: JobRoleForwardingMinAggregateOutputType | null
    _max: JobRoleForwardingMaxAggregateOutputType | null
  }

  type GetJobRoleForwardingGroupByPayload<T extends JobRoleForwardingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRoleForwardingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRoleForwardingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRoleForwardingGroupByOutputType[P]>
            : GetScalarType<T[P], JobRoleForwardingGroupByOutputType[P]>
        }
      >
    >


  export type JobRoleForwardingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    quantity?: boolean
    createdAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRoleForwarding"]>

  export type JobRoleForwardingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    quantity?: boolean
    createdAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRoleForwarding"]>

  export type JobRoleForwardingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    quantity?: boolean
    createdAt?: boolean
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRoleForwarding"]>

  export type JobRoleForwardingSelectScalar = {
    id?: boolean
    jobRoleId?: boolean
    agencyId?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type JobRoleForwardingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobRoleId" | "agencyId" | "quantity" | "createdAt", ExtArgs["result"]["jobRoleForwarding"]>
  export type JobRoleForwardingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type JobRoleForwardingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type JobRoleForwardingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobRole?: boolean | JobRoleDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $JobRoleForwardingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRoleForwarding"
    objects: {
      jobRole: Prisma.$JobRolePayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobRoleId: string
      agencyId: string
      quantity: number
      createdAt: Date
    }, ExtArgs["result"]["jobRoleForwarding"]>
    composites: {}
  }

  type JobRoleForwardingGetPayload<S extends boolean | null | undefined | JobRoleForwardingDefaultArgs> = $Result.GetResult<Prisma.$JobRoleForwardingPayload, S>

  type JobRoleForwardingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRoleForwardingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRoleForwardingCountAggregateInputType | true
    }

  export interface JobRoleForwardingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRoleForwarding'], meta: { name: 'JobRoleForwarding' } }
    /**
     * Find zero or one JobRoleForwarding that matches the filter.
     * @param {JobRoleForwardingFindUniqueArgs} args - Arguments to find a JobRoleForwarding
     * @example
     * // Get one JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRoleForwardingFindUniqueArgs>(args: SelectSubset<T, JobRoleForwardingFindUniqueArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRoleForwarding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRoleForwardingFindUniqueOrThrowArgs} args - Arguments to find a JobRoleForwarding
     * @example
     * // Get one JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRoleForwardingFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRoleForwardingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRoleForwarding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingFindFirstArgs} args - Arguments to find a JobRoleForwarding
     * @example
     * // Get one JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRoleForwardingFindFirstArgs>(args?: SelectSubset<T, JobRoleForwardingFindFirstArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRoleForwarding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingFindFirstOrThrowArgs} args - Arguments to find a JobRoleForwarding
     * @example
     * // Get one JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRoleForwardingFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRoleForwardingFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRoleForwardings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRoleForwardings
     * const jobRoleForwardings = await prisma.jobRoleForwarding.findMany()
     * 
     * // Get first 10 JobRoleForwardings
     * const jobRoleForwardings = await prisma.jobRoleForwarding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobRoleForwardingWithIdOnly = await prisma.jobRoleForwarding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobRoleForwardingFindManyArgs>(args?: SelectSubset<T, JobRoleForwardingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRoleForwarding.
     * @param {JobRoleForwardingCreateArgs} args - Arguments to create a JobRoleForwarding.
     * @example
     * // Create one JobRoleForwarding
     * const JobRoleForwarding = await prisma.jobRoleForwarding.create({
     *   data: {
     *     // ... data to create a JobRoleForwarding
     *   }
     * })
     * 
     */
    create<T extends JobRoleForwardingCreateArgs>(args: SelectSubset<T, JobRoleForwardingCreateArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRoleForwardings.
     * @param {JobRoleForwardingCreateManyArgs} args - Arguments to create many JobRoleForwardings.
     * @example
     * // Create many JobRoleForwardings
     * const jobRoleForwarding = await prisma.jobRoleForwarding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRoleForwardingCreateManyArgs>(args?: SelectSubset<T, JobRoleForwardingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobRoleForwardings and returns the data saved in the database.
     * @param {JobRoleForwardingCreateManyAndReturnArgs} args - Arguments to create many JobRoleForwardings.
     * @example
     * // Create many JobRoleForwardings
     * const jobRoleForwarding = await prisma.jobRoleForwarding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobRoleForwardings and only return the `id`
     * const jobRoleForwardingWithIdOnly = await prisma.jobRoleForwarding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobRoleForwardingCreateManyAndReturnArgs>(args?: SelectSubset<T, JobRoleForwardingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobRoleForwarding.
     * @param {JobRoleForwardingDeleteArgs} args - Arguments to delete one JobRoleForwarding.
     * @example
     * // Delete one JobRoleForwarding
     * const JobRoleForwarding = await prisma.jobRoleForwarding.delete({
     *   where: {
     *     // ... filter to delete one JobRoleForwarding
     *   }
     * })
     * 
     */
    delete<T extends JobRoleForwardingDeleteArgs>(args: SelectSubset<T, JobRoleForwardingDeleteArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRoleForwarding.
     * @param {JobRoleForwardingUpdateArgs} args - Arguments to update one JobRoleForwarding.
     * @example
     * // Update one JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRoleForwardingUpdateArgs>(args: SelectSubset<T, JobRoleForwardingUpdateArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRoleForwardings.
     * @param {JobRoleForwardingDeleteManyArgs} args - Arguments to filter JobRoleForwardings to delete.
     * @example
     * // Delete a few JobRoleForwardings
     * const { count } = await prisma.jobRoleForwarding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRoleForwardingDeleteManyArgs>(args?: SelectSubset<T, JobRoleForwardingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoleForwardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRoleForwardings
     * const jobRoleForwarding = await prisma.jobRoleForwarding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRoleForwardingUpdateManyArgs>(args: SelectSubset<T, JobRoleForwardingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRoleForwardings and returns the data updated in the database.
     * @param {JobRoleForwardingUpdateManyAndReturnArgs} args - Arguments to update many JobRoleForwardings.
     * @example
     * // Update many JobRoleForwardings
     * const jobRoleForwarding = await prisma.jobRoleForwarding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobRoleForwardings and only return the `id`
     * const jobRoleForwardingWithIdOnly = await prisma.jobRoleForwarding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobRoleForwardingUpdateManyAndReturnArgs>(args: SelectSubset<T, JobRoleForwardingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobRoleForwarding.
     * @param {JobRoleForwardingUpsertArgs} args - Arguments to update or create a JobRoleForwarding.
     * @example
     * // Update or create a JobRoleForwarding
     * const jobRoleForwarding = await prisma.jobRoleForwarding.upsert({
     *   create: {
     *     // ... data to create a JobRoleForwarding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRoleForwarding we want to update
     *   }
     * })
     */
    upsert<T extends JobRoleForwardingUpsertArgs>(args: SelectSubset<T, JobRoleForwardingUpsertArgs<ExtArgs>>): Prisma__JobRoleForwardingClient<$Result.GetResult<Prisma.$JobRoleForwardingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRoleForwardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingCountArgs} args - Arguments to filter JobRoleForwardings to count.
     * @example
     * // Count the number of JobRoleForwardings
     * const count = await prisma.jobRoleForwarding.count({
     *   where: {
     *     // ... the filter for the JobRoleForwardings we want to count
     *   }
     * })
    **/
    count<T extends JobRoleForwardingCountArgs>(
      args?: Subset<T, JobRoleForwardingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRoleForwardingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRoleForwarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRoleForwardingAggregateArgs>(args: Subset<T, JobRoleForwardingAggregateArgs>): Prisma.PrismaPromise<GetJobRoleForwardingAggregateType<T>>

    /**
     * Group by JobRoleForwarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRoleForwardingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRoleForwardingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRoleForwardingGroupByArgs['orderBy'] }
        : { orderBy?: JobRoleForwardingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRoleForwardingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRoleForwardingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRoleForwarding model
   */
  readonly fields: JobRoleForwardingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRoleForwarding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRoleForwardingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobRole<T extends JobRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobRoleDefaultArgs<ExtArgs>>): Prisma__JobRoleClient<$Result.GetResult<Prisma.$JobRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRoleForwarding model
   */
  interface JobRoleForwardingFieldRefs {
    readonly id: FieldRef<"JobRoleForwarding", 'String'>
    readonly jobRoleId: FieldRef<"JobRoleForwarding", 'String'>
    readonly agencyId: FieldRef<"JobRoleForwarding", 'String'>
    readonly quantity: FieldRef<"JobRoleForwarding", 'Int'>
    readonly createdAt: FieldRef<"JobRoleForwarding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobRoleForwarding findUnique
   */
  export type JobRoleForwardingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter, which JobRoleForwarding to fetch.
     */
    where: JobRoleForwardingWhereUniqueInput
  }

  /**
   * JobRoleForwarding findUniqueOrThrow
   */
  export type JobRoleForwardingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter, which JobRoleForwarding to fetch.
     */
    where: JobRoleForwardingWhereUniqueInput
  }

  /**
   * JobRoleForwarding findFirst
   */
  export type JobRoleForwardingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter, which JobRoleForwarding to fetch.
     */
    where?: JobRoleForwardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoleForwardings to fetch.
     */
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoleForwardings.
     */
    cursor?: JobRoleForwardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoleForwardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoleForwardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoleForwardings.
     */
    distinct?: JobRoleForwardingScalarFieldEnum | JobRoleForwardingScalarFieldEnum[]
  }

  /**
   * JobRoleForwarding findFirstOrThrow
   */
  export type JobRoleForwardingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter, which JobRoleForwarding to fetch.
     */
    where?: JobRoleForwardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoleForwardings to fetch.
     */
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRoleForwardings.
     */
    cursor?: JobRoleForwardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoleForwardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoleForwardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRoleForwardings.
     */
    distinct?: JobRoleForwardingScalarFieldEnum | JobRoleForwardingScalarFieldEnum[]
  }

  /**
   * JobRoleForwarding findMany
   */
  export type JobRoleForwardingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter, which JobRoleForwardings to fetch.
     */
    where?: JobRoleForwardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRoleForwardings to fetch.
     */
    orderBy?: JobRoleForwardingOrderByWithRelationInput | JobRoleForwardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRoleForwardings.
     */
    cursor?: JobRoleForwardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRoleForwardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRoleForwardings.
     */
    skip?: number
    distinct?: JobRoleForwardingScalarFieldEnum | JobRoleForwardingScalarFieldEnum[]
  }

  /**
   * JobRoleForwarding create
   */
  export type JobRoleForwardingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * The data needed to create a JobRoleForwarding.
     */
    data: XOR<JobRoleForwardingCreateInput, JobRoleForwardingUncheckedCreateInput>
  }

  /**
   * JobRoleForwarding createMany
   */
  export type JobRoleForwardingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRoleForwardings.
     */
    data: JobRoleForwardingCreateManyInput | JobRoleForwardingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRoleForwarding createManyAndReturn
   */
  export type JobRoleForwardingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * The data used to create many JobRoleForwardings.
     */
    data: JobRoleForwardingCreateManyInput | JobRoleForwardingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRoleForwarding update
   */
  export type JobRoleForwardingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * The data needed to update a JobRoleForwarding.
     */
    data: XOR<JobRoleForwardingUpdateInput, JobRoleForwardingUncheckedUpdateInput>
    /**
     * Choose, which JobRoleForwarding to update.
     */
    where: JobRoleForwardingWhereUniqueInput
  }

  /**
   * JobRoleForwarding updateMany
   */
  export type JobRoleForwardingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRoleForwardings.
     */
    data: XOR<JobRoleForwardingUpdateManyMutationInput, JobRoleForwardingUncheckedUpdateManyInput>
    /**
     * Filter which JobRoleForwardings to update
     */
    where?: JobRoleForwardingWhereInput
    /**
     * Limit how many JobRoleForwardings to update.
     */
    limit?: number
  }

  /**
   * JobRoleForwarding updateManyAndReturn
   */
  export type JobRoleForwardingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * The data used to update JobRoleForwardings.
     */
    data: XOR<JobRoleForwardingUpdateManyMutationInput, JobRoleForwardingUncheckedUpdateManyInput>
    /**
     * Filter which JobRoleForwardings to update
     */
    where?: JobRoleForwardingWhereInput
    /**
     * Limit how many JobRoleForwardings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRoleForwarding upsert
   */
  export type JobRoleForwardingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * The filter to search for the JobRoleForwarding to update in case it exists.
     */
    where: JobRoleForwardingWhereUniqueInput
    /**
     * In case the JobRoleForwarding found by the `where` argument doesn't exist, create a new JobRoleForwarding with this data.
     */
    create: XOR<JobRoleForwardingCreateInput, JobRoleForwardingUncheckedCreateInput>
    /**
     * In case the JobRoleForwarding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRoleForwardingUpdateInput, JobRoleForwardingUncheckedUpdateInput>
  }

  /**
   * JobRoleForwarding delete
   */
  export type JobRoleForwardingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
    /**
     * Filter which JobRoleForwarding to delete.
     */
    where: JobRoleForwardingWhereUniqueInput
  }

  /**
   * JobRoleForwarding deleteMany
   */
  export type JobRoleForwardingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRoleForwardings to delete
     */
    where?: JobRoleForwardingWhereInput
    /**
     * Limit how many JobRoleForwardings to delete.
     */
    limit?: number
  }

  /**
   * JobRoleForwarding without action
   */
  export type JobRoleForwardingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRoleForwarding
     */
    select?: JobRoleForwardingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRoleForwarding
     */
    omit?: JobRoleForwardingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRoleForwardingInclude<ExtArgs> | null
  }


  /**
   * Model OfferLetterDetails
   */

  export type AggregateOfferLetterDetails = {
    _count: OfferLetterDetailsCountAggregateOutputType | null
    _min: OfferLetterDetailsMinAggregateOutputType | null
    _max: OfferLetterDetailsMaxAggregateOutputType | null
  }

  export type OfferLetterDetailsMinAggregateOutputType = {
    id: string | null
    requirementId: string | null
    workingHours: string | null
    workingDays: string | null
    leaveSalary: string | null
    endOfService: string | null
    probationPeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferLetterDetailsMaxAggregateOutputType = {
    id: string | null
    requirementId: string | null
    workingHours: string | null
    workingDays: string | null
    leaveSalary: string | null
    endOfService: string | null
    probationPeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferLetterDetailsCountAggregateOutputType = {
    id: number
    requirementId: number
    workingHours: number
    workingDays: number
    leaveSalary: number
    endOfService: number
    probationPeriod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferLetterDetailsMinAggregateInputType = {
    id?: true
    requirementId?: true
    workingHours?: true
    workingDays?: true
    leaveSalary?: true
    endOfService?: true
    probationPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferLetterDetailsMaxAggregateInputType = {
    id?: true
    requirementId?: true
    workingHours?: true
    workingDays?: true
    leaveSalary?: true
    endOfService?: true
    probationPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferLetterDetailsCountAggregateInputType = {
    id?: true
    requirementId?: true
    workingHours?: true
    workingDays?: true
    leaveSalary?: true
    endOfService?: true
    probationPeriod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferLetterDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferLetterDetails to aggregate.
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferLetterDetails to fetch.
     */
    orderBy?: OfferLetterDetailsOrderByWithRelationInput | OfferLetterDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferLetterDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferLetterDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferLetterDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferLetterDetails
    **/
    _count?: true | OfferLetterDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferLetterDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferLetterDetailsMaxAggregateInputType
  }

  export type GetOfferLetterDetailsAggregateType<T extends OfferLetterDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferLetterDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferLetterDetails[P]>
      : GetScalarType<T[P], AggregateOfferLetterDetails[P]>
  }




  export type OfferLetterDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferLetterDetailsWhereInput
    orderBy?: OfferLetterDetailsOrderByWithAggregationInput | OfferLetterDetailsOrderByWithAggregationInput[]
    by: OfferLetterDetailsScalarFieldEnum[] | OfferLetterDetailsScalarFieldEnum
    having?: OfferLetterDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferLetterDetailsCountAggregateInputType | true
    _min?: OfferLetterDetailsMinAggregateInputType
    _max?: OfferLetterDetailsMaxAggregateInputType
  }

  export type OfferLetterDetailsGroupByOutputType = {
    id: string
    requirementId: string
    workingHours: string | null
    workingDays: string | null
    leaveSalary: string | null
    endOfService: string | null
    probationPeriod: string | null
    createdAt: Date
    updatedAt: Date
    _count: OfferLetterDetailsCountAggregateOutputType | null
    _min: OfferLetterDetailsMinAggregateOutputType | null
    _max: OfferLetterDetailsMaxAggregateOutputType | null
  }

  type GetOfferLetterDetailsGroupByPayload<T extends OfferLetterDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferLetterDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferLetterDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferLetterDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OfferLetterDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OfferLetterDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    workingHours?: boolean
    workingDays?: boolean
    leaveSalary?: boolean
    endOfService?: boolean
    probationPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerLetterDetails"]>

  export type OfferLetterDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    workingHours?: boolean
    workingDays?: boolean
    leaveSalary?: boolean
    endOfService?: boolean
    probationPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerLetterDetails"]>

  export type OfferLetterDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requirementId?: boolean
    workingHours?: boolean
    workingDays?: boolean
    leaveSalary?: boolean
    endOfService?: boolean
    probationPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerLetterDetails"]>

  export type OfferLetterDetailsSelectScalar = {
    id?: boolean
    requirementId?: boolean
    workingHours?: boolean
    workingDays?: boolean
    leaveSalary?: boolean
    endOfService?: boolean
    probationPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferLetterDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requirementId" | "workingHours" | "workingDays" | "leaveSalary" | "endOfService" | "probationPeriod" | "createdAt" | "updatedAt", ExtArgs["result"]["offerLetterDetails"]>
  export type OfferLetterDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }
  export type OfferLetterDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }
  export type OfferLetterDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
  }

  export type $OfferLetterDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferLetterDetails"
    objects: {
      requirement: Prisma.$RequirementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requirementId: string
      workingHours: string | null
      workingDays: string | null
      leaveSalary: string | null
      endOfService: string | null
      probationPeriod: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offerLetterDetails"]>
    composites: {}
  }

  type OfferLetterDetailsGetPayload<S extends boolean | null | undefined | OfferLetterDetailsDefaultArgs> = $Result.GetResult<Prisma.$OfferLetterDetailsPayload, S>

  type OfferLetterDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferLetterDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferLetterDetailsCountAggregateInputType | true
    }

  export interface OfferLetterDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferLetterDetails'], meta: { name: 'OfferLetterDetails' } }
    /**
     * Find zero or one OfferLetterDetails that matches the filter.
     * @param {OfferLetterDetailsFindUniqueArgs} args - Arguments to find a OfferLetterDetails
     * @example
     * // Get one OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferLetterDetailsFindUniqueArgs>(args: SelectSubset<T, OfferLetterDetailsFindUniqueArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferLetterDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferLetterDetailsFindUniqueOrThrowArgs} args - Arguments to find a OfferLetterDetails
     * @example
     * // Get one OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferLetterDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferLetterDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferLetterDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsFindFirstArgs} args - Arguments to find a OfferLetterDetails
     * @example
     * // Get one OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferLetterDetailsFindFirstArgs>(args?: SelectSubset<T, OfferLetterDetailsFindFirstArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferLetterDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsFindFirstOrThrowArgs} args - Arguments to find a OfferLetterDetails
     * @example
     * // Get one OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferLetterDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferLetterDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferLetterDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findMany()
     * 
     * // Get first 10 OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerLetterDetailsWithIdOnly = await prisma.offerLetterDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferLetterDetailsFindManyArgs>(args?: SelectSubset<T, OfferLetterDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferLetterDetails.
     * @param {OfferLetterDetailsCreateArgs} args - Arguments to create a OfferLetterDetails.
     * @example
     * // Create one OfferLetterDetails
     * const OfferLetterDetails = await prisma.offerLetterDetails.create({
     *   data: {
     *     // ... data to create a OfferLetterDetails
     *   }
     * })
     * 
     */
    create<T extends OfferLetterDetailsCreateArgs>(args: SelectSubset<T, OfferLetterDetailsCreateArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferLetterDetails.
     * @param {OfferLetterDetailsCreateManyArgs} args - Arguments to create many OfferLetterDetails.
     * @example
     * // Create many OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferLetterDetailsCreateManyArgs>(args?: SelectSubset<T, OfferLetterDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OfferLetterDetails and returns the data saved in the database.
     * @param {OfferLetterDetailsCreateManyAndReturnArgs} args - Arguments to create many OfferLetterDetails.
     * @example
     * // Create many OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OfferLetterDetails and only return the `id`
     * const offerLetterDetailsWithIdOnly = await prisma.offerLetterDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferLetterDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferLetterDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OfferLetterDetails.
     * @param {OfferLetterDetailsDeleteArgs} args - Arguments to delete one OfferLetterDetails.
     * @example
     * // Delete one OfferLetterDetails
     * const OfferLetterDetails = await prisma.offerLetterDetails.delete({
     *   where: {
     *     // ... filter to delete one OfferLetterDetails
     *   }
     * })
     * 
     */
    delete<T extends OfferLetterDetailsDeleteArgs>(args: SelectSubset<T, OfferLetterDetailsDeleteArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferLetterDetails.
     * @param {OfferLetterDetailsUpdateArgs} args - Arguments to update one OfferLetterDetails.
     * @example
     * // Update one OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferLetterDetailsUpdateArgs>(args: SelectSubset<T, OfferLetterDetailsUpdateArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferLetterDetails.
     * @param {OfferLetterDetailsDeleteManyArgs} args - Arguments to filter OfferLetterDetails to delete.
     * @example
     * // Delete a few OfferLetterDetails
     * const { count } = await prisma.offerLetterDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferLetterDetailsDeleteManyArgs>(args?: SelectSubset<T, OfferLetterDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferLetterDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferLetterDetailsUpdateManyArgs>(args: SelectSubset<T, OfferLetterDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferLetterDetails and returns the data updated in the database.
     * @param {OfferLetterDetailsUpdateManyAndReturnArgs} args - Arguments to update many OfferLetterDetails.
     * @example
     * // Update many OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OfferLetterDetails and only return the `id`
     * const offerLetterDetailsWithIdOnly = await prisma.offerLetterDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferLetterDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferLetterDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OfferLetterDetails.
     * @param {OfferLetterDetailsUpsertArgs} args - Arguments to update or create a OfferLetterDetails.
     * @example
     * // Update or create a OfferLetterDetails
     * const offerLetterDetails = await prisma.offerLetterDetails.upsert({
     *   create: {
     *     // ... data to create a OfferLetterDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferLetterDetails we want to update
     *   }
     * })
     */
    upsert<T extends OfferLetterDetailsUpsertArgs>(args: SelectSubset<T, OfferLetterDetailsUpsertArgs<ExtArgs>>): Prisma__OfferLetterDetailsClient<$Result.GetResult<Prisma.$OfferLetterDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferLetterDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsCountArgs} args - Arguments to filter OfferLetterDetails to count.
     * @example
     * // Count the number of OfferLetterDetails
     * const count = await prisma.offerLetterDetails.count({
     *   where: {
     *     // ... the filter for the OfferLetterDetails we want to count
     *   }
     * })
    **/
    count<T extends OfferLetterDetailsCountArgs>(
      args?: Subset<T, OfferLetterDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferLetterDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferLetterDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferLetterDetailsAggregateArgs>(args: Subset<T, OfferLetterDetailsAggregateArgs>): Prisma.PrismaPromise<GetOfferLetterDetailsAggregateType<T>>

    /**
     * Group by OfferLetterDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferLetterDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferLetterDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferLetterDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OfferLetterDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferLetterDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferLetterDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferLetterDetails model
   */
  readonly fields: OfferLetterDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferLetterDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferLetterDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferLetterDetails model
   */
  interface OfferLetterDetailsFieldRefs {
    readonly id: FieldRef<"OfferLetterDetails", 'String'>
    readonly requirementId: FieldRef<"OfferLetterDetails", 'String'>
    readonly workingHours: FieldRef<"OfferLetterDetails", 'String'>
    readonly workingDays: FieldRef<"OfferLetterDetails", 'String'>
    readonly leaveSalary: FieldRef<"OfferLetterDetails", 'String'>
    readonly endOfService: FieldRef<"OfferLetterDetails", 'String'>
    readonly probationPeriod: FieldRef<"OfferLetterDetails", 'String'>
    readonly createdAt: FieldRef<"OfferLetterDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferLetterDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OfferLetterDetails findUnique
   */
  export type OfferLetterDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OfferLetterDetails to fetch.
     */
    where: OfferLetterDetailsWhereUniqueInput
  }

  /**
   * OfferLetterDetails findUniqueOrThrow
   */
  export type OfferLetterDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OfferLetterDetails to fetch.
     */
    where: OfferLetterDetailsWhereUniqueInput
  }

  /**
   * OfferLetterDetails findFirst
   */
  export type OfferLetterDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OfferLetterDetails to fetch.
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferLetterDetails to fetch.
     */
    orderBy?: OfferLetterDetailsOrderByWithRelationInput | OfferLetterDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferLetterDetails.
     */
    cursor?: OfferLetterDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferLetterDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferLetterDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferLetterDetails.
     */
    distinct?: OfferLetterDetailsScalarFieldEnum | OfferLetterDetailsScalarFieldEnum[]
  }

  /**
   * OfferLetterDetails findFirstOrThrow
   */
  export type OfferLetterDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OfferLetterDetails to fetch.
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferLetterDetails to fetch.
     */
    orderBy?: OfferLetterDetailsOrderByWithRelationInput | OfferLetterDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferLetterDetails.
     */
    cursor?: OfferLetterDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferLetterDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferLetterDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferLetterDetails.
     */
    distinct?: OfferLetterDetailsScalarFieldEnum | OfferLetterDetailsScalarFieldEnum[]
  }

  /**
   * OfferLetterDetails findMany
   */
  export type OfferLetterDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OfferLetterDetails to fetch.
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferLetterDetails to fetch.
     */
    orderBy?: OfferLetterDetailsOrderByWithRelationInput | OfferLetterDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferLetterDetails.
     */
    cursor?: OfferLetterDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferLetterDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferLetterDetails.
     */
    skip?: number
    distinct?: OfferLetterDetailsScalarFieldEnum | OfferLetterDetailsScalarFieldEnum[]
  }

  /**
   * OfferLetterDetails create
   */
  export type OfferLetterDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferLetterDetails.
     */
    data: XOR<OfferLetterDetailsCreateInput, OfferLetterDetailsUncheckedCreateInput>
  }

  /**
   * OfferLetterDetails createMany
   */
  export type OfferLetterDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferLetterDetails.
     */
    data: OfferLetterDetailsCreateManyInput | OfferLetterDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferLetterDetails createManyAndReturn
   */
  export type OfferLetterDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many OfferLetterDetails.
     */
    data: OfferLetterDetailsCreateManyInput | OfferLetterDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferLetterDetails update
   */
  export type OfferLetterDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferLetterDetails.
     */
    data: XOR<OfferLetterDetailsUpdateInput, OfferLetterDetailsUncheckedUpdateInput>
    /**
     * Choose, which OfferLetterDetails to update.
     */
    where: OfferLetterDetailsWhereUniqueInput
  }

  /**
   * OfferLetterDetails updateMany
   */
  export type OfferLetterDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferLetterDetails.
     */
    data: XOR<OfferLetterDetailsUpdateManyMutationInput, OfferLetterDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OfferLetterDetails to update
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * Limit how many OfferLetterDetails to update.
     */
    limit?: number
  }

  /**
   * OfferLetterDetails updateManyAndReturn
   */
  export type OfferLetterDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * The data used to update OfferLetterDetails.
     */
    data: XOR<OfferLetterDetailsUpdateManyMutationInput, OfferLetterDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OfferLetterDetails to update
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * Limit how many OfferLetterDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferLetterDetails upsert
   */
  export type OfferLetterDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferLetterDetails to update in case it exists.
     */
    where: OfferLetterDetailsWhereUniqueInput
    /**
     * In case the OfferLetterDetails found by the `where` argument doesn't exist, create a new OfferLetterDetails with this data.
     */
    create: XOR<OfferLetterDetailsCreateInput, OfferLetterDetailsUncheckedCreateInput>
    /**
     * In case the OfferLetterDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferLetterDetailsUpdateInput, OfferLetterDetailsUncheckedUpdateInput>
  }

  /**
   * OfferLetterDetails delete
   */
  export type OfferLetterDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
    /**
     * Filter which OfferLetterDetails to delete.
     */
    where: OfferLetterDetailsWhereUniqueInput
  }

  /**
   * OfferLetterDetails deleteMany
   */
  export type OfferLetterDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferLetterDetails to delete
     */
    where?: OfferLetterDetailsWhereInput
    /**
     * Limit how many OfferLetterDetails to delete.
     */
    limit?: number
  }

  /**
   * OfferLetterDetails without action
   */
  export type OfferLetterDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferLetterDetails
     */
    select?: OfferLetterDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferLetterDetails
     */
    omit?: OfferLetterDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferLetterDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    recipientId: string | null
    senderId: string | null
    entityType: string | null
    entityId: string | null
    isRead: boolean | null
    isArchived: boolean | null
    priority: $Enums.NotificationPriority | null
    actionUrl: string | null
    actionText: string | null
    createdAt: Date | null
    readAt: Date | null
    archivedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    recipientId: string | null
    senderId: string | null
    entityType: string | null
    entityId: string | null
    isRead: boolean | null
    isArchived: boolean | null
    priority: $Enums.NotificationPriority | null
    actionUrl: string | null
    actionText: string | null
    createdAt: Date | null
    readAt: Date | null
    archivedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    recipientId: number
    senderId: number
    entityType: number
    entityId: number
    isRead: number
    isArchived: number
    priority: number
    actionUrl: number
    actionText: number
    createdAt: number
    readAt: number
    archivedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    recipientId?: true
    senderId?: true
    entityType?: true
    entityId?: true
    isRead?: true
    isArchived?: true
    priority?: true
    actionUrl?: true
    actionText?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    recipientId?: true
    senderId?: true
    entityType?: true
    entityId?: true
    isRead?: true
    isArchived?: true
    priority?: true
    actionUrl?: true
    actionText?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    recipientId?: true
    senderId?: true
    entityType?: true
    entityId?: true
    isRead?: true
    isArchived?: true
    priority?: true
    actionUrl?: true
    actionText?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    recipientId: string
    senderId: string | null
    entityType: string | null
    entityId: string | null
    isRead: boolean
    isArchived: boolean
    priority: $Enums.NotificationPriority
    actionUrl: string | null
    actionText: string | null
    createdAt: Date
    readAt: Date | null
    archivedAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    senderId?: boolean
    entityType?: boolean
    entityId?: boolean
    isRead?: boolean
    isArchived?: boolean
    priority?: boolean
    actionUrl?: boolean
    actionText?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    senderId?: boolean
    entityType?: boolean
    entityId?: boolean
    isRead?: boolean
    isArchived?: boolean
    priority?: boolean
    actionUrl?: boolean
    actionText?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    senderId?: boolean
    entityType?: boolean
    entityId?: boolean
    isRead?: boolean
    isArchived?: boolean
    priority?: boolean
    actionUrl?: boolean
    actionText?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    senderId?: boolean
    entityType?: boolean
    entityId?: boolean
    isRead?: boolean
    isArchived?: boolean
    priority?: boolean
    actionUrl?: boolean
    actionText?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "recipientId" | "senderId" | "entityType" | "entityId" | "isRead" | "isArchived" | "priority" | "actionUrl" | "actionText" | "createdAt" | "readAt" | "archivedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      recipientId: string
      senderId: string | null
      entityType: string | null
      entityId: string | null
      isRead: boolean
      isArchived: boolean
      priority: $Enums.NotificationPriority
      actionUrl: string | null
      actionText: string | null
      createdAt: Date
      readAt: Date | null
      archivedAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly entityType: FieldRef<"Notification", 'String'>
    readonly entityId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly isArchived: FieldRef<"Notification", 'Boolean'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly actionText: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly archivedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    tempPassword: 'tempPassword',
    phone: 'phone',
    altContact: 'altContact',
    profilePicture: 'profilePicture',
    role: 'role',
    status: 'status',
    resetRequired: 'resetRequired',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleteAt: 'deleteAt',
    deletionType: 'deletionType',
    deletionReason: 'deletionReason',
    deletionRequestedBy: 'deletionRequestedBy',
    createdById: 'createdById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    registrationNo: 'registrationNo',
    companySector: 'companySector',
    companySize: 'companySize',
    website: 'website',
    address: 'address',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    designation: 'designation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agencyName: 'agencyName',
    registrationNo: 'registrationNo',
    licenseNumber: 'licenseNumber',
    licenseExpiry: 'licenseExpiry',
    country: 'country',
    website: 'website',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    department: 'department',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    type: 'type',
    url: 'url',
    labourProfileId: 'labourProfileId',
    status: 'status',
    category: 'category',
    requirementId: 'requirementId',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentRequirementScalarFieldEnum: {
    id: 'id',
    role: 'role',
    documentType: 'documentType',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type DocumentRequirementScalarFieldEnum = (typeof DocumentRequirementScalarFieldEnum)[keyof typeof DocumentRequirementScalarFieldEnum]


  export const RequirementScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequirementScalarFieldEnum = (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum]


  export const JobRoleScalarFieldEnum: {
    id: 'id',
    requirementId: 'requirementId',
    title: 'title',
    quantity: 'quantity',
    nationality: 'nationality',
    startDate: 'startDate',
    contractDuration: 'contractDuration',
    salaryCurrency: 'salaryCurrency',
    basicSalary: 'basicSalary',
    foodAllowance: 'foodAllowance',
    foodProvidedByCompany: 'foodProvidedByCompany',
    housingAllowance: 'housingAllowance',
    housingProvidedByCompany: 'housingProvidedByCompany',
    transportationAllowance: 'transportationAllowance',
    transportationProvidedByCompany: 'transportationProvidedByCompany',
    healthInsurance: 'healthInsurance',
    mobileAllowance: 'mobileAllowance',
    mobileProvidedByCompany: 'mobileProvidedByCompany',
    natureOfWorkAllowance: 'natureOfWorkAllowance',
    otherAllowance: 'otherAllowance',
    ticketFrequency: 'ticketFrequency',
    workLocations: 'workLocations',
    previousExperience: 'previousExperience',
    totalExperienceYears: 'totalExperienceYears',
    preferredAge: 'preferredAge',
    languageRequirements: 'languageRequirements',
    specialRequirements: 'specialRequirements',
    assignedAgencyId: 'assignedAgencyId',
    agencyStatus: 'agencyStatus',
    adminStatus: 'adminStatus',
    needsMoreLabour: 'needsMoreLabour'
  };

  export type JobRoleScalarFieldEnum = (typeof JobRoleScalarFieldEnum)[keyof typeof JobRoleScalarFieldEnum]


  export const LabourProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profileImage: 'profileImage',
    age: 'age',
    gender: 'gender',
    nationality: 'nationality',
    email: 'email',
    phone: 'phone',
    passportNumber: 'passportNumber',
    passportExpiry: 'passportExpiry',
    passportVerified: 'passportVerified',
    visaType: 'visaType',
    visaExpiry: 'visaExpiry',
    visaVerified: 'visaVerified',
    medicalReport: 'medicalReport',
    medicalVerified: 'medicalVerified',
    policeClearance: 'policeClearance',
    policeVerified: 'policeVerified',
    contractVerified: 'contractVerified',
    status: 'status',
    verificationStatus: 'verificationStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    documentsSubmittedAt: 'documentsSubmittedAt',
    documentsVerifiedAt: 'documentsVerifiedAt',
    jobRole: 'jobRole',
    skills: 'skills',
    experience: 'experience',
    education: 'education',
    languages: 'languages',
    requirementId: 'requirementId',
    agencyId: 'agencyId',
    currentStage: 'currentStage'
  };

  export type LabourProfileScalarFieldEnum = (typeof LabourProfileScalarFieldEnum)[keyof typeof LabourProfileScalarFieldEnum]


  export const LabourAssignmentScalarFieldEnum: {
    id: 'id',
    jobRoleId: 'jobRoleId',
    agencyId: 'agencyId',
    labourId: 'labourId',
    isBackup: 'isBackup',
    agencyStatus: 'agencyStatus',
    adminStatus: 'adminStatus',
    clientStatus: 'clientStatus',
    adminFeedback: 'adminFeedback',
    clientFeedback: 'clientFeedback',
    signedOfferLetterUrl: 'signedOfferLetterUrl',
    visaUrl: 'visaUrl',
    travelDate: 'travelDate',
    flightTicketUrl: 'flightTicketUrl',
    medicalCertificateUrl: 'medicalCertificateUrl',
    policeClearanceUrl: 'policeClearanceUrl',
    employmentContractUrl: 'employmentContractUrl',
    additionalDocumentsUrls: 'additionalDocumentsUrls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabourAssignmentScalarFieldEnum = (typeof LabourAssignmentScalarFieldEnum)[keyof typeof LabourAssignmentScalarFieldEnum]


  export const LabourStageHistoryScalarFieldEnum: {
    id: 'id',
    labourId: 'labourId',
    stage: 'stage',
    status: 'status',
    notes: 'notes',
    documents: 'documents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type LabourStageHistoryScalarFieldEnum = (typeof LabourStageHistoryScalarFieldEnum)[keyof typeof LabourStageHistoryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    description: 'description',
    oldData: 'oldData',
    newData: 'newData',
    affectedFields: 'affectedFields',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    performedById: 'performedById',
    performedAt: 'performedAt',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const JobRoleForwardingScalarFieldEnum: {
    id: 'id',
    jobRoleId: 'jobRoleId',
    agencyId: 'agencyId',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type JobRoleForwardingScalarFieldEnum = (typeof JobRoleForwardingScalarFieldEnum)[keyof typeof JobRoleForwardingScalarFieldEnum]


  export const OfferLetterDetailsScalarFieldEnum: {
    id: 'id',
    requirementId: 'requirementId',
    workingHours: 'workingHours',
    workingDays: 'workingDays',
    leaveSalary: 'leaveSalary',
    endOfService: 'endOfService',
    probationPeriod: 'probationPeriod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferLetterDetailsScalarFieldEnum = (typeof OfferLetterDetailsScalarFieldEnum)[keyof typeof OfferLetterDetailsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    recipientId: 'recipientId',
    senderId: 'senderId',
    entityType: 'entityType',
    entityId: 'entityId',
    isRead: 'isRead',
    isArchived: 'isArchived',
    priority: 'priority',
    actionUrl: 'actionUrl',
    actionText: 'actionText',
    createdAt: 'createdAt',
    readAt: 'readAt',
    archivedAt: 'archivedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DeletionType'
   */
  export type EnumDeletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeletionType'>
    


  /**
   * Reference to a field of type 'DeletionType[]'
   */
  export type ListEnumDeletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeletionType[]'>
    


  /**
   * Reference to a field of type 'CompanySector'
   */
  export type EnumCompanySectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySector'>
    


  /**
   * Reference to a field of type 'CompanySector[]'
   */
  export type ListEnumCompanySectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySector[]'>
    


  /**
   * Reference to a field of type 'CompanySize'
   */
  export type EnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize'>
    


  /**
   * Reference to a field of type 'CompanySize[]'
   */
  export type ListEnumCompanySizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanySize[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentCategory'
   */
  export type EnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory'>
    


  /**
   * Reference to a field of type 'DocumentCategory[]'
   */
  export type ListEnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory[]'>
    


  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus'>
    


  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ContractDuration'
   */
  export type EnumContractDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractDuration'>
    


  /**
   * Reference to a field of type 'ContractDuration[]'
   */
  export type ListEnumContractDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractDuration[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'LabourProfileStatus'
   */
  export type EnumLabourProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourProfileStatus'>
    


  /**
   * Reference to a field of type 'LabourProfileStatus[]'
   */
  export type ListEnumLabourProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourProfileStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentVerificationStatus'
   */
  export type EnumDocumentVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVerificationStatus'>
    


  /**
   * Reference to a field of type 'DocumentVerificationStatus[]'
   */
  export type ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVerificationStatus[]'>
    


  /**
   * Reference to a field of type 'LabourStage'
   */
  export type EnumLabourStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourStage'>
    


  /**
   * Reference to a field of type 'LabourStage[]'
   */
  export type ListEnumLabourStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabourStage[]'>
    


  /**
   * Reference to a field of type 'StageStatus'
   */
  export type EnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus'>
    


  /**
   * Reference to a field of type 'StageStatus[]'
   */
  export type ListEnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    tempPassword?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agencyProfile?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    Document?: DocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    tempPassword?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altContact?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrderInput | SortOrder
    deletionType?: SortOrderInput | SortOrder
    deletionReason?: SortOrderInput | SortOrder
    deletionRequestedBy?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    clientProfile?: ClientOrderByWithRelationInput
    agencyProfile?: AgencyOrderByWithRelationInput
    adminProfile?: AdminOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    Document?: DocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    tempPassword?: StringNullableFilter<"User"> | string | null
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    clientProfile?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agencyProfile?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    Document?: DocumentListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    tempPassword?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altContact?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrderInput | SortOrder
    deletionType?: SortOrderInput | SortOrder
    deletionReason?: SortOrderInput | SortOrder
    deletionRequestedBy?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    tempPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    altContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableWithAggregatesFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    companyName?: StringFilter<"Client"> | string
    registrationNo?: StringNullableFilter<"Client"> | string | null
    companySector?: EnumCompanySectorFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableFilter<"Client"> | string | null
    address?: StringFilter<"Client"> | string
    city?: StringFilter<"Client"> | string
    country?: StringFilter<"Client"> | string
    postalCode?: StringNullableFilter<"Client"> | string | null
    designation?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Requirement?: RequirementListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Requirement?: RequirementOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    registrationNo?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    companyName?: StringFilter<"Client"> | string
    companySector?: EnumCompanySectorFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableFilter<"Client"> | string | null
    address?: StringFilter<"Client"> | string
    city?: StringFilter<"Client"> | string
    country?: StringFilter<"Client"> | string
    postalCode?: StringNullableFilter<"Client"> | string | null
    designation?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Requirement?: RequirementListRelationFilter
  }, "id" | "userId" | "registrationNo">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringWithAggregatesFilter<"Client"> | string
    companyName?: StringWithAggregatesFilter<"Client"> | string
    registrationNo?: StringNullableWithAggregatesFilter<"Client"> | string | null
    companySector?: EnumCompanySectorWithAggregatesFilter<"Client"> | $Enums.CompanySector
    companySize?: EnumCompanySizeWithAggregatesFilter<"Client"> | $Enums.CompanySize
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringWithAggregatesFilter<"Client"> | string
    city?: StringWithAggregatesFilter<"Client"> | string
    country?: StringWithAggregatesFilter<"Client"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    designation?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    userId?: StringFilter<"Agency"> | string
    agencyName?: StringFilter<"Agency"> | string
    registrationNo?: StringNullableFilter<"Agency"> | string | null
    licenseNumber?: StringFilter<"Agency"> | string
    licenseExpiry?: DateTimeFilter<"Agency"> | Date | string
    country?: StringFilter<"Agency"> | string
    website?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    postalCode?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    JobRole?: JobRoleListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
    LabourAssignment?: LabourAssignmentListRelationFilter
    jobRoleForwardings?: JobRoleForwardingListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    JobRole?: JobRoleOrderByRelationAggregateInput
    LabourProfile?: LabourProfileOrderByRelationAggregateInput
    LabourAssignment?: LabourAssignmentOrderByRelationAggregateInput
    jobRoleForwardings?: JobRoleForwardingOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    registrationNo?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    agencyName?: StringFilter<"Agency"> | string
    licenseNumber?: StringFilter<"Agency"> | string
    licenseExpiry?: DateTimeFilter<"Agency"> | Date | string
    country?: StringFilter<"Agency"> | string
    website?: StringNullableFilter<"Agency"> | string | null
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    postalCode?: StringNullableFilter<"Agency"> | string | null
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    JobRole?: JobRoleListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
    LabourAssignment?: LabourAssignmentListRelationFilter
    jobRoleForwardings?: JobRoleForwardingListRelationFilter
  }, "id" | "userId" | "registrationNo">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    userId?: StringWithAggregatesFilter<"Agency"> | string
    agencyName?: StringWithAggregatesFilter<"Agency"> | string
    registrationNo?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    licenseNumber?: StringWithAggregatesFilter<"Agency"> | string
    licenseExpiry?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    country?: StringWithAggregatesFilter<"Agency"> | string
    website?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    address?: StringWithAggregatesFilter<"Agency"> | string
    city?: StringWithAggregatesFilter<"Agency"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    department?: StringNullableFilter<"Admin"> | string | null
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    department?: StringNullableFilter<"Admin"> | string | null
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    department?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    permissions?: JsonNullableWithAggregatesFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    ownerId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    labourProfileId?: StringNullableFilter<"Document"> | string | null
    status?: EnumAccountStatusFilter<"Document"> | $Enums.AccountStatus
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    requirementId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    labourProfile?: XOR<LabourProfileNullableScalarRelationFilter, LabourProfileWhereInput> | null
    requirement?: XOR<DocumentRequirementNullableScalarRelationFilter, DocumentRequirementWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    labourProfileId?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    labourProfile?: LabourProfileOrderByWithRelationInput
    requirement?: DocumentRequirementOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    ownerId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    labourProfileId?: StringNullableFilter<"Document"> | string | null
    status?: EnumAccountStatusFilter<"Document"> | $Enums.AccountStatus
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    requirementId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    labourProfile?: XOR<LabourProfileNullableScalarRelationFilter, LabourProfileWhereInput> | null
    requirement?: XOR<DocumentRequirementNullableScalarRelationFilter, DocumentRequirementWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    labourProfileId?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    ownerId?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"Document"> | string
    labourProfileId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    status?: EnumAccountStatusWithAggregatesFilter<"Document"> | $Enums.AccountStatus
    category?: EnumDocumentCategoryWithAggregatesFilter<"Document"> | $Enums.DocumentCategory
    requirementId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentRequirementWhereInput = {
    AND?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    OR?: DocumentRequirementWhereInput[]
    NOT?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    id?: StringFilter<"DocumentRequirement"> | string
    role?: EnumUserRoleFilter<"DocumentRequirement"> | $Enums.UserRole
    documentType?: EnumDocumentTypeFilter<"DocumentRequirement"> | $Enums.DocumentType
    category?: EnumDocumentCategoryFilter<"DocumentRequirement"> | $Enums.DocumentCategory
    createdAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    documents?: DocumentListRelationFilter
  }

  export type DocumentRequirementOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    documentType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type DocumentRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    role_documentType?: DocumentRequirementRoleDocumentTypeCompoundUniqueInput
    AND?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    OR?: DocumentRequirementWhereInput[]
    NOT?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    role?: EnumUserRoleFilter<"DocumentRequirement"> | $Enums.UserRole
    documentType?: EnumDocumentTypeFilter<"DocumentRequirement"> | $Enums.DocumentType
    category?: EnumDocumentCategoryFilter<"DocumentRequirement"> | $Enums.DocumentCategory
    createdAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    documents?: DocumentListRelationFilter
  }, "id" | "role_documentType">

  export type DocumentRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    documentType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentRequirementCountOrderByAggregateInput
    _max?: DocumentRequirementMaxOrderByAggregateInput
    _min?: DocumentRequirementMinOrderByAggregateInput
  }

  export type DocumentRequirementScalarWhereWithAggregatesInput = {
    AND?: DocumentRequirementScalarWhereWithAggregatesInput | DocumentRequirementScalarWhereWithAggregatesInput[]
    OR?: DocumentRequirementScalarWhereWithAggregatesInput[]
    NOT?: DocumentRequirementScalarWhereWithAggregatesInput | DocumentRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentRequirement"> | string
    role?: EnumUserRoleWithAggregatesFilter<"DocumentRequirement"> | $Enums.UserRole
    documentType?: EnumDocumentTypeWithAggregatesFilter<"DocumentRequirement"> | $Enums.DocumentType
    category?: EnumDocumentCategoryWithAggregatesFilter<"DocumentRequirement"> | $Enums.DocumentCategory
    createdAt?: DateTimeWithAggregatesFilter<"DocumentRequirement"> | Date | string
  }

  export type RequirementWhereInput = {
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    id?: StringFilter<"Requirement"> | string
    clientId?: StringFilter<"Requirement"> | string
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    jobRoles?: JobRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
    OfferLetterDetails?: XOR<OfferLetterDetailsNullableScalarRelationFilter, OfferLetterDetailsWhereInput> | null
  }

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    jobRoles?: JobRoleOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    LabourProfile?: LabourProfileOrderByRelationAggregateInput
    OfferLetterDetails?: OfferLetterDetailsOrderByWithRelationInput
  }

  export type RequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    clientId?: StringFilter<"Requirement"> | string
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    jobRoles?: JobRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
    OfferLetterDetails?: XOR<OfferLetterDetailsNullableScalarRelationFilter, OfferLetterDetailsWhereInput> | null
  }, "id">

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequirementCountOrderByAggregateInput
    _max?: RequirementMaxOrderByAggregateInput
    _min?: RequirementMinOrderByAggregateInput
  }

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    OR?: RequirementScalarWhereWithAggregatesInput[]
    NOT?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requirement"> | string
    clientId?: StringWithAggregatesFilter<"Requirement"> | string
    status?: EnumRequirementStatusWithAggregatesFilter<"Requirement"> | $Enums.RequirementStatus
    createdAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
  }

  export type JobRoleWhereInput = {
    AND?: JobRoleWhereInput | JobRoleWhereInput[]
    OR?: JobRoleWhereInput[]
    NOT?: JobRoleWhereInput | JobRoleWhereInput[]
    id?: StringFilter<"JobRole"> | string
    requirementId?: StringFilter<"JobRole"> | string
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    startDate?: DateTimeFilter<"JobRole"> | Date | string
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    salaryCurrency?: StringNullableFilter<"JobRole"> | string | null
    basicSalary?: FloatFilter<"JobRole"> | number
    foodAllowance?: FloatNullableFilter<"JobRole"> | number | null
    foodProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    housingAllowance?: FloatNullableFilter<"JobRole"> | number | null
    housingProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    transportationAllowance?: FloatNullableFilter<"JobRole"> | number | null
    transportationProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    healthInsurance?: StringFilter<"JobRole"> | string
    mobileAllowance?: FloatNullableFilter<"JobRole"> | number | null
    mobileProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    natureOfWorkAllowance?: FloatNullableFilter<"JobRole"> | number | null
    otherAllowance?: FloatNullableFilter<"JobRole"> | number | null
    ticketFrequency?: StringFilter<"JobRole"> | string
    workLocations?: StringFilter<"JobRole"> | string
    previousExperience?: StringFilter<"JobRole"> | string
    totalExperienceYears?: IntNullableFilter<"JobRole"> | number | null
    preferredAge?: IntNullableFilter<"JobRole"> | number | null
    languageRequirements?: StringNullableListFilter<"JobRole">
    specialRequirements?: StringNullableFilter<"JobRole"> | string | null
    assignedAgencyId?: StringNullableFilter<"JobRole"> | string | null
    agencyStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    needsMoreLabour?: BoolFilter<"JobRole"> | boolean
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    assignedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    LabourAssignment?: LabourAssignmentListRelationFilter
    forwardings?: JobRoleForwardingListRelationFilter
  }

  export type JobRoleOrderByWithRelationInput = {
    id?: SortOrder
    requirementId?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrderInput | SortOrder
    salaryCurrency?: SortOrderInput | SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrderInput | SortOrder
    foodProvidedByCompany?: SortOrder
    housingAllowance?: SortOrderInput | SortOrder
    housingProvidedByCompany?: SortOrder
    transportationAllowance?: SortOrderInput | SortOrder
    transportationProvidedByCompany?: SortOrder
    healthInsurance?: SortOrder
    mobileAllowance?: SortOrderInput | SortOrder
    mobileProvidedByCompany?: SortOrder
    natureOfWorkAllowance?: SortOrderInput | SortOrder
    otherAllowance?: SortOrderInput | SortOrder
    ticketFrequency?: SortOrder
    workLocations?: SortOrder
    previousExperience?: SortOrder
    totalExperienceYears?: SortOrderInput | SortOrder
    preferredAge?: SortOrderInput | SortOrder
    languageRequirements?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    needsMoreLabour?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
    assignedAgency?: AgencyOrderByWithRelationInput
    LabourAssignment?: LabourAssignmentOrderByRelationAggregateInput
    forwardings?: JobRoleForwardingOrderByRelationAggregateInput
  }

  export type JobRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobRoleWhereInput | JobRoleWhereInput[]
    OR?: JobRoleWhereInput[]
    NOT?: JobRoleWhereInput | JobRoleWhereInput[]
    requirementId?: StringFilter<"JobRole"> | string
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    startDate?: DateTimeFilter<"JobRole"> | Date | string
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    salaryCurrency?: StringNullableFilter<"JobRole"> | string | null
    basicSalary?: FloatFilter<"JobRole"> | number
    foodAllowance?: FloatNullableFilter<"JobRole"> | number | null
    foodProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    housingAllowance?: FloatNullableFilter<"JobRole"> | number | null
    housingProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    transportationAllowance?: FloatNullableFilter<"JobRole"> | number | null
    transportationProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    healthInsurance?: StringFilter<"JobRole"> | string
    mobileAllowance?: FloatNullableFilter<"JobRole"> | number | null
    mobileProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    natureOfWorkAllowance?: FloatNullableFilter<"JobRole"> | number | null
    otherAllowance?: FloatNullableFilter<"JobRole"> | number | null
    ticketFrequency?: StringFilter<"JobRole"> | string
    workLocations?: StringFilter<"JobRole"> | string
    previousExperience?: StringFilter<"JobRole"> | string
    totalExperienceYears?: IntNullableFilter<"JobRole"> | number | null
    preferredAge?: IntNullableFilter<"JobRole"> | number | null
    languageRequirements?: StringNullableListFilter<"JobRole">
    specialRequirements?: StringNullableFilter<"JobRole"> | string | null
    assignedAgencyId?: StringNullableFilter<"JobRole"> | string | null
    agencyStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    needsMoreLabour?: BoolFilter<"JobRole"> | boolean
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    assignedAgency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    LabourAssignment?: LabourAssignmentListRelationFilter
    forwardings?: JobRoleForwardingListRelationFilter
  }, "id">

  export type JobRoleOrderByWithAggregationInput = {
    id?: SortOrder
    requirementId?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrderInput | SortOrder
    salaryCurrency?: SortOrderInput | SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrderInput | SortOrder
    foodProvidedByCompany?: SortOrder
    housingAllowance?: SortOrderInput | SortOrder
    housingProvidedByCompany?: SortOrder
    transportationAllowance?: SortOrderInput | SortOrder
    transportationProvidedByCompany?: SortOrder
    healthInsurance?: SortOrder
    mobileAllowance?: SortOrderInput | SortOrder
    mobileProvidedByCompany?: SortOrder
    natureOfWorkAllowance?: SortOrderInput | SortOrder
    otherAllowance?: SortOrderInput | SortOrder
    ticketFrequency?: SortOrder
    workLocations?: SortOrder
    previousExperience?: SortOrder
    totalExperienceYears?: SortOrderInput | SortOrder
    preferredAge?: SortOrderInput | SortOrder
    languageRequirements?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    needsMoreLabour?: SortOrder
    _count?: JobRoleCountOrderByAggregateInput
    _avg?: JobRoleAvgOrderByAggregateInput
    _max?: JobRoleMaxOrderByAggregateInput
    _min?: JobRoleMinOrderByAggregateInput
    _sum?: JobRoleSumOrderByAggregateInput
  }

  export type JobRoleScalarWhereWithAggregatesInput = {
    AND?: JobRoleScalarWhereWithAggregatesInput | JobRoleScalarWhereWithAggregatesInput[]
    OR?: JobRoleScalarWhereWithAggregatesInput[]
    NOT?: JobRoleScalarWhereWithAggregatesInput | JobRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobRole"> | string
    requirementId?: StringWithAggregatesFilter<"JobRole"> | string
    title?: StringWithAggregatesFilter<"JobRole"> | string
    quantity?: IntWithAggregatesFilter<"JobRole"> | number
    nationality?: StringWithAggregatesFilter<"JobRole"> | string
    startDate?: DateTimeWithAggregatesFilter<"JobRole"> | Date | string
    contractDuration?: EnumContractDurationNullableWithAggregatesFilter<"JobRole"> | $Enums.ContractDuration | null
    salaryCurrency?: StringNullableWithAggregatesFilter<"JobRole"> | string | null
    basicSalary?: FloatWithAggregatesFilter<"JobRole"> | number
    foodAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    foodProvidedByCompany?: BoolWithAggregatesFilter<"JobRole"> | boolean
    housingAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    housingProvidedByCompany?: BoolWithAggregatesFilter<"JobRole"> | boolean
    transportationAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    transportationProvidedByCompany?: BoolWithAggregatesFilter<"JobRole"> | boolean
    healthInsurance?: StringWithAggregatesFilter<"JobRole"> | string
    mobileAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    mobileProvidedByCompany?: BoolWithAggregatesFilter<"JobRole"> | boolean
    natureOfWorkAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    otherAllowance?: FloatNullableWithAggregatesFilter<"JobRole"> | number | null
    ticketFrequency?: StringWithAggregatesFilter<"JobRole"> | string
    workLocations?: StringWithAggregatesFilter<"JobRole"> | string
    previousExperience?: StringWithAggregatesFilter<"JobRole"> | string
    totalExperienceYears?: IntNullableWithAggregatesFilter<"JobRole"> | number | null
    preferredAge?: IntNullableWithAggregatesFilter<"JobRole"> | number | null
    languageRequirements?: StringNullableListFilter<"JobRole">
    specialRequirements?: StringNullableWithAggregatesFilter<"JobRole"> | string | null
    assignedAgencyId?: StringNullableWithAggregatesFilter<"JobRole"> | string | null
    agencyStatus?: EnumRequirementStatusWithAggregatesFilter<"JobRole"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusWithAggregatesFilter<"JobRole"> | $Enums.RequirementStatus
    needsMoreLabour?: BoolWithAggregatesFilter<"JobRole"> | boolean
  }

  export type LabourProfileWhereInput = {
    AND?: LabourProfileWhereInput | LabourProfileWhereInput[]
    OR?: LabourProfileWhereInput[]
    NOT?: LabourProfileWhereInput | LabourProfileWhereInput[]
    id?: StringFilter<"LabourProfile"> | string
    name?: StringFilter<"LabourProfile"> | string
    profileImage?: StringNullableFilter<"LabourProfile"> | string | null
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    email?: StringNullableFilter<"LabourProfile"> | string | null
    phone?: StringNullableFilter<"LabourProfile"> | string | null
    passportNumber?: StringFilter<"LabourProfile"> | string
    passportExpiry?: DateTimeFilter<"LabourProfile"> | Date | string
    passportVerified?: BoolFilter<"LabourProfile"> | boolean
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaVerified?: BoolFilter<"LabourProfile"> | boolean
    medicalReport?: StringNullableFilter<"LabourProfile"> | string | null
    medicalVerified?: BoolFilter<"LabourProfile"> | boolean
    policeClearance?: StringNullableFilter<"LabourProfile"> | string | null
    policeVerified?: BoolFilter<"LabourProfile"> | boolean
    contractVerified?: BoolFilter<"LabourProfile"> | boolean
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFilter<"LabourProfile"> | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
    documentsSubmittedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    documentsVerifiedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    jobRole?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experience?: StringNullableFilter<"LabourProfile"> | string | null
    education?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    requirementId?: StringNullableFilter<"LabourProfile"> | string | null
    agencyId?: StringFilter<"LabourProfile"> | string
    currentStage?: EnumLabourStageFilter<"LabourProfile"> | $Enums.LabourStage
    requirement?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    stages?: LabourStageHistoryListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    Document?: DocumentListRelationFilter
    LabourAssignment?: LabourAssignmentListRelationFilter
  }

  export type LabourProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportVerified?: SortOrder
    visaType?: SortOrderInput | SortOrder
    visaExpiry?: SortOrderInput | SortOrder
    visaVerified?: SortOrder
    medicalReport?: SortOrderInput | SortOrder
    medicalVerified?: SortOrder
    policeClearance?: SortOrderInput | SortOrder
    policeVerified?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentsSubmittedAt?: SortOrderInput | SortOrder
    documentsVerifiedAt?: SortOrderInput | SortOrder
    jobRole?: SortOrderInput | SortOrder
    skills?: SortOrder
    experience?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    languages?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    currentStage?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    stages?: LabourStageHistoryOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    Document?: DocumentOrderByRelationAggregateInput
    LabourAssignment?: LabourAssignmentOrderByRelationAggregateInput
  }

  export type LabourProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: LabourProfileWhereInput | LabourProfileWhereInput[]
    OR?: LabourProfileWhereInput[]
    NOT?: LabourProfileWhereInput | LabourProfileWhereInput[]
    name?: StringFilter<"LabourProfile"> | string
    profileImage?: StringNullableFilter<"LabourProfile"> | string | null
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    passportNumber?: StringFilter<"LabourProfile"> | string
    passportExpiry?: DateTimeFilter<"LabourProfile"> | Date | string
    passportVerified?: BoolFilter<"LabourProfile"> | boolean
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaVerified?: BoolFilter<"LabourProfile"> | boolean
    medicalReport?: StringNullableFilter<"LabourProfile"> | string | null
    medicalVerified?: BoolFilter<"LabourProfile"> | boolean
    policeClearance?: StringNullableFilter<"LabourProfile"> | string | null
    policeVerified?: BoolFilter<"LabourProfile"> | boolean
    contractVerified?: BoolFilter<"LabourProfile"> | boolean
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFilter<"LabourProfile"> | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
    documentsSubmittedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    documentsVerifiedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    jobRole?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experience?: StringNullableFilter<"LabourProfile"> | string | null
    education?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    requirementId?: StringNullableFilter<"LabourProfile"> | string | null
    agencyId?: StringFilter<"LabourProfile"> | string
    currentStage?: EnumLabourStageFilter<"LabourProfile"> | $Enums.LabourStage
    requirement?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    stages?: LabourStageHistoryListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    Document?: DocumentListRelationFilter
    LabourAssignment?: LabourAssignmentListRelationFilter
  }, "id" | "email" | "phone">

  export type LabourProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportVerified?: SortOrder
    visaType?: SortOrderInput | SortOrder
    visaExpiry?: SortOrderInput | SortOrder
    visaVerified?: SortOrder
    medicalReport?: SortOrderInput | SortOrder
    medicalVerified?: SortOrder
    policeClearance?: SortOrderInput | SortOrder
    policeVerified?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentsSubmittedAt?: SortOrderInput | SortOrder
    documentsVerifiedAt?: SortOrderInput | SortOrder
    jobRole?: SortOrderInput | SortOrder
    skills?: SortOrder
    experience?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    languages?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    agencyId?: SortOrder
    currentStage?: SortOrder
    _count?: LabourProfileCountOrderByAggregateInput
    _avg?: LabourProfileAvgOrderByAggregateInput
    _max?: LabourProfileMaxOrderByAggregateInput
    _min?: LabourProfileMinOrderByAggregateInput
    _sum?: LabourProfileSumOrderByAggregateInput
  }

  export type LabourProfileScalarWhereWithAggregatesInput = {
    AND?: LabourProfileScalarWhereWithAggregatesInput | LabourProfileScalarWhereWithAggregatesInput[]
    OR?: LabourProfileScalarWhereWithAggregatesInput[]
    NOT?: LabourProfileScalarWhereWithAggregatesInput | LabourProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourProfile"> | string
    name?: StringWithAggregatesFilter<"LabourProfile"> | string
    profileImage?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    age?: IntWithAggregatesFilter<"LabourProfile"> | number
    gender?: EnumGenderWithAggregatesFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringWithAggregatesFilter<"LabourProfile"> | string
    email?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    passportNumber?: StringWithAggregatesFilter<"LabourProfile"> | string
    passportExpiry?: DateTimeWithAggregatesFilter<"LabourProfile"> | Date | string
    passportVerified?: BoolWithAggregatesFilter<"LabourProfile"> | boolean
    visaType?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    visaVerified?: BoolWithAggregatesFilter<"LabourProfile"> | boolean
    medicalReport?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    medicalVerified?: BoolWithAggregatesFilter<"LabourProfile"> | boolean
    policeClearance?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    policeVerified?: BoolWithAggregatesFilter<"LabourProfile"> | boolean
    contractVerified?: BoolWithAggregatesFilter<"LabourProfile"> | boolean
    status?: EnumLabourProfileStatusWithAggregatesFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusWithAggregatesFilter<"LabourProfile"> | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeWithAggregatesFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabourProfile"> | Date | string
    documentsSubmittedAt?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    documentsVerifiedAt?: DateTimeNullableWithAggregatesFilter<"LabourProfile"> | Date | string | null
    jobRole?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experience?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    education?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    requirementId?: StringNullableWithAggregatesFilter<"LabourProfile"> | string | null
    agencyId?: StringWithAggregatesFilter<"LabourProfile"> | string
    currentStage?: EnumLabourStageWithAggregatesFilter<"LabourProfile"> | $Enums.LabourStage
  }

  export type LabourAssignmentWhereInput = {
    AND?: LabourAssignmentWhereInput | LabourAssignmentWhereInput[]
    OR?: LabourAssignmentWhereInput[]
    NOT?: LabourAssignmentWhereInput | LabourAssignmentWhereInput[]
    id?: StringFilter<"LabourAssignment"> | string
    jobRoleId?: StringFilter<"LabourAssignment"> | string
    agencyId?: StringFilter<"LabourAssignment"> | string
    labourId?: StringFilter<"LabourAssignment"> | string
    isBackup?: BoolFilter<"LabourAssignment"> | boolean
    agencyStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    clientFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    signedOfferLetterUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    visaUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    travelDate?: DateTimeNullableFilter<"LabourAssignment"> | Date | string | null
    flightTicketUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    medicalCertificateUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    policeClearanceUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    employmentContractUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    additionalDocumentsUrls?: StringNullableListFilter<"LabourAssignment">
    createdAt?: DateTimeFilter<"LabourAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"LabourAssignment"> | Date | string
    jobRole?: XOR<JobRoleScalarRelationFilter, JobRoleWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    labour?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
  }

  export type LabourAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    labourId?: SortOrder
    isBackup?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    clientStatus?: SortOrder
    adminFeedback?: SortOrderInput | SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    signedOfferLetterUrl?: SortOrderInput | SortOrder
    visaUrl?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    flightTicketUrl?: SortOrderInput | SortOrder
    medicalCertificateUrl?: SortOrderInput | SortOrder
    policeClearanceUrl?: SortOrderInput | SortOrder
    employmentContractUrl?: SortOrderInput | SortOrder
    additionalDocumentsUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobRole?: JobRoleOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    labour?: LabourProfileOrderByWithRelationInput
  }

  export type LabourAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobRoleId_labourId?: LabourAssignmentJobRoleIdLabourIdCompoundUniqueInput
    AND?: LabourAssignmentWhereInput | LabourAssignmentWhereInput[]
    OR?: LabourAssignmentWhereInput[]
    NOT?: LabourAssignmentWhereInput | LabourAssignmentWhereInput[]
    jobRoleId?: StringFilter<"LabourAssignment"> | string
    agencyId?: StringFilter<"LabourAssignment"> | string
    labourId?: StringFilter<"LabourAssignment"> | string
    isBackup?: BoolFilter<"LabourAssignment"> | boolean
    agencyStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    clientFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    signedOfferLetterUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    visaUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    travelDate?: DateTimeNullableFilter<"LabourAssignment"> | Date | string | null
    flightTicketUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    medicalCertificateUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    policeClearanceUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    employmentContractUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    additionalDocumentsUrls?: StringNullableListFilter<"LabourAssignment">
    createdAt?: DateTimeFilter<"LabourAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"LabourAssignment"> | Date | string
    jobRole?: XOR<JobRoleScalarRelationFilter, JobRoleWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    labour?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
  }, "id" | "jobRoleId_labourId">

  export type LabourAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    labourId?: SortOrder
    isBackup?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    clientStatus?: SortOrder
    adminFeedback?: SortOrderInput | SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    signedOfferLetterUrl?: SortOrderInput | SortOrder
    visaUrl?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    flightTicketUrl?: SortOrderInput | SortOrder
    medicalCertificateUrl?: SortOrderInput | SortOrder
    policeClearanceUrl?: SortOrderInput | SortOrder
    employmentContractUrl?: SortOrderInput | SortOrder
    additionalDocumentsUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabourAssignmentCountOrderByAggregateInput
    _max?: LabourAssignmentMaxOrderByAggregateInput
    _min?: LabourAssignmentMinOrderByAggregateInput
  }

  export type LabourAssignmentScalarWhereWithAggregatesInput = {
    AND?: LabourAssignmentScalarWhereWithAggregatesInput | LabourAssignmentScalarWhereWithAggregatesInput[]
    OR?: LabourAssignmentScalarWhereWithAggregatesInput[]
    NOT?: LabourAssignmentScalarWhereWithAggregatesInput | LabourAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourAssignment"> | string
    jobRoleId?: StringWithAggregatesFilter<"LabourAssignment"> | string
    agencyId?: StringWithAggregatesFilter<"LabourAssignment"> | string
    labourId?: StringWithAggregatesFilter<"LabourAssignment"> | string
    isBackup?: BoolWithAggregatesFilter<"LabourAssignment"> | boolean
    agencyStatus?: EnumRequirementStatusWithAggregatesFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusWithAggregatesFilter<"LabourAssignment"> | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusWithAggregatesFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminFeedback?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    clientFeedback?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    signedOfferLetterUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    visaUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    travelDate?: DateTimeNullableWithAggregatesFilter<"LabourAssignment"> | Date | string | null
    flightTicketUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    medicalCertificateUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    policeClearanceUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    employmentContractUrl?: StringNullableWithAggregatesFilter<"LabourAssignment"> | string | null
    additionalDocumentsUrls?: StringNullableListFilter<"LabourAssignment">
    createdAt?: DateTimeWithAggregatesFilter<"LabourAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabourAssignment"> | Date | string
  }

  export type LabourStageHistoryWhereInput = {
    AND?: LabourStageHistoryWhereInput | LabourStageHistoryWhereInput[]
    OR?: LabourStageHistoryWhereInput[]
    NOT?: LabourStageHistoryWhereInput | LabourStageHistoryWhereInput[]
    id?: StringFilter<"LabourStageHistory"> | string
    labourId?: StringFilter<"LabourStageHistory"> | string
    stage?: EnumLabourStageFilter<"LabourStageHistory"> | $Enums.LabourStage
    status?: EnumStageStatusFilter<"LabourStageHistory"> | $Enums.StageStatus
    notes?: StringNullableFilter<"LabourStageHistory"> | string | null
    documents?: StringNullableListFilter<"LabourStageHistory">
    createdAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    updatedAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"LabourStageHistory"> | Date | string | null
    labour?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
  }

  export type LabourStageHistoryOrderByWithRelationInput = {
    id?: SortOrder
    labourId?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    labour?: LabourProfileOrderByWithRelationInput
  }

  export type LabourStageHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabourStageHistoryWhereInput | LabourStageHistoryWhereInput[]
    OR?: LabourStageHistoryWhereInput[]
    NOT?: LabourStageHistoryWhereInput | LabourStageHistoryWhereInput[]
    labourId?: StringFilter<"LabourStageHistory"> | string
    stage?: EnumLabourStageFilter<"LabourStageHistory"> | $Enums.LabourStage
    status?: EnumStageStatusFilter<"LabourStageHistory"> | $Enums.StageStatus
    notes?: StringNullableFilter<"LabourStageHistory"> | string | null
    documents?: StringNullableListFilter<"LabourStageHistory">
    createdAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    updatedAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"LabourStageHistory"> | Date | string | null
    labour?: XOR<LabourProfileScalarRelationFilter, LabourProfileWhereInput>
  }, "id">

  export type LabourStageHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    labourId?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: LabourStageHistoryCountOrderByAggregateInput
    _max?: LabourStageHistoryMaxOrderByAggregateInput
    _min?: LabourStageHistoryMinOrderByAggregateInput
  }

  export type LabourStageHistoryScalarWhereWithAggregatesInput = {
    AND?: LabourStageHistoryScalarWhereWithAggregatesInput | LabourStageHistoryScalarWhereWithAggregatesInput[]
    OR?: LabourStageHistoryScalarWhereWithAggregatesInput[]
    NOT?: LabourStageHistoryScalarWhereWithAggregatesInput | LabourStageHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourStageHistory"> | string
    labourId?: StringWithAggregatesFilter<"LabourStageHistory"> | string
    stage?: EnumLabourStageWithAggregatesFilter<"LabourStageHistory"> | $Enums.LabourStage
    status?: EnumStageStatusWithAggregatesFilter<"LabourStageHistory"> | $Enums.StageStatus
    notes?: StringNullableWithAggregatesFilter<"LabourStageHistory"> | string | null
    documents?: StringNullableListFilter<"LabourStageHistory">
    createdAt?: DateTimeWithAggregatesFilter<"LabourStageHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabourStageHistory"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"LabourStageHistory"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    Requirement?: RequirementListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    performedBy?: UserOrderByWithRelationInput
    Requirement?: RequirementOrderByRelationAggregateInput
    LabourProfile?: LabourProfileOrderByRelationAggregateInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    Requirement?: RequirementListRelationFilter
    LabourProfile?: LabourProfileListRelationFilter
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    performedById?: StringWithAggregatesFilter<"AuditLog"> | string
    performedAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type JobRoleForwardingWhereInput = {
    AND?: JobRoleForwardingWhereInput | JobRoleForwardingWhereInput[]
    OR?: JobRoleForwardingWhereInput[]
    NOT?: JobRoleForwardingWhereInput | JobRoleForwardingWhereInput[]
    id?: StringFilter<"JobRoleForwarding"> | string
    jobRoleId?: StringFilter<"JobRoleForwarding"> | string
    agencyId?: StringFilter<"JobRoleForwarding"> | string
    quantity?: IntFilter<"JobRoleForwarding"> | number
    createdAt?: DateTimeFilter<"JobRoleForwarding"> | Date | string
    jobRole?: XOR<JobRoleScalarRelationFilter, JobRoleWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type JobRoleForwardingOrderByWithRelationInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    jobRole?: JobRoleOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
  }

  export type JobRoleForwardingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobRoleId_agencyId?: JobRoleForwardingJobRoleIdAgencyIdCompoundUniqueInput
    AND?: JobRoleForwardingWhereInput | JobRoleForwardingWhereInput[]
    OR?: JobRoleForwardingWhereInput[]
    NOT?: JobRoleForwardingWhereInput | JobRoleForwardingWhereInput[]
    jobRoleId?: StringFilter<"JobRoleForwarding"> | string
    agencyId?: StringFilter<"JobRoleForwarding"> | string
    quantity?: IntFilter<"JobRoleForwarding"> | number
    createdAt?: DateTimeFilter<"JobRoleForwarding"> | Date | string
    jobRole?: XOR<JobRoleScalarRelationFilter, JobRoleWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "jobRoleId_agencyId">

  export type JobRoleForwardingOrderByWithAggregationInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: JobRoleForwardingCountOrderByAggregateInput
    _avg?: JobRoleForwardingAvgOrderByAggregateInput
    _max?: JobRoleForwardingMaxOrderByAggregateInput
    _min?: JobRoleForwardingMinOrderByAggregateInput
    _sum?: JobRoleForwardingSumOrderByAggregateInput
  }

  export type JobRoleForwardingScalarWhereWithAggregatesInput = {
    AND?: JobRoleForwardingScalarWhereWithAggregatesInput | JobRoleForwardingScalarWhereWithAggregatesInput[]
    OR?: JobRoleForwardingScalarWhereWithAggregatesInput[]
    NOT?: JobRoleForwardingScalarWhereWithAggregatesInput | JobRoleForwardingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobRoleForwarding"> | string
    jobRoleId?: StringWithAggregatesFilter<"JobRoleForwarding"> | string
    agencyId?: StringWithAggregatesFilter<"JobRoleForwarding"> | string
    quantity?: IntWithAggregatesFilter<"JobRoleForwarding"> | number
    createdAt?: DateTimeWithAggregatesFilter<"JobRoleForwarding"> | Date | string
  }

  export type OfferLetterDetailsWhereInput = {
    AND?: OfferLetterDetailsWhereInput | OfferLetterDetailsWhereInput[]
    OR?: OfferLetterDetailsWhereInput[]
    NOT?: OfferLetterDetailsWhereInput | OfferLetterDetailsWhereInput[]
    id?: StringFilter<"OfferLetterDetails"> | string
    requirementId?: StringFilter<"OfferLetterDetails"> | string
    workingHours?: StringNullableFilter<"OfferLetterDetails"> | string | null
    workingDays?: StringNullableFilter<"OfferLetterDetails"> | string | null
    leaveSalary?: StringNullableFilter<"OfferLetterDetails"> | string | null
    endOfService?: StringNullableFilter<"OfferLetterDetails"> | string | null
    probationPeriod?: StringNullableFilter<"OfferLetterDetails"> | string | null
    createdAt?: DateTimeFilter<"OfferLetterDetails"> | Date | string
    updatedAt?: DateTimeFilter<"OfferLetterDetails"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
  }

  export type OfferLetterDetailsOrderByWithRelationInput = {
    id?: SortOrder
    requirementId?: SortOrder
    workingHours?: SortOrderInput | SortOrder
    workingDays?: SortOrderInput | SortOrder
    leaveSalary?: SortOrderInput | SortOrder
    endOfService?: SortOrderInput | SortOrder
    probationPeriod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requirement?: RequirementOrderByWithRelationInput
  }

  export type OfferLetterDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requirementId?: string
    AND?: OfferLetterDetailsWhereInput | OfferLetterDetailsWhereInput[]
    OR?: OfferLetterDetailsWhereInput[]
    NOT?: OfferLetterDetailsWhereInput | OfferLetterDetailsWhereInput[]
    workingHours?: StringNullableFilter<"OfferLetterDetails"> | string | null
    workingDays?: StringNullableFilter<"OfferLetterDetails"> | string | null
    leaveSalary?: StringNullableFilter<"OfferLetterDetails"> | string | null
    endOfService?: StringNullableFilter<"OfferLetterDetails"> | string | null
    probationPeriod?: StringNullableFilter<"OfferLetterDetails"> | string | null
    createdAt?: DateTimeFilter<"OfferLetterDetails"> | Date | string
    updatedAt?: DateTimeFilter<"OfferLetterDetails"> | Date | string
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
  }, "id" | "requirementId">

  export type OfferLetterDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    requirementId?: SortOrder
    workingHours?: SortOrderInput | SortOrder
    workingDays?: SortOrderInput | SortOrder
    leaveSalary?: SortOrderInput | SortOrder
    endOfService?: SortOrderInput | SortOrder
    probationPeriod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferLetterDetailsCountOrderByAggregateInput
    _max?: OfferLetterDetailsMaxOrderByAggregateInput
    _min?: OfferLetterDetailsMinOrderByAggregateInput
  }

  export type OfferLetterDetailsScalarWhereWithAggregatesInput = {
    AND?: OfferLetterDetailsScalarWhereWithAggregatesInput | OfferLetterDetailsScalarWhereWithAggregatesInput[]
    OR?: OfferLetterDetailsScalarWhereWithAggregatesInput[]
    NOT?: OfferLetterDetailsScalarWhereWithAggregatesInput | OfferLetterDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferLetterDetails"> | string
    requirementId?: StringWithAggregatesFilter<"OfferLetterDetails"> | string
    workingHours?: StringNullableWithAggregatesFilter<"OfferLetterDetails"> | string | null
    workingDays?: StringNullableWithAggregatesFilter<"OfferLetterDetails"> | string | null
    leaveSalary?: StringNullableWithAggregatesFilter<"OfferLetterDetails"> | string | null
    endOfService?: StringNullableWithAggregatesFilter<"OfferLetterDetails"> | string | null
    probationPeriod?: StringNullableWithAggregatesFilter<"OfferLetterDetails"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OfferLetterDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferLetterDetails"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    recipient?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionText?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    archivedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    Requirement?: RequirementCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Requirement?: RequirementUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    Requirement?: RequirementUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyCreateInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    JobRole?: JobRoleCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    JobRole?: JobRoleUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
    owner: UserCreateNestedOneWithoutDocumentInput
    labourProfile?: LabourProfileCreateNestedOneWithoutDocumentInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutDocumentNestedInput
    labourProfile?: LabourProfileUpdateOneWithoutDocumentNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRequirementCreateInput = {
    id?: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category?: $Enums.DocumentCategory
    createdAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementUncheckedCreateInput = {
    id?: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category?: $Enums.DocumentCategory
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementCreateManyInput = {
    id?: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category?: $Enums.DocumentCategory
    createdAt?: Date | string
  }

  export type DocumentRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementCreateManyInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleCreateInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    requirement: RequirementCreateNestedOneWithoutJobRolesInput
    assignedAgency?: AgencyCreateNestedOneWithoutJobRoleInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUncheckedCreateInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    requirement?: RequirementUpdateOneRequiredWithoutJobRolesNestedInput
    assignedAgency?: AgencyUpdateOneWithoutJobRoleNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUncheckedUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleCreateManyInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
  }

  export type JobRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabourProfileCreateInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileCreateManyInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
  }

  export type LabourProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
  }

  export type LabourProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
  }

  export type LabourAssignmentCreateInput = {
    id?: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRole: JobRoleCreateNestedOneWithoutLabourAssignmentInput
    agency: AgencyCreateNestedOneWithoutLabourAssignmentInput
    labour: LabourProfileCreateNestedOneWithoutLabourAssignmentInput
  }

  export type LabourAssignmentUncheckedCreateInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRole?: JobRoleUpdateOneRequiredWithoutLabourAssignmentNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourAssignmentNestedInput
    labour?: LabourProfileUpdateOneRequiredWithoutLabourAssignmentNestedInput
  }

  export type LabourAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentCreateManyInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStageHistoryCreateInput = {
    id?: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    labour: LabourProfileCreateNestedOneWithoutStagesInput
  }

  export type LabourStageHistoryUncheckedCreateInput = {
    id?: string
    labourId: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LabourStageHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    labour?: LabourProfileUpdateOneRequiredWithoutStagesNestedInput
  }

  export type LabourStageHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabourStageHistoryCreateManyInput = {
    id?: string
    labourId: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LabourStageHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabourStageHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    performedBy: UserCreateNestedOneWithoutAuditLogsInput
    Requirement?: RequirementCreateNestedManyWithoutAuditLogsInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
    Requirement?: RequirementUncheckedCreateNestedManyWithoutAuditLogsInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    Requirement?: RequirementUpdateManyWithoutAuditLogsNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUncheckedUpdateManyWithoutAuditLogsNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    jobRole: JobRoleCreateNestedOneWithoutForwardingsInput
    agency: AgencyCreateNestedOneWithoutJobRoleForwardingsInput
  }

  export type JobRoleForwardingUncheckedCreateInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    quantity: number
    createdAt?: Date | string
  }

  export type JobRoleForwardingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRole?: JobRoleUpdateOneRequiredWithoutForwardingsNestedInput
    agency?: AgencyUpdateOneRequiredWithoutJobRoleForwardingsNestedInput
  }

  export type JobRoleForwardingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingCreateManyInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    quantity: number
    createdAt?: Date | string
  }

  export type JobRoleForwardingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferLetterDetailsCreateInput = {
    id?: string
    workingHours?: string | null
    workingDays?: string | null
    leaveSalary?: string | null
    endOfService?: string | null
    probationPeriod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutOfferLetterDetailsInput
  }

  export type OfferLetterDetailsUncheckedCreateInput = {
    id?: string
    requirementId: string
    workingHours?: string | null
    workingDays?: string | null
    leaveSalary?: string | null
    endOfService?: string | null
    probationPeriod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferLetterDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutOfferLetterDetailsNestedInput
  }

  export type OfferLetterDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferLetterDetailsCreateManyInput = {
    id?: string
    requirementId: string
    workingHours?: string | null
    workingDays?: string | null
    leaveSalary?: string | null
    endOfService?: string | null
    probationPeriod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferLetterDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferLetterDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    recipientId: string
    senderId?: string | null
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    recipientId: string
    senderId?: string | null
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumDeletionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableFilter<$PrismaModel> | $Enums.DeletionType | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    tempPassword?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    tempPassword?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    tempPassword?: SortOrder
    phone?: SortOrder
    altContact?: SortOrder
    profilePicture?: SortOrder
    role?: SortOrder
    status?: SortOrder
    resetRequired?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleteAt?: SortOrder
    deletionType?: SortOrder
    deletionReason?: SortOrder
    deletionRequestedBy?: SortOrder
    createdById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeletionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
  }

  export type EnumCompanySectorFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorFilter<$PrismaModel> | $Enums.CompanySector
  }

  export type EnumCompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeFilter<$PrismaModel> | $Enums.CompanySize
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput
    some?: RequirementWhereInput
    none?: RequirementWhereInput
  }

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    registrationNo?: SortOrder
    companySector?: SortOrder
    companySize?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanySectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel> | $Enums.CompanySector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySectorFilter<$PrismaModel>
    _max?: NestedEnumCompanySectorFilter<$PrismaModel>
  }

  export type EnumCompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeFilter<$PrismaModel>
  }

  export type JobRoleListRelationFilter = {
    every?: JobRoleWhereInput
    some?: JobRoleWhereInput
    none?: JobRoleWhereInput
  }

  export type LabourProfileListRelationFilter = {
    every?: LabourProfileWhereInput
    some?: LabourProfileWhereInput
    none?: LabourProfileWhereInput
  }

  export type LabourAssignmentListRelationFilter = {
    every?: LabourAssignmentWhereInput
    some?: LabourAssignmentWhereInput
    none?: LabourAssignmentWhereInput
  }

  export type JobRoleForwardingListRelationFilter = {
    every?: JobRoleForwardingWhereInput
    some?: JobRoleForwardingWhereInput
    none?: JobRoleForwardingWhereInput
  }

  export type JobRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabourProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabourAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobRoleForwardingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agencyName?: SortOrder
    registrationNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    country?: SortOrder
    website?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type LabourProfileNullableScalarRelationFilter = {
    is?: LabourProfileWhereInput | null
    isNot?: LabourProfileWhereInput | null
  }

  export type DocumentRequirementNullableScalarRelationFilter = {
    is?: DocumentRequirementWhereInput | null
    isNot?: DocumentRequirementWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    labourProfileId?: SortOrder
    status?: SortOrder
    category?: SortOrder
    requirementId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    labourProfileId?: SortOrder
    status?: SortOrder
    category?: SortOrder
    requirementId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    labourProfileId?: SortOrder
    status?: SortOrder
    category?: SortOrder
    requirementId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type DocumentRequirementRoleDocumentTypeCompoundUniqueInput = {
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
  }

  export type DocumentRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    documentType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    documentType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    documentType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type OfferLetterDetailsNullableScalarRelationFilter = {
    is?: OfferLetterDetailsWhereInput | null
    isNot?: OfferLetterDetailsWhereInput | null
  }

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumContractDurationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableFilter<$PrismaModel> | $Enums.ContractDuration | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RequirementScalarRelationFilter = {
    is?: RequirementWhereInput
    isNot?: RequirementWhereInput
  }

  export type JobRoleCountOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    salaryCurrency?: SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrder
    foodProvidedByCompany?: SortOrder
    housingAllowance?: SortOrder
    housingProvidedByCompany?: SortOrder
    transportationAllowance?: SortOrder
    transportationProvidedByCompany?: SortOrder
    healthInsurance?: SortOrder
    mobileAllowance?: SortOrder
    mobileProvidedByCompany?: SortOrder
    natureOfWorkAllowance?: SortOrder
    otherAllowance?: SortOrder
    ticketFrequency?: SortOrder
    workLocations?: SortOrder
    previousExperience?: SortOrder
    totalExperienceYears?: SortOrder
    preferredAge?: SortOrder
    languageRequirements?: SortOrder
    specialRequirements?: SortOrder
    assignedAgencyId?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    needsMoreLabour?: SortOrder
  }

  export type JobRoleAvgOrderByAggregateInput = {
    quantity?: SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrder
    housingAllowance?: SortOrder
    transportationAllowance?: SortOrder
    mobileAllowance?: SortOrder
    natureOfWorkAllowance?: SortOrder
    otherAllowance?: SortOrder
    totalExperienceYears?: SortOrder
    preferredAge?: SortOrder
  }

  export type JobRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    salaryCurrency?: SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrder
    foodProvidedByCompany?: SortOrder
    housingAllowance?: SortOrder
    housingProvidedByCompany?: SortOrder
    transportationAllowance?: SortOrder
    transportationProvidedByCompany?: SortOrder
    healthInsurance?: SortOrder
    mobileAllowance?: SortOrder
    mobileProvidedByCompany?: SortOrder
    natureOfWorkAllowance?: SortOrder
    otherAllowance?: SortOrder
    ticketFrequency?: SortOrder
    workLocations?: SortOrder
    previousExperience?: SortOrder
    totalExperienceYears?: SortOrder
    preferredAge?: SortOrder
    specialRequirements?: SortOrder
    assignedAgencyId?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    needsMoreLabour?: SortOrder
  }

  export type JobRoleMinOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    nationality?: SortOrder
    startDate?: SortOrder
    contractDuration?: SortOrder
    salaryCurrency?: SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrder
    foodProvidedByCompany?: SortOrder
    housingAllowance?: SortOrder
    housingProvidedByCompany?: SortOrder
    transportationAllowance?: SortOrder
    transportationProvidedByCompany?: SortOrder
    healthInsurance?: SortOrder
    mobileAllowance?: SortOrder
    mobileProvidedByCompany?: SortOrder
    natureOfWorkAllowance?: SortOrder
    otherAllowance?: SortOrder
    ticketFrequency?: SortOrder
    workLocations?: SortOrder
    previousExperience?: SortOrder
    totalExperienceYears?: SortOrder
    preferredAge?: SortOrder
    specialRequirements?: SortOrder
    assignedAgencyId?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    needsMoreLabour?: SortOrder
  }

  export type JobRoleSumOrderByAggregateInput = {
    quantity?: SortOrder
    basicSalary?: SortOrder
    foodAllowance?: SortOrder
    housingAllowance?: SortOrder
    transportationAllowance?: SortOrder
    mobileAllowance?: SortOrder
    natureOfWorkAllowance?: SortOrder
    otherAllowance?: SortOrder
    totalExperienceYears?: SortOrder
    preferredAge?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumContractDurationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractDuration | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractDurationNullableFilter<$PrismaModel>
    _max?: NestedEnumContractDurationNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumLabourProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusFilter<$PrismaModel> | $Enums.LabourProfileStatus
  }

  export type EnumDocumentVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
  }

  export type EnumLabourStageFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourStage | EnumLabourStageFieldRefInput<$PrismaModel>
    in?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourStageFilter<$PrismaModel> | $Enums.LabourStage
  }

  export type RequirementNullableScalarRelationFilter = {
    is?: RequirementWhereInput | null
    isNot?: RequirementWhereInput | null
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type LabourStageHistoryListRelationFilter = {
    every?: LabourStageHistoryWhereInput
    some?: LabourStageHistoryWhereInput
    none?: LabourStageHistoryWhereInput
  }

  export type LabourStageHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabourProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImage?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportVerified?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    visaVerified?: SortOrder
    medicalReport?: SortOrder
    medicalVerified?: SortOrder
    policeClearance?: SortOrder
    policeVerified?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentsSubmittedAt?: SortOrder
    documentsVerifiedAt?: SortOrder
    jobRole?: SortOrder
    skills?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    languages?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    currentStage?: SortOrder
  }

  export type LabourProfileAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type LabourProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImage?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportVerified?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    visaVerified?: SortOrder
    medicalReport?: SortOrder
    medicalVerified?: SortOrder
    policeClearance?: SortOrder
    policeVerified?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentsSubmittedAt?: SortOrder
    documentsVerifiedAt?: SortOrder
    jobRole?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    currentStage?: SortOrder
  }

  export type LabourProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImage?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportVerified?: SortOrder
    visaType?: SortOrder
    visaExpiry?: SortOrder
    visaVerified?: SortOrder
    medicalReport?: SortOrder
    medicalVerified?: SortOrder
    policeClearance?: SortOrder
    policeVerified?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentsSubmittedAt?: SortOrder
    documentsVerifiedAt?: SortOrder
    jobRole?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    requirementId?: SortOrder
    agencyId?: SortOrder
    currentStage?: SortOrder
  }

  export type LabourProfileSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumLabourProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabourProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
  }

  export type EnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
  }

  export type EnumLabourStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourStage | EnumLabourStageFieldRefInput<$PrismaModel>
    in?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourStageWithAggregatesFilter<$PrismaModel> | $Enums.LabourStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourStageFilter<$PrismaModel>
    _max?: NestedEnumLabourStageFilter<$PrismaModel>
  }

  export type JobRoleScalarRelationFilter = {
    is?: JobRoleWhereInput
    isNot?: JobRoleWhereInput
  }

  export type LabourProfileScalarRelationFilter = {
    is?: LabourProfileWhereInput
    isNot?: LabourProfileWhereInput
  }

  export type LabourAssignmentJobRoleIdLabourIdCompoundUniqueInput = {
    jobRoleId: string
    labourId: string
  }

  export type LabourAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    labourId?: SortOrder
    isBackup?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    clientStatus?: SortOrder
    adminFeedback?: SortOrder
    clientFeedback?: SortOrder
    signedOfferLetterUrl?: SortOrder
    visaUrl?: SortOrder
    travelDate?: SortOrder
    flightTicketUrl?: SortOrder
    medicalCertificateUrl?: SortOrder
    policeClearanceUrl?: SortOrder
    employmentContractUrl?: SortOrder
    additionalDocumentsUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabourAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    labourId?: SortOrder
    isBackup?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    clientStatus?: SortOrder
    adminFeedback?: SortOrder
    clientFeedback?: SortOrder
    signedOfferLetterUrl?: SortOrder
    visaUrl?: SortOrder
    travelDate?: SortOrder
    flightTicketUrl?: SortOrder
    medicalCertificateUrl?: SortOrder
    policeClearanceUrl?: SortOrder
    employmentContractUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabourAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    labourId?: SortOrder
    isBackup?: SortOrder
    agencyStatus?: SortOrder
    adminStatus?: SortOrder
    clientStatus?: SortOrder
    adminFeedback?: SortOrder
    clientFeedback?: SortOrder
    signedOfferLetterUrl?: SortOrder
    visaUrl?: SortOrder
    travelDate?: SortOrder
    flightTicketUrl?: SortOrder
    medicalCertificateUrl?: SortOrder
    policeClearanceUrl?: SortOrder
    employmentContractUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type LabourStageHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    labourId?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type LabourStageHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    labourId?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type LabourStageHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    labourId?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    affectedFields?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    performedById?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type JobRoleForwardingJobRoleIdAgencyIdCompoundUniqueInput = {
    jobRoleId: string
    agencyId: string
  }

  export type JobRoleForwardingCountOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRoleForwardingAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type JobRoleForwardingMaxOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRoleForwardingMinOrderByAggregateInput = {
    id?: SortOrder
    jobRoleId?: SortOrder
    agencyId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRoleForwardingSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OfferLetterDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    workingHours?: SortOrder
    workingDays?: SortOrder
    leaveSalary?: SortOrder
    endOfService?: SortOrder
    probationPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferLetterDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    workingHours?: SortOrder
    workingDays?: SortOrder
    leaveSalary?: SortOrder
    endOfService?: SortOrder
    probationPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferLetterDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    requirementId?: SortOrder
    workingHours?: SortOrder
    workingDays?: SortOrder
    leaveSalary?: SortOrder
    endOfService?: SortOrder
    probationPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    connect?: AgencyWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput> | DocumentCreateWithoutOwnerInput[] | DocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOwnerInput | DocumentCreateOrConnectWithoutOwnerInput[]
    createMany?: DocumentCreateManyOwnerInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type AgencyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    connect?: AgencyWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput> | DocumentCreateWithoutOwnerInput[] | DocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOwnerInput | DocumentCreateOrConnectWithoutOwnerInput[]
    createMany?: DocumentCreateManyOwnerInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumDeletionTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeletionType | null
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    upsert?: AgencyUpsertWithoutUserInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUserInput, AgencyUpdateWithoutUserInput>, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPerformedByInput | AuditLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPerformedByInput | AuditLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPerformedByInput | AuditLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput> | DocumentCreateWithoutOwnerInput[] | DocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOwnerInput | DocumentCreateOrConnectWithoutOwnerInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOwnerInput | DocumentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DocumentCreateManyOwnerInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOwnerInput | DocumentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOwnerInput | DocumentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    upsert?: AgencyUpsertWithoutUserInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUserInput, AgencyUpdateWithoutUserInput>, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput> | AuditLogCreateWithoutPerformedByInput[] | AuditLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPerformedByInput | AuditLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPerformedByInput | AuditLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: AuditLogCreateManyPerformedByInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPerformedByInput | AuditLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPerformedByInput | AuditLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput> | DocumentCreateWithoutOwnerInput[] | DocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOwnerInput | DocumentCreateOrConnectWithoutOwnerInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOwnerInput | DocumentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: DocumentCreateManyOwnerInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOwnerInput | DocumentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOwnerInput | DocumentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutClientInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type EnumCompanySectorFieldUpdateOperationsInput = {
    set?: $Enums.CompanySector
  }

  export type EnumCompanySizeFieldUpdateOperationsInput = {
    set?: $Enums.CompanySize
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type RequirementUpdateManyWithoutClientNestedInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutClientInput | RequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutClientInput | RequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutClientInput | RequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput> | RequirementCreateWithoutClientInput[] | RequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutClientInput | RequirementCreateOrConnectWithoutClientInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutClientInput | RequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RequirementCreateManyClientInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutClientInput | RequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutClientInput | RequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgencyProfileInput = {
    create?: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyProfileInput
    connect?: UserWhereUniqueInput
  }

  export type JobRoleCreateNestedManyWithoutAssignedAgencyInput = {
    create?: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput> | JobRoleCreateWithoutAssignedAgencyInput[] | JobRoleUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutAssignedAgencyInput | JobRoleCreateOrConnectWithoutAssignedAgencyInput[]
    createMany?: JobRoleCreateManyAssignedAgencyInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type LabourProfileCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type LabourAssignmentCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput> | LabourAssignmentCreateWithoutAgencyInput[] | LabourAssignmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutAgencyInput | LabourAssignmentCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourAssignmentCreateManyAgencyInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type JobRoleForwardingCreateNestedManyWithoutAgencyInput = {
    create?: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput> | JobRoleForwardingCreateWithoutAgencyInput[] | JobRoleForwardingUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutAgencyInput | JobRoleForwardingCreateOrConnectWithoutAgencyInput[]
    createMany?: JobRoleForwardingCreateManyAgencyInputEnvelope
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
  }

  export type JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput = {
    create?: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput> | JobRoleCreateWithoutAssignedAgencyInput[] | JobRoleUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutAssignedAgencyInput | JobRoleCreateOrConnectWithoutAssignedAgencyInput[]
    createMany?: JobRoleCreateManyAssignedAgencyInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type LabourProfileUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput> | LabourAssignmentCreateWithoutAgencyInput[] | LabourAssignmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutAgencyInput | LabourAssignmentCreateOrConnectWithoutAgencyInput[]
    createMany?: LabourAssignmentCreateManyAgencyInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput> | JobRoleForwardingCreateWithoutAgencyInput[] | JobRoleForwardingUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutAgencyInput | JobRoleForwardingCreateOrConnectWithoutAgencyInput[]
    createMany?: JobRoleForwardingCreateManyAgencyInputEnvelope
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAgencyProfileNestedInput = {
    create?: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgencyProfileInput
    upsert?: UserUpsertWithoutAgencyProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgencyProfileInput, UserUpdateWithoutAgencyProfileInput>, UserUncheckedUpdateWithoutAgencyProfileInput>
  }

  export type JobRoleUpdateManyWithoutAssignedAgencyNestedInput = {
    create?: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput> | JobRoleCreateWithoutAssignedAgencyInput[] | JobRoleUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutAssignedAgencyInput | JobRoleCreateOrConnectWithoutAssignedAgencyInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutAssignedAgencyInput | JobRoleUpsertWithWhereUniqueWithoutAssignedAgencyInput[]
    createMany?: JobRoleCreateManyAssignedAgencyInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutAssignedAgencyInput | JobRoleUpdateWithWhereUniqueWithoutAssignedAgencyInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutAssignedAgencyInput | JobRoleUpdateManyWithWhereWithoutAssignedAgencyInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type LabourProfileUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAgencyInput | LabourProfileUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAgencyInput | LabourProfileUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAgencyInput | LabourProfileUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type LabourAssignmentUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput> | LabourAssignmentCreateWithoutAgencyInput[] | LabourAssignmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutAgencyInput | LabourAssignmentCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutAgencyInput | LabourAssignmentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourAssignmentCreateManyAgencyInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutAgencyInput | LabourAssignmentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutAgencyInput | LabourAssignmentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type JobRoleForwardingUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput> | JobRoleForwardingCreateWithoutAgencyInput[] | JobRoleForwardingUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutAgencyInput | JobRoleForwardingCreateOrConnectWithoutAgencyInput[]
    upsert?: JobRoleForwardingUpsertWithWhereUniqueWithoutAgencyInput | JobRoleForwardingUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: JobRoleForwardingCreateManyAgencyInputEnvelope
    set?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    disconnect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    delete?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    update?: JobRoleForwardingUpdateWithWhereUniqueWithoutAgencyInput | JobRoleForwardingUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: JobRoleForwardingUpdateManyWithWhereWithoutAgencyInput | JobRoleForwardingUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
  }

  export type JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput = {
    create?: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput> | JobRoleCreateWithoutAssignedAgencyInput[] | JobRoleUncheckedCreateWithoutAssignedAgencyInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutAssignedAgencyInput | JobRoleCreateOrConnectWithoutAssignedAgencyInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutAssignedAgencyInput | JobRoleUpsertWithWhereUniqueWithoutAssignedAgencyInput[]
    createMany?: JobRoleCreateManyAssignedAgencyInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutAssignedAgencyInput | JobRoleUpdateWithWhereUniqueWithoutAssignedAgencyInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutAssignedAgencyInput | JobRoleUpdateManyWithWhereWithoutAssignedAgencyInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput> | LabourProfileCreateWithoutAgencyInput[] | LabourProfileUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAgencyInput | LabourProfileCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAgencyInput | LabourProfileUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourProfileCreateManyAgencyInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAgencyInput | LabourProfileUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAgencyInput | LabourProfileUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput> | LabourAssignmentCreateWithoutAgencyInput[] | LabourAssignmentUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutAgencyInput | LabourAssignmentCreateOrConnectWithoutAgencyInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutAgencyInput | LabourAssignmentUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: LabourAssignmentCreateManyAgencyInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutAgencyInput | LabourAssignmentUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutAgencyInput | LabourAssignmentUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput> | JobRoleForwardingCreateWithoutAgencyInput[] | JobRoleForwardingUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutAgencyInput | JobRoleForwardingCreateOrConnectWithoutAgencyInput[]
    upsert?: JobRoleForwardingUpsertWithWhereUniqueWithoutAgencyInput | JobRoleForwardingUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: JobRoleForwardingCreateManyAgencyInputEnvelope
    set?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    disconnect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    delete?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    update?: JobRoleForwardingUpdateWithWhereUniqueWithoutAgencyInput | JobRoleForwardingUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: JobRoleForwardingUpdateManyWithWhereWithoutAgencyInput | JobRoleForwardingUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserCreateNestedOneWithoutDocumentInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type LabourProfileCreateNestedOneWithoutDocumentInput = {
    create?: XOR<LabourProfileCreateWithoutDocumentInput, LabourProfileUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutDocumentInput
    connect?: LabourProfileWhereUniqueInput
  }

  export type DocumentRequirementCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutDocumentsInput
    connect?: DocumentRequirementWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DocumentCategory
  }

  export type UserUpdateOneRequiredWithoutDocumentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    upsert?: UserUpsertWithoutDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentInput, UserUpdateWithoutDocumentInput>, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type LabourProfileUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<LabourProfileCreateWithoutDocumentInput, LabourProfileUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutDocumentInput
    upsert?: LabourProfileUpsertWithoutDocumentInput
    disconnect?: LabourProfileWhereInput | boolean
    delete?: LabourProfileWhereInput | boolean
    connect?: LabourProfileWhereUniqueInput
    update?: XOR<XOR<LabourProfileUpdateToOneWithWhereWithoutDocumentInput, LabourProfileUpdateWithoutDocumentInput>, LabourProfileUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentRequirementUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutDocumentsInput
    upsert?: DocumentRequirementUpsertWithoutDocumentsInput
    disconnect?: DocumentRequirementWhereInput | boolean
    delete?: DocumentRequirementWhereInput | boolean
    connect?: DocumentRequirementWhereUniqueInput
    update?: XOR<XOR<DocumentRequirementUpdateToOneWithWhereWithoutDocumentsInput, DocumentRequirementUpdateWithoutDocumentsInput>, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentCreateNestedManyWithoutRequirementInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRequirementInput | DocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRequirementInput | DocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRequirementInput | DocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRequirementInput | DocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRequirementInput | DocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRequirementInput | DocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutRequirementInput = {
    create?: XOR<ClientCreateWithoutRequirementInput, ClientUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementInput
    connect?: ClientWhereUniqueInput
  }

  export type JobRoleCreateNestedManyWithoutRequirementInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutRequirementInput = {
    create?: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput> | AuditLogCreateWithoutRequirementInput[] | AuditLogUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutRequirementInput | AuditLogCreateOrConnectWithoutRequirementInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LabourProfileCreateNestedManyWithoutRequirementInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type OfferLetterDetailsCreateNestedOneWithoutRequirementInput = {
    create?: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: OfferLetterDetailsCreateOrConnectWithoutRequirementInput
    connect?: OfferLetterDetailsWhereUniqueInput
  }

  export type JobRoleUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput> | AuditLogCreateWithoutRequirementInput[] | AuditLogUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutRequirementInput | AuditLogCreateOrConnectWithoutRequirementInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LabourProfileUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput = {
    create?: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: OfferLetterDetailsCreateOrConnectWithoutRequirementInput
    connect?: OfferLetterDetailsWhereUniqueInput
  }

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus
  }

  export type ClientUpdateOneRequiredWithoutRequirementNestedInput = {
    create?: XOR<ClientCreateWithoutRequirementInput, ClientUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementInput
    upsert?: ClientUpsertWithoutRequirementInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRequirementInput, ClientUpdateWithoutRequirementInput>, ClientUncheckedUpdateWithoutRequirementInput>
  }

  export type JobRoleUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutRequirementInput | JobRoleUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutRequirementInput | JobRoleUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutRequirementInput | JobRoleUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput> | AuditLogCreateWithoutRequirementInput[] | AuditLogUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutRequirementInput | AuditLogCreateOrConnectWithoutRequirementInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutRequirementInput | AuditLogUpsertWithWhereUniqueWithoutRequirementInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutRequirementInput | AuditLogUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutRequirementInput | AuditLogUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LabourProfileUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutRequirementInput | LabourProfileUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutRequirementInput | LabourProfileUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutRequirementInput | LabourProfileUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type OfferLetterDetailsUpdateOneWithoutRequirementNestedInput = {
    create?: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: OfferLetterDetailsCreateOrConnectWithoutRequirementInput
    upsert?: OfferLetterDetailsUpsertWithoutRequirementInput
    disconnect?: OfferLetterDetailsWhereInput | boolean
    delete?: OfferLetterDetailsWhereInput | boolean
    connect?: OfferLetterDetailsWhereUniqueInput
    update?: XOR<XOR<OfferLetterDetailsUpdateToOneWithWhereWithoutRequirementInput, OfferLetterDetailsUpdateWithoutRequirementInput>, OfferLetterDetailsUncheckedUpdateWithoutRequirementInput>
  }

  export type JobRoleUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput> | JobRoleCreateWithoutRequirementInput[] | JobRoleUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: JobRoleCreateOrConnectWithoutRequirementInput | JobRoleCreateOrConnectWithoutRequirementInput[]
    upsert?: JobRoleUpsertWithWhereUniqueWithoutRequirementInput | JobRoleUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: JobRoleCreateManyRequirementInputEnvelope
    set?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    disconnect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    delete?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    connect?: JobRoleWhereUniqueInput | JobRoleWhereUniqueInput[]
    update?: JobRoleUpdateWithWhereUniqueWithoutRequirementInput | JobRoleUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: JobRoleUpdateManyWithWhereWithoutRequirementInput | JobRoleUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput> | AuditLogCreateWithoutRequirementInput[] | AuditLogUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutRequirementInput | AuditLogCreateOrConnectWithoutRequirementInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutRequirementInput | AuditLogUpsertWithWhereUniqueWithoutRequirementInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutRequirementInput | AuditLogUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutRequirementInput | AuditLogUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput> | LabourProfileCreateWithoutRequirementInput[] | LabourProfileUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutRequirementInput | LabourProfileCreateOrConnectWithoutRequirementInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutRequirementInput | LabourProfileUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: LabourProfileCreateManyRequirementInputEnvelope
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutRequirementInput | LabourProfileUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutRequirementInput | LabourProfileUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput = {
    create?: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: OfferLetterDetailsCreateOrConnectWithoutRequirementInput
    upsert?: OfferLetterDetailsUpsertWithoutRequirementInput
    disconnect?: OfferLetterDetailsWhereInput | boolean
    delete?: OfferLetterDetailsWhereInput | boolean
    connect?: OfferLetterDetailsWhereUniqueInput
    update?: XOR<XOR<OfferLetterDetailsUpdateToOneWithWhereWithoutRequirementInput, OfferLetterDetailsUpdateWithoutRequirementInput>, OfferLetterDetailsUncheckedUpdateWithoutRequirementInput>
  }

  export type JobRoleCreatelanguageRequirementsInput = {
    set: string[]
  }

  export type RequirementCreateNestedOneWithoutJobRolesInput = {
    create?: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutJobRolesInput
    connect?: RequirementWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutJobRoleInput = {
    create?: XOR<AgencyCreateWithoutJobRoleInput, AgencyUncheckedCreateWithoutJobRoleInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutJobRoleInput
    connect?: AgencyWhereUniqueInput
  }

  export type LabourAssignmentCreateNestedManyWithoutJobRoleInput = {
    create?: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput> | LabourAssignmentCreateWithoutJobRoleInput[] | LabourAssignmentUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutJobRoleInput | LabourAssignmentCreateOrConnectWithoutJobRoleInput[]
    createMany?: LabourAssignmentCreateManyJobRoleInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type JobRoleForwardingCreateNestedManyWithoutJobRoleInput = {
    create?: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput> | JobRoleForwardingCreateWithoutJobRoleInput[] | JobRoleForwardingUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutJobRoleInput | JobRoleForwardingCreateOrConnectWithoutJobRoleInput[]
    createMany?: JobRoleForwardingCreateManyJobRoleInputEnvelope
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
  }

  export type LabourAssignmentUncheckedCreateNestedManyWithoutJobRoleInput = {
    create?: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput> | LabourAssignmentCreateWithoutJobRoleInput[] | LabourAssignmentUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutJobRoleInput | LabourAssignmentCreateOrConnectWithoutJobRoleInput[]
    createMany?: LabourAssignmentCreateManyJobRoleInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type JobRoleForwardingUncheckedCreateNestedManyWithoutJobRoleInput = {
    create?: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput> | JobRoleForwardingCreateWithoutJobRoleInput[] | JobRoleForwardingUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutJobRoleInput | JobRoleForwardingCreateOrConnectWithoutJobRoleInput[]
    createMany?: JobRoleForwardingCreateManyJobRoleInputEnvelope
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumContractDurationFieldUpdateOperationsInput = {
    set?: $Enums.ContractDuration | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobRoleUpdatelanguageRequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RequirementUpdateOneRequiredWithoutJobRolesNestedInput = {
    create?: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutJobRolesInput
    upsert?: RequirementUpsertWithoutJobRolesInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutJobRolesInput, RequirementUpdateWithoutJobRolesInput>, RequirementUncheckedUpdateWithoutJobRolesInput>
  }

  export type AgencyUpdateOneWithoutJobRoleNestedInput = {
    create?: XOR<AgencyCreateWithoutJobRoleInput, AgencyUncheckedCreateWithoutJobRoleInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutJobRoleInput
    upsert?: AgencyUpsertWithoutJobRoleInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutJobRoleInput, AgencyUpdateWithoutJobRoleInput>, AgencyUncheckedUpdateWithoutJobRoleInput>
  }

  export type LabourAssignmentUpdateManyWithoutJobRoleNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput> | LabourAssignmentCreateWithoutJobRoleInput[] | LabourAssignmentUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutJobRoleInput | LabourAssignmentCreateOrConnectWithoutJobRoleInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutJobRoleInput | LabourAssignmentUpsertWithWhereUniqueWithoutJobRoleInput[]
    createMany?: LabourAssignmentCreateManyJobRoleInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutJobRoleInput | LabourAssignmentUpdateWithWhereUniqueWithoutJobRoleInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutJobRoleInput | LabourAssignmentUpdateManyWithWhereWithoutJobRoleInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type JobRoleForwardingUpdateManyWithoutJobRoleNestedInput = {
    create?: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput> | JobRoleForwardingCreateWithoutJobRoleInput[] | JobRoleForwardingUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutJobRoleInput | JobRoleForwardingCreateOrConnectWithoutJobRoleInput[]
    upsert?: JobRoleForwardingUpsertWithWhereUniqueWithoutJobRoleInput | JobRoleForwardingUpsertWithWhereUniqueWithoutJobRoleInput[]
    createMany?: JobRoleForwardingCreateManyJobRoleInputEnvelope
    set?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    disconnect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    delete?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    update?: JobRoleForwardingUpdateWithWhereUniqueWithoutJobRoleInput | JobRoleForwardingUpdateWithWhereUniqueWithoutJobRoleInput[]
    updateMany?: JobRoleForwardingUpdateManyWithWhereWithoutJobRoleInput | JobRoleForwardingUpdateManyWithWhereWithoutJobRoleInput[]
    deleteMany?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutJobRoleNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput> | LabourAssignmentCreateWithoutJobRoleInput[] | LabourAssignmentUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutJobRoleInput | LabourAssignmentCreateOrConnectWithoutJobRoleInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutJobRoleInput | LabourAssignmentUpsertWithWhereUniqueWithoutJobRoleInput[]
    createMany?: LabourAssignmentCreateManyJobRoleInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutJobRoleInput | LabourAssignmentUpdateWithWhereUniqueWithoutJobRoleInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutJobRoleInput | LabourAssignmentUpdateManyWithWhereWithoutJobRoleInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type JobRoleForwardingUncheckedUpdateManyWithoutJobRoleNestedInput = {
    create?: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput> | JobRoleForwardingCreateWithoutJobRoleInput[] | JobRoleForwardingUncheckedCreateWithoutJobRoleInput[]
    connectOrCreate?: JobRoleForwardingCreateOrConnectWithoutJobRoleInput | JobRoleForwardingCreateOrConnectWithoutJobRoleInput[]
    upsert?: JobRoleForwardingUpsertWithWhereUniqueWithoutJobRoleInput | JobRoleForwardingUpsertWithWhereUniqueWithoutJobRoleInput[]
    createMany?: JobRoleForwardingCreateManyJobRoleInputEnvelope
    set?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    disconnect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    delete?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    connect?: JobRoleForwardingWhereUniqueInput | JobRoleForwardingWhereUniqueInput[]
    update?: JobRoleForwardingUpdateWithWhereUniqueWithoutJobRoleInput | JobRoleForwardingUpdateWithWhereUniqueWithoutJobRoleInput[]
    updateMany?: JobRoleForwardingUpdateManyWithWhereWithoutJobRoleInput | JobRoleForwardingUpdateManyWithWhereWithoutJobRoleInput[]
    deleteMany?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
  }

  export type LabourProfileCreateskillsInput = {
    set: string[]
  }

  export type LabourProfileCreatelanguagesInput = {
    set: string[]
  }

  export type RequirementCreateNestedOneWithoutLabourProfileInput = {
    create?: XOR<RequirementCreateWithoutLabourProfileInput, RequirementUncheckedCreateWithoutLabourProfileInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutLabourProfileInput
    connect?: RequirementWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutLabourProfileInput = {
    create?: XOR<AgencyCreateWithoutLabourProfileInput, AgencyUncheckedCreateWithoutLabourProfileInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourProfileInput
    connect?: AgencyWhereUniqueInput
  }

  export type LabourStageHistoryCreateNestedManyWithoutLabourInput = {
    create?: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput> | LabourStageHistoryCreateWithoutLabourInput[] | LabourStageHistoryUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourStageHistoryCreateOrConnectWithoutLabourInput | LabourStageHistoryCreateOrConnectWithoutLabourInput[]
    createMany?: LabourStageHistoryCreateManyLabourInputEnvelope
    connect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput> | AuditLogCreateWithoutLabourProfileInput[] | AuditLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutLabourProfileInput | AuditLogCreateOrConnectWithoutLabourProfileInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput> | DocumentCreateWithoutLabourProfileInput[] | DocumentUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLabourProfileInput | DocumentCreateOrConnectWithoutLabourProfileInput[]
    createMany?: DocumentCreateManyLabourProfileInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type LabourAssignmentCreateNestedManyWithoutLabourInput = {
    create?: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput> | LabourAssignmentCreateWithoutLabourInput[] | LabourAssignmentUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutLabourInput | LabourAssignmentCreateOrConnectWithoutLabourInput[]
    createMany?: LabourAssignmentCreateManyLabourInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput = {
    create?: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput> | LabourStageHistoryCreateWithoutLabourInput[] | LabourStageHistoryUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourStageHistoryCreateOrConnectWithoutLabourInput | LabourStageHistoryCreateOrConnectWithoutLabourInput[]
    createMany?: LabourStageHistoryCreateManyLabourInputEnvelope
    connect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput> | AuditLogCreateWithoutLabourProfileInput[] | AuditLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutLabourProfileInput | AuditLogCreateOrConnectWithoutLabourProfileInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutLabourProfileInput = {
    create?: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput> | DocumentCreateWithoutLabourProfileInput[] | DocumentUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLabourProfileInput | DocumentCreateOrConnectWithoutLabourProfileInput[]
    createMany?: DocumentCreateManyLabourProfileInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput = {
    create?: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput> | LabourAssignmentCreateWithoutLabourInput[] | LabourAssignmentUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutLabourInput | LabourAssignmentCreateOrConnectWithoutLabourInput[]
    createMany?: LabourAssignmentCreateManyLabourInputEnvelope
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumLabourProfileStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabourProfileStatus
  }

  export type EnumDocumentVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentVerificationStatus
  }

  export type LabourProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LabourProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumLabourStageFieldUpdateOperationsInput = {
    set?: $Enums.LabourStage
  }

  export type RequirementUpdateOneWithoutLabourProfileNestedInput = {
    create?: XOR<RequirementCreateWithoutLabourProfileInput, RequirementUncheckedCreateWithoutLabourProfileInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutLabourProfileInput
    upsert?: RequirementUpsertWithoutLabourProfileInput
    disconnect?: RequirementWhereInput | boolean
    delete?: RequirementWhereInput | boolean
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutLabourProfileInput, RequirementUpdateWithoutLabourProfileInput>, RequirementUncheckedUpdateWithoutLabourProfileInput>
  }

  export type AgencyUpdateOneRequiredWithoutLabourProfileNestedInput = {
    create?: XOR<AgencyCreateWithoutLabourProfileInput, AgencyUncheckedCreateWithoutLabourProfileInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourProfileInput
    upsert?: AgencyUpsertWithoutLabourProfileInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutLabourProfileInput, AgencyUpdateWithoutLabourProfileInput>, AgencyUncheckedUpdateWithoutLabourProfileInput>
  }

  export type LabourStageHistoryUpdateManyWithoutLabourNestedInput = {
    create?: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput> | LabourStageHistoryCreateWithoutLabourInput[] | LabourStageHistoryUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourStageHistoryCreateOrConnectWithoutLabourInput | LabourStageHistoryCreateOrConnectWithoutLabourInput[]
    upsert?: LabourStageHistoryUpsertWithWhereUniqueWithoutLabourInput | LabourStageHistoryUpsertWithWhereUniqueWithoutLabourInput[]
    createMany?: LabourStageHistoryCreateManyLabourInputEnvelope
    set?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    disconnect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    delete?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    connect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    update?: LabourStageHistoryUpdateWithWhereUniqueWithoutLabourInput | LabourStageHistoryUpdateWithWhereUniqueWithoutLabourInput[]
    updateMany?: LabourStageHistoryUpdateManyWithWhereWithoutLabourInput | LabourStageHistoryUpdateManyWithWhereWithoutLabourInput[]
    deleteMany?: LabourStageHistoryScalarWhereInput | LabourStageHistoryScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput> | AuditLogCreateWithoutLabourProfileInput[] | AuditLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutLabourProfileInput | AuditLogCreateOrConnectWithoutLabourProfileInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutLabourProfileInput | AuditLogUpsertWithWhereUniqueWithoutLabourProfileInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutLabourProfileInput | AuditLogUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutLabourProfileInput | AuditLogUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput> | DocumentCreateWithoutLabourProfileInput[] | DocumentUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLabourProfileInput | DocumentCreateOrConnectWithoutLabourProfileInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLabourProfileInput | DocumentUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: DocumentCreateManyLabourProfileInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLabourProfileInput | DocumentUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLabourProfileInput | DocumentUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type LabourAssignmentUpdateManyWithoutLabourNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput> | LabourAssignmentCreateWithoutLabourInput[] | LabourAssignmentUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutLabourInput | LabourAssignmentCreateOrConnectWithoutLabourInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutLabourInput | LabourAssignmentUpsertWithWhereUniqueWithoutLabourInput[]
    createMany?: LabourAssignmentCreateManyLabourInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutLabourInput | LabourAssignmentUpdateWithWhereUniqueWithoutLabourInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutLabourInput | LabourAssignmentUpdateManyWithWhereWithoutLabourInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput = {
    create?: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput> | LabourStageHistoryCreateWithoutLabourInput[] | LabourStageHistoryUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourStageHistoryCreateOrConnectWithoutLabourInput | LabourStageHistoryCreateOrConnectWithoutLabourInput[]
    upsert?: LabourStageHistoryUpsertWithWhereUniqueWithoutLabourInput | LabourStageHistoryUpsertWithWhereUniqueWithoutLabourInput[]
    createMany?: LabourStageHistoryCreateManyLabourInputEnvelope
    set?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    disconnect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    delete?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    connect?: LabourStageHistoryWhereUniqueInput | LabourStageHistoryWhereUniqueInput[]
    update?: LabourStageHistoryUpdateWithWhereUniqueWithoutLabourInput | LabourStageHistoryUpdateWithWhereUniqueWithoutLabourInput[]
    updateMany?: LabourStageHistoryUpdateManyWithWhereWithoutLabourInput | LabourStageHistoryUpdateManyWithWhereWithoutLabourInput[]
    deleteMany?: LabourStageHistoryScalarWhereInput | LabourStageHistoryScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput> | AuditLogCreateWithoutLabourProfileInput[] | AuditLogUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutLabourProfileInput | AuditLogCreateOrConnectWithoutLabourProfileInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutLabourProfileInput | AuditLogUpsertWithWhereUniqueWithoutLabourProfileInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutLabourProfileInput | AuditLogUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutLabourProfileInput | AuditLogUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput = {
    create?: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput> | DocumentCreateWithoutLabourProfileInput[] | DocumentUncheckedCreateWithoutLabourProfileInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLabourProfileInput | DocumentCreateOrConnectWithoutLabourProfileInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLabourProfileInput | DocumentUpsertWithWhereUniqueWithoutLabourProfileInput[]
    createMany?: DocumentCreateManyLabourProfileInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLabourProfileInput | DocumentUpdateWithWhereUniqueWithoutLabourProfileInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLabourProfileInput | DocumentUpdateManyWithWhereWithoutLabourProfileInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput = {
    create?: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput> | LabourAssignmentCreateWithoutLabourInput[] | LabourAssignmentUncheckedCreateWithoutLabourInput[]
    connectOrCreate?: LabourAssignmentCreateOrConnectWithoutLabourInput | LabourAssignmentCreateOrConnectWithoutLabourInput[]
    upsert?: LabourAssignmentUpsertWithWhereUniqueWithoutLabourInput | LabourAssignmentUpsertWithWhereUniqueWithoutLabourInput[]
    createMany?: LabourAssignmentCreateManyLabourInputEnvelope
    set?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    disconnect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    delete?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    connect?: LabourAssignmentWhereUniqueInput | LabourAssignmentWhereUniqueInput[]
    update?: LabourAssignmentUpdateWithWhereUniqueWithoutLabourInput | LabourAssignmentUpdateWithWhereUniqueWithoutLabourInput[]
    updateMany?: LabourAssignmentUpdateManyWithWhereWithoutLabourInput | LabourAssignmentUpdateManyWithWhereWithoutLabourInput[]
    deleteMany?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
  }

  export type LabourAssignmentCreateadditionalDocumentsUrlsInput = {
    set: string[]
  }

  export type JobRoleCreateNestedOneWithoutLabourAssignmentInput = {
    create?: XOR<JobRoleCreateWithoutLabourAssignmentInput, JobRoleUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: JobRoleCreateOrConnectWithoutLabourAssignmentInput
    connect?: JobRoleWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutLabourAssignmentInput = {
    create?: XOR<AgencyCreateWithoutLabourAssignmentInput, AgencyUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourAssignmentInput
    connect?: AgencyWhereUniqueInput
  }

  export type LabourProfileCreateNestedOneWithoutLabourAssignmentInput = {
    create?: XOR<LabourProfileCreateWithoutLabourAssignmentInput, LabourProfileUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutLabourAssignmentInput
    connect?: LabourProfileWhereUniqueInput
  }

  export type LabourAssignmentUpdateadditionalDocumentsUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobRoleUpdateOneRequiredWithoutLabourAssignmentNestedInput = {
    create?: XOR<JobRoleCreateWithoutLabourAssignmentInput, JobRoleUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: JobRoleCreateOrConnectWithoutLabourAssignmentInput
    upsert?: JobRoleUpsertWithoutLabourAssignmentInput
    connect?: JobRoleWhereUniqueInput
    update?: XOR<XOR<JobRoleUpdateToOneWithWhereWithoutLabourAssignmentInput, JobRoleUpdateWithoutLabourAssignmentInput>, JobRoleUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type AgencyUpdateOneRequiredWithoutLabourAssignmentNestedInput = {
    create?: XOR<AgencyCreateWithoutLabourAssignmentInput, AgencyUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutLabourAssignmentInput
    upsert?: AgencyUpsertWithoutLabourAssignmentInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutLabourAssignmentInput, AgencyUpdateWithoutLabourAssignmentInput>, AgencyUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type LabourProfileUpdateOneRequiredWithoutLabourAssignmentNestedInput = {
    create?: XOR<LabourProfileCreateWithoutLabourAssignmentInput, LabourProfileUncheckedCreateWithoutLabourAssignmentInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutLabourAssignmentInput
    upsert?: LabourProfileUpsertWithoutLabourAssignmentInput
    connect?: LabourProfileWhereUniqueInput
    update?: XOR<XOR<LabourProfileUpdateToOneWithWhereWithoutLabourAssignmentInput, LabourProfileUpdateWithoutLabourAssignmentInput>, LabourProfileUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type LabourStageHistoryCreatedocumentsInput = {
    set: string[]
  }

  export type LabourProfileCreateNestedOneWithoutStagesInput = {
    create?: XOR<LabourProfileCreateWithoutStagesInput, LabourProfileUncheckedCreateWithoutStagesInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutStagesInput
    connect?: LabourProfileWhereUniqueInput
  }

  export type EnumStageStatusFieldUpdateOperationsInput = {
    set?: $Enums.StageStatus
  }

  export type LabourStageHistoryUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LabourProfileUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<LabourProfileCreateWithoutStagesInput, LabourProfileUncheckedCreateWithoutStagesInput>
    connectOrCreate?: LabourProfileCreateOrConnectWithoutStagesInput
    upsert?: LabourProfileUpsertWithoutStagesInput
    connect?: LabourProfileWhereUniqueInput
    update?: XOR<XOR<LabourProfileUpdateToOneWithWhereWithoutStagesInput, LabourProfileUpdateWithoutStagesInput>, LabourProfileUncheckedUpdateWithoutStagesInput>
  }

  export type AuditLogCreateaffectedFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutAuditLogsInput = {
    create?: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput> | RequirementCreateWithoutAuditLogsInput[] | RequirementUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAuditLogsInput | RequirementCreateOrConnectWithoutAuditLogsInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type LabourProfileCreateNestedManyWithoutAuditLogsInput = {
    create?: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput> | LabourProfileCreateWithoutAuditLogsInput[] | LabourProfileUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAuditLogsInput | LabourProfileCreateOrConnectWithoutAuditLogsInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutAuditLogsInput = {
    create?: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput> | RequirementCreateWithoutAuditLogsInput[] | RequirementUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAuditLogsInput | RequirementCreateOrConnectWithoutAuditLogsInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type LabourProfileUncheckedCreateNestedManyWithoutAuditLogsInput = {
    create?: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput> | LabourProfileCreateWithoutAuditLogsInput[] | LabourProfileUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAuditLogsInput | LabourProfileCreateOrConnectWithoutAuditLogsInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type AuditLogUpdateaffectedFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type RequirementUpdateManyWithoutAuditLogsNestedInput = {
    create?: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput> | RequirementCreateWithoutAuditLogsInput[] | RequirementUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAuditLogsInput | RequirementCreateOrConnectWithoutAuditLogsInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutAuditLogsInput | RequirementUpsertWithWhereUniqueWithoutAuditLogsInput[]
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutAuditLogsInput | RequirementUpdateWithWhereUniqueWithoutAuditLogsInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutAuditLogsInput | RequirementUpdateManyWithWhereWithoutAuditLogsInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type LabourProfileUpdateManyWithoutAuditLogsNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput> | LabourProfileCreateWithoutAuditLogsInput[] | LabourProfileUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAuditLogsInput | LabourProfileCreateOrConnectWithoutAuditLogsInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAuditLogsInput | LabourProfileUpsertWithWhereUniqueWithoutAuditLogsInput[]
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAuditLogsInput | LabourProfileUpdateWithWhereUniqueWithoutAuditLogsInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAuditLogsInput | LabourProfileUpdateManyWithWhereWithoutAuditLogsInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutAuditLogsNestedInput = {
    create?: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput> | RequirementCreateWithoutAuditLogsInput[] | RequirementUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutAuditLogsInput | RequirementCreateOrConnectWithoutAuditLogsInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutAuditLogsInput | RequirementUpsertWithWhereUniqueWithoutAuditLogsInput[]
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutAuditLogsInput | RequirementUpdateWithWhereUniqueWithoutAuditLogsInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutAuditLogsInput | RequirementUpdateManyWithWhereWithoutAuditLogsInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type LabourProfileUncheckedUpdateManyWithoutAuditLogsNestedInput = {
    create?: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput> | LabourProfileCreateWithoutAuditLogsInput[] | LabourProfileUncheckedCreateWithoutAuditLogsInput[]
    connectOrCreate?: LabourProfileCreateOrConnectWithoutAuditLogsInput | LabourProfileCreateOrConnectWithoutAuditLogsInput[]
    upsert?: LabourProfileUpsertWithWhereUniqueWithoutAuditLogsInput | LabourProfileUpsertWithWhereUniqueWithoutAuditLogsInput[]
    set?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    disconnect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    delete?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    connect?: LabourProfileWhereUniqueInput | LabourProfileWhereUniqueInput[]
    update?: LabourProfileUpdateWithWhereUniqueWithoutAuditLogsInput | LabourProfileUpdateWithWhereUniqueWithoutAuditLogsInput[]
    updateMany?: LabourProfileUpdateManyWithWhereWithoutAuditLogsInput | LabourProfileUpdateManyWithWhereWithoutAuditLogsInput[]
    deleteMany?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
  }

  export type JobRoleCreateNestedOneWithoutForwardingsInput = {
    create?: XOR<JobRoleCreateWithoutForwardingsInput, JobRoleUncheckedCreateWithoutForwardingsInput>
    connectOrCreate?: JobRoleCreateOrConnectWithoutForwardingsInput
    connect?: JobRoleWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutJobRoleForwardingsInput = {
    create?: XOR<AgencyCreateWithoutJobRoleForwardingsInput, AgencyUncheckedCreateWithoutJobRoleForwardingsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutJobRoleForwardingsInput
    connect?: AgencyWhereUniqueInput
  }

  export type JobRoleUpdateOneRequiredWithoutForwardingsNestedInput = {
    create?: XOR<JobRoleCreateWithoutForwardingsInput, JobRoleUncheckedCreateWithoutForwardingsInput>
    connectOrCreate?: JobRoleCreateOrConnectWithoutForwardingsInput
    upsert?: JobRoleUpsertWithoutForwardingsInput
    connect?: JobRoleWhereUniqueInput
    update?: XOR<XOR<JobRoleUpdateToOneWithWhereWithoutForwardingsInput, JobRoleUpdateWithoutForwardingsInput>, JobRoleUncheckedUpdateWithoutForwardingsInput>
  }

  export type AgencyUpdateOneRequiredWithoutJobRoleForwardingsNestedInput = {
    create?: XOR<AgencyCreateWithoutJobRoleForwardingsInput, AgencyUncheckedCreateWithoutJobRoleForwardingsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutJobRoleForwardingsInput
    upsert?: AgencyUpsertWithoutJobRoleForwardingsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutJobRoleForwardingsInput, AgencyUpdateWithoutJobRoleForwardingsInput>, AgencyUncheckedUpdateWithoutJobRoleForwardingsInput>
  }

  export type RequirementCreateNestedOneWithoutOfferLetterDetailsInput = {
    create?: XOR<RequirementCreateWithoutOfferLetterDetailsInput, RequirementUncheckedCreateWithoutOfferLetterDetailsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutOfferLetterDetailsInput
    connect?: RequirementWhereUniqueInput
  }

  export type RequirementUpdateOneRequiredWithoutOfferLetterDetailsNestedInput = {
    create?: XOR<RequirementCreateWithoutOfferLetterDetailsInput, RequirementUncheckedCreateWithoutOfferLetterDetailsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutOfferLetterDetailsInput
    upsert?: RequirementUpsertWithoutOfferLetterDetailsInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutOfferLetterDetailsInput, RequirementUpdateWithoutOfferLetterDetailsInput>, RequirementUncheckedUpdateWithoutOfferLetterDetailsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumDeletionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableFilter<$PrismaModel> | $Enums.DeletionType | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeletionType | EnumDeletionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeletionType[] | ListEnumDeletionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeletionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeletionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeletionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompanySectorFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorFilter<$PrismaModel> | $Enums.CompanySector
  }

  export type NestedEnumCompanySizeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeFilter<$PrismaModel> | $Enums.CompanySize
  }

  export type NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySector | EnumCompanySectorFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySector[] | ListEnumCompanySectorFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySectorWithAggregatesFilter<$PrismaModel> | $Enums.CompanySector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySectorFilter<$PrismaModel>
    _max?: NestedEnumCompanySectorFilter<$PrismaModel>
  }

  export type NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanySize | EnumCompanySizeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanySize[] | ListEnumCompanySizeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanySizeWithAggregatesFilter<$PrismaModel> | $Enums.CompanySize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanySizeFilter<$PrismaModel>
    _max?: NestedEnumCompanySizeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryFilter<$PrismaModel> | $Enums.DocumentCategory
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentCategory | EnumDocumentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentCategory[] | ListEnumDocumentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DocumentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentCategoryFilter<$PrismaModel>
    _max?: NestedEnumDocumentCategoryFilter<$PrismaModel>
  }

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type NestedEnumContractDurationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableFilter<$PrismaModel> | $Enums.ContractDuration | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractDuration | EnumContractDurationFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractDuration[] | ListEnumContractDurationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractDurationNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractDuration | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractDurationNullableFilter<$PrismaModel>
    _max?: NestedEnumContractDurationNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumLabourProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusFilter<$PrismaModel> | $Enums.LabourProfileStatus
  }

  export type NestedEnumDocumentVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
  }

  export type NestedEnumLabourStageFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourStage | EnumLabourStageFieldRefInput<$PrismaModel>
    in?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourStageFilter<$PrismaModel> | $Enums.LabourStage
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourProfileStatus | EnumLabourProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourProfileStatus[] | ListEnumLabourProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabourProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumLabourProfileStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumLabourStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabourStage | EnumLabourStageFieldRefInput<$PrismaModel>
    in?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabourStage[] | ListEnumLabourStageFieldRefInput<$PrismaModel>
    not?: NestedEnumLabourStageWithAggregatesFilter<$PrismaModel> | $Enums.LabourStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabourStageFilter<$PrismaModel>
    _max?: NestedEnumLabourStageFilter<$PrismaModel>
  }

  export type NestedEnumStageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusFilter<$PrismaModel> | $Enums.StageStatus
  }

  export type NestedEnumStageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StageStatus | EnumStageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StageStatus[] | ListEnumStageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStageStatusWithAggregatesFilter<$PrismaModel> | $Enums.StageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStageStatusFilter<$PrismaModel>
    _max?: NestedEnumStageStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Requirement?: RequirementCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Requirement?: RequirementUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type AgencyCreateWithoutUserInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUserInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUserInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    department?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    Requirement?: RequirementCreateNestedManyWithoutAuditLogsInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    Requirement?: RequirementUncheckedCreateNestedManyWithoutAuditLogsInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogCreateOrConnectWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput>
  }

  export type AuditLogCreateManyPerformedByInputEnvelope = {
    data: AuditLogCreateManyPerformedByInput | AuditLogCreateManyPerformedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    senderId?: string | null
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    recipientId: string
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutOwnerInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
    labourProfile?: LabourProfileCreateNestedOneWithoutDocumentInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutOwnerInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput>
  }

  export type DocumentCreateManyOwnerInputEnvelope = {
    data: DocumentCreateManyOwnerInput | DocumentCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgencyUpsertWithoutUserInput = {
    update: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUserInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    tempPassword?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    altContact?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    resetRequired?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deleteAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletionType?: EnumDeletionTypeNullableFilter<"User"> | $Enums.DeletionType | null
    deletionReason?: StringNullableFilter<"User"> | string | null
    deletionRequestedBy?: StringNullableFilter<"User"> | string | null
    createdById?: StringNullableFilter<"User"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutPerformedByInput, AuditLogUncheckedUpdateWithoutPerformedByInput>
    create: XOR<AuditLogCreateWithoutPerformedByInput, AuditLogUncheckedCreateWithoutPerformedByInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutPerformedByInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutPerformedByInput, AuditLogUncheckedUpdateWithoutPerformedByInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutPerformedByInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutPerformedByInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    affectedFields?: StringNullableListFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    performedById?: StringFilter<"AuditLog"> | string
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOwnerInput, DocumentUncheckedUpdateWithoutOwnerInput>
    create: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOwnerInput, DocumentUncheckedUpdateWithoutOwnerInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOwnerInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    ownerId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    labourProfileId?: StringNullableFilter<"Document"> | string | null
    status?: EnumAccountStatusFilter<"Document"> | $Enums.AccountStatus
    category?: EnumDocumentCategoryFilter<"Document"> | $Enums.DocumentCategory
    requirementId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type RequirementCreateWithoutClientInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutClientInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutClientInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput>
  }

  export type RequirementCreateManyClientInputEnvelope = {
    data: RequirementCreateManyClientInput | RequirementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type RequirementUpsertWithWhereUniqueWithoutClientInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutClientInput, RequirementUncheckedUpdateWithoutClientInput>
    create: XOR<RequirementCreateWithoutClientInput, RequirementUncheckedCreateWithoutClientInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutClientInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutClientInput, RequirementUncheckedUpdateWithoutClientInput>
  }

  export type RequirementUpdateManyWithWhereWithoutClientInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutClientInput>
  }

  export type RequirementScalarWhereInput = {
    AND?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    OR?: RequirementScalarWhereInput[]
    NOT?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    id?: StringFilter<"Requirement"> | string
    clientId?: StringFilter<"Requirement"> | string
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
  }

  export type UserCreateWithoutAgencyProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAgencyProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAgencyProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
  }

  export type JobRoleCreateWithoutAssignedAgencyInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    requirement: RequirementCreateNestedOneWithoutJobRolesInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUncheckedCreateWithoutAssignedAgencyInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleCreateOrConnectWithoutAssignedAgencyInput = {
    where: JobRoleWhereUniqueInput
    create: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput>
  }

  export type JobRoleCreateManyAssignedAgencyInputEnvelope = {
    data: JobRoleCreateManyAssignedAgencyInput | JobRoleCreateManyAssignedAgencyInput[]
    skipDuplicates?: boolean
  }

  export type LabourProfileCreateWithoutAgencyInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileCreateOrConnectWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput>
  }

  export type LabourProfileCreateManyAgencyInputEnvelope = {
    data: LabourProfileCreateManyAgencyInput | LabourProfileCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type LabourAssignmentCreateWithoutAgencyInput = {
    id?: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRole: JobRoleCreateNestedOneWithoutLabourAssignmentInput
    labour: LabourProfileCreateNestedOneWithoutLabourAssignmentInput
  }

  export type LabourAssignmentUncheckedCreateWithoutAgencyInput = {
    id?: string
    jobRoleId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourAssignmentCreateOrConnectWithoutAgencyInput = {
    where: LabourAssignmentWhereUniqueInput
    create: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput>
  }

  export type LabourAssignmentCreateManyAgencyInputEnvelope = {
    data: LabourAssignmentCreateManyAgencyInput | LabourAssignmentCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type JobRoleForwardingCreateWithoutAgencyInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    jobRole: JobRoleCreateNestedOneWithoutForwardingsInput
  }

  export type JobRoleForwardingUncheckedCreateWithoutAgencyInput = {
    id?: string
    jobRoleId: string
    quantity: number
    createdAt?: Date | string
  }

  export type JobRoleForwardingCreateOrConnectWithoutAgencyInput = {
    where: JobRoleForwardingWhereUniqueInput
    create: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput>
  }

  export type JobRoleForwardingCreateManyAgencyInputEnvelope = {
    data: JobRoleForwardingCreateManyAgencyInput | JobRoleForwardingCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgencyProfileInput = {
    update: XOR<UserUpdateWithoutAgencyProfileInput, UserUncheckedUpdateWithoutAgencyProfileInput>
    create: XOR<UserCreateWithoutAgencyProfileInput, UserUncheckedCreateWithoutAgencyProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgencyProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgencyProfileInput, UserUncheckedUpdateWithoutAgencyProfileInput>
  }

  export type UserUpdateWithoutAgencyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type JobRoleUpsertWithWhereUniqueWithoutAssignedAgencyInput = {
    where: JobRoleWhereUniqueInput
    update: XOR<JobRoleUpdateWithoutAssignedAgencyInput, JobRoleUncheckedUpdateWithoutAssignedAgencyInput>
    create: XOR<JobRoleCreateWithoutAssignedAgencyInput, JobRoleUncheckedCreateWithoutAssignedAgencyInput>
  }

  export type JobRoleUpdateWithWhereUniqueWithoutAssignedAgencyInput = {
    where: JobRoleWhereUniqueInput
    data: XOR<JobRoleUpdateWithoutAssignedAgencyInput, JobRoleUncheckedUpdateWithoutAssignedAgencyInput>
  }

  export type JobRoleUpdateManyWithWhereWithoutAssignedAgencyInput = {
    where: JobRoleScalarWhereInput
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyWithoutAssignedAgencyInput>
  }

  export type JobRoleScalarWhereInput = {
    AND?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
    OR?: JobRoleScalarWhereInput[]
    NOT?: JobRoleScalarWhereInput | JobRoleScalarWhereInput[]
    id?: StringFilter<"JobRole"> | string
    requirementId?: StringFilter<"JobRole"> | string
    title?: StringFilter<"JobRole"> | string
    quantity?: IntFilter<"JobRole"> | number
    nationality?: StringFilter<"JobRole"> | string
    startDate?: DateTimeFilter<"JobRole"> | Date | string
    contractDuration?: EnumContractDurationNullableFilter<"JobRole"> | $Enums.ContractDuration | null
    salaryCurrency?: StringNullableFilter<"JobRole"> | string | null
    basicSalary?: FloatFilter<"JobRole"> | number
    foodAllowance?: FloatNullableFilter<"JobRole"> | number | null
    foodProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    housingAllowance?: FloatNullableFilter<"JobRole"> | number | null
    housingProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    transportationAllowance?: FloatNullableFilter<"JobRole"> | number | null
    transportationProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    healthInsurance?: StringFilter<"JobRole"> | string
    mobileAllowance?: FloatNullableFilter<"JobRole"> | number | null
    mobileProvidedByCompany?: BoolFilter<"JobRole"> | boolean
    natureOfWorkAllowance?: FloatNullableFilter<"JobRole"> | number | null
    otherAllowance?: FloatNullableFilter<"JobRole"> | number | null
    ticketFrequency?: StringFilter<"JobRole"> | string
    workLocations?: StringFilter<"JobRole"> | string
    previousExperience?: StringFilter<"JobRole"> | string
    totalExperienceYears?: IntNullableFilter<"JobRole"> | number | null
    preferredAge?: IntNullableFilter<"JobRole"> | number | null
    languageRequirements?: StringNullableListFilter<"JobRole">
    specialRequirements?: StringNullableFilter<"JobRole"> | string | null
    assignedAgencyId?: StringNullableFilter<"JobRole"> | string | null
    agencyStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"JobRole"> | $Enums.RequirementStatus
    needsMoreLabour?: BoolFilter<"JobRole"> | boolean
  }

  export type LabourProfileUpsertWithWhereUniqueWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    update: XOR<LabourProfileUpdateWithoutAgencyInput, LabourProfileUncheckedUpdateWithoutAgencyInput>
    create: XOR<LabourProfileCreateWithoutAgencyInput, LabourProfileUncheckedCreateWithoutAgencyInput>
  }

  export type LabourProfileUpdateWithWhereUniqueWithoutAgencyInput = {
    where: LabourProfileWhereUniqueInput
    data: XOR<LabourProfileUpdateWithoutAgencyInput, LabourProfileUncheckedUpdateWithoutAgencyInput>
  }

  export type LabourProfileUpdateManyWithWhereWithoutAgencyInput = {
    where: LabourProfileScalarWhereInput
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyWithoutAgencyInput>
  }

  export type LabourProfileScalarWhereInput = {
    AND?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
    OR?: LabourProfileScalarWhereInput[]
    NOT?: LabourProfileScalarWhereInput | LabourProfileScalarWhereInput[]
    id?: StringFilter<"LabourProfile"> | string
    name?: StringFilter<"LabourProfile"> | string
    profileImage?: StringNullableFilter<"LabourProfile"> | string | null
    age?: IntFilter<"LabourProfile"> | number
    gender?: EnumGenderFilter<"LabourProfile"> | $Enums.Gender
    nationality?: StringFilter<"LabourProfile"> | string
    email?: StringNullableFilter<"LabourProfile"> | string | null
    phone?: StringNullableFilter<"LabourProfile"> | string | null
    passportNumber?: StringFilter<"LabourProfile"> | string
    passportExpiry?: DateTimeFilter<"LabourProfile"> | Date | string
    passportVerified?: BoolFilter<"LabourProfile"> | boolean
    visaType?: StringNullableFilter<"LabourProfile"> | string | null
    visaExpiry?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    visaVerified?: BoolFilter<"LabourProfile"> | boolean
    medicalReport?: StringNullableFilter<"LabourProfile"> | string | null
    medicalVerified?: BoolFilter<"LabourProfile"> | boolean
    policeClearance?: StringNullableFilter<"LabourProfile"> | string | null
    policeVerified?: BoolFilter<"LabourProfile"> | boolean
    contractVerified?: BoolFilter<"LabourProfile"> | boolean
    status?: EnumLabourProfileStatusFilter<"LabourProfile"> | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFilter<"LabourProfile"> | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFilter<"LabourProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabourProfile"> | Date | string
    documentsSubmittedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    documentsVerifiedAt?: DateTimeNullableFilter<"LabourProfile"> | Date | string | null
    jobRole?: StringNullableFilter<"LabourProfile"> | string | null
    skills?: StringNullableListFilter<"LabourProfile">
    experience?: StringNullableFilter<"LabourProfile"> | string | null
    education?: StringNullableFilter<"LabourProfile"> | string | null
    languages?: StringNullableListFilter<"LabourProfile">
    requirementId?: StringNullableFilter<"LabourProfile"> | string | null
    agencyId?: StringFilter<"LabourProfile"> | string
    currentStage?: EnumLabourStageFilter<"LabourProfile"> | $Enums.LabourStage
  }

  export type LabourAssignmentUpsertWithWhereUniqueWithoutAgencyInput = {
    where: LabourAssignmentWhereUniqueInput
    update: XOR<LabourAssignmentUpdateWithoutAgencyInput, LabourAssignmentUncheckedUpdateWithoutAgencyInput>
    create: XOR<LabourAssignmentCreateWithoutAgencyInput, LabourAssignmentUncheckedCreateWithoutAgencyInput>
  }

  export type LabourAssignmentUpdateWithWhereUniqueWithoutAgencyInput = {
    where: LabourAssignmentWhereUniqueInput
    data: XOR<LabourAssignmentUpdateWithoutAgencyInput, LabourAssignmentUncheckedUpdateWithoutAgencyInput>
  }

  export type LabourAssignmentUpdateManyWithWhereWithoutAgencyInput = {
    where: LabourAssignmentScalarWhereInput
    data: XOR<LabourAssignmentUpdateManyMutationInput, LabourAssignmentUncheckedUpdateManyWithoutAgencyInput>
  }

  export type LabourAssignmentScalarWhereInput = {
    AND?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
    OR?: LabourAssignmentScalarWhereInput[]
    NOT?: LabourAssignmentScalarWhereInput | LabourAssignmentScalarWhereInput[]
    id?: StringFilter<"LabourAssignment"> | string
    jobRoleId?: StringFilter<"LabourAssignment"> | string
    agencyId?: StringFilter<"LabourAssignment"> | string
    labourId?: StringFilter<"LabourAssignment"> | string
    isBackup?: BoolFilter<"LabourAssignment"> | boolean
    agencyStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFilter<"LabourAssignment"> | $Enums.RequirementStatus
    adminFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    clientFeedback?: StringNullableFilter<"LabourAssignment"> | string | null
    signedOfferLetterUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    visaUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    travelDate?: DateTimeNullableFilter<"LabourAssignment"> | Date | string | null
    flightTicketUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    medicalCertificateUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    policeClearanceUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    employmentContractUrl?: StringNullableFilter<"LabourAssignment"> | string | null
    additionalDocumentsUrls?: StringNullableListFilter<"LabourAssignment">
    createdAt?: DateTimeFilter<"LabourAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"LabourAssignment"> | Date | string
  }

  export type JobRoleForwardingUpsertWithWhereUniqueWithoutAgencyInput = {
    where: JobRoleForwardingWhereUniqueInput
    update: XOR<JobRoleForwardingUpdateWithoutAgencyInput, JobRoleForwardingUncheckedUpdateWithoutAgencyInput>
    create: XOR<JobRoleForwardingCreateWithoutAgencyInput, JobRoleForwardingUncheckedCreateWithoutAgencyInput>
  }

  export type JobRoleForwardingUpdateWithWhereUniqueWithoutAgencyInput = {
    where: JobRoleForwardingWhereUniqueInput
    data: XOR<JobRoleForwardingUpdateWithoutAgencyInput, JobRoleForwardingUncheckedUpdateWithoutAgencyInput>
  }

  export type JobRoleForwardingUpdateManyWithWhereWithoutAgencyInput = {
    where: JobRoleForwardingScalarWhereInput
    data: XOR<JobRoleForwardingUpdateManyMutationInput, JobRoleForwardingUncheckedUpdateManyWithoutAgencyInput>
  }

  export type JobRoleForwardingScalarWhereInput = {
    AND?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
    OR?: JobRoleForwardingScalarWhereInput[]
    NOT?: JobRoleForwardingScalarWhereInput | JobRoleForwardingScalarWhereInput[]
    id?: StringFilter<"JobRoleForwarding"> | string
    jobRoleId?: StringFilter<"JobRoleForwarding"> | string
    agencyId?: StringFilter<"JobRoleForwarding"> | string
    quantity?: IntFilter<"JobRoleForwarding"> | number
    createdAt?: DateTimeFilter<"JobRoleForwarding"> | Date | string
  }

  export type UserCreateWithoutAdminProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutDocumentInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutDocumentInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
  }

  export type LabourProfileCreateWithoutDocumentInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateWithoutDocumentInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileCreateOrConnectWithoutDocumentInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutDocumentInput, LabourProfileUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentRequirementCreateWithoutDocumentsInput = {
    id?: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category?: $Enums.DocumentCategory
    createdAt?: Date | string
  }

  export type DocumentRequirementUncheckedCreateWithoutDocumentsInput = {
    id?: string
    role: $Enums.UserRole
    documentType: $Enums.DocumentType
    category?: $Enums.DocumentCategory
    createdAt?: Date | string
  }

  export type DocumentRequirementCreateOrConnectWithoutDocumentsInput = {
    where: DocumentRequirementWhereUniqueInput
    create: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentInput = {
    update: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type UserUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type LabourProfileUpsertWithoutDocumentInput = {
    update: XOR<LabourProfileUpdateWithoutDocumentInput, LabourProfileUncheckedUpdateWithoutDocumentInput>
    create: XOR<LabourProfileCreateWithoutDocumentInput, LabourProfileUncheckedCreateWithoutDocumentInput>
    where?: LabourProfileWhereInput
  }

  export type LabourProfileUpdateToOneWithWhereWithoutDocumentInput = {
    where?: LabourProfileWhereInput
    data: XOR<LabourProfileUpdateWithoutDocumentInput, LabourProfileUncheckedUpdateWithoutDocumentInput>
  }

  export type LabourProfileUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type DocumentRequirementUpsertWithoutDocumentsInput = {
    update: XOR<DocumentRequirementUpdateWithoutDocumentsInput, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    where?: DocumentRequirementWhereInput
  }

  export type DocumentRequirementUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DocumentRequirementWhereInput
    data: XOR<DocumentRequirementUpdateWithoutDocumentsInput, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentRequirementUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRequirementUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateWithoutRequirementInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
    owner: UserCreateNestedOneWithoutDocumentInput
    labourProfile?: LabourProfileCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutRequirementInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput>
  }

  export type DocumentCreateManyRequirementInputEnvelope = {
    data: DocumentCreateManyRequirementInput | DocumentCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutRequirementInput, DocumentUncheckedUpdateWithoutRequirementInput>
    create: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutRequirementInput, DocumentUncheckedUpdateWithoutRequirementInput>
  }

  export type DocumentUpdateManyWithWhereWithoutRequirementInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutRequirementInput>
  }

  export type ClientCreateWithoutRequirementInput = {
    id?: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
  }

  export type ClientUncheckedCreateWithoutRequirementInput = {
    id?: string
    userId: string
    companyName: string
    registrationNo?: string | null
    companySector: $Enums.CompanySector
    companySize: $Enums.CompanySize
    website?: string | null
    address: string
    city: string
    country: string
    postalCode?: string | null
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutRequirementInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRequirementInput, ClientUncheckedCreateWithoutRequirementInput>
  }

  export type JobRoleCreateWithoutRequirementInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    assignedAgency?: AgencyCreateNestedOneWithoutJobRoleInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUncheckedCreateWithoutRequirementInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutJobRoleInput
    forwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleCreateOrConnectWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    create: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput>
  }

  export type JobRoleCreateManyRequirementInputEnvelope = {
    data: JobRoleCreateManyRequirementInput | JobRoleCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutRequirementInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    performedBy: UserCreateNestedOneWithoutAuditLogsInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutRequirementInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogCreateOrConnectWithoutRequirementInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput>
  }

  export type LabourProfileCreateWithoutRequirementInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateWithoutRequirementInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    agencyId: string
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileCreateOrConnectWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput>
  }

  export type LabourProfileCreateManyRequirementInputEnvelope = {
    data: LabourProfileCreateManyRequirementInput | LabourProfileCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type OfferLetterDetailsCreateWithoutRequirementInput = {
    id?: string
    workingHours?: string | null
    workingDays?: string | null
    leaveSalary?: string | null
    endOfService?: string | null
    probationPeriod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferLetterDetailsUncheckedCreateWithoutRequirementInput = {
    id?: string
    workingHours?: string | null
    workingDays?: string | null
    leaveSalary?: string | null
    endOfService?: string | null
    probationPeriod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferLetterDetailsCreateOrConnectWithoutRequirementInput = {
    where: OfferLetterDetailsWhereUniqueInput
    create: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
  }

  export type ClientUpsertWithoutRequirementInput = {
    update: XOR<ClientUpdateWithoutRequirementInput, ClientUncheckedUpdateWithoutRequirementInput>
    create: XOR<ClientCreateWithoutRequirementInput, ClientUncheckedCreateWithoutRequirementInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRequirementInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRequirementInput, ClientUncheckedUpdateWithoutRequirementInput>
  }

  export type ClientUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
  }

  export type ClientUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: EnumCompanySectorFieldUpdateOperationsInput | $Enums.CompanySector
    companySize?: EnumCompanySizeFieldUpdateOperationsInput | $Enums.CompanySize
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleUpsertWithWhereUniqueWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    update: XOR<JobRoleUpdateWithoutRequirementInput, JobRoleUncheckedUpdateWithoutRequirementInput>
    create: XOR<JobRoleCreateWithoutRequirementInput, JobRoleUncheckedCreateWithoutRequirementInput>
  }

  export type JobRoleUpdateWithWhereUniqueWithoutRequirementInput = {
    where: JobRoleWhereUniqueInput
    data: XOR<JobRoleUpdateWithoutRequirementInput, JobRoleUncheckedUpdateWithoutRequirementInput>
  }

  export type JobRoleUpdateManyWithWhereWithoutRequirementInput = {
    where: JobRoleScalarWhereInput
    data: XOR<JobRoleUpdateManyMutationInput, JobRoleUncheckedUpdateManyWithoutRequirementInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutRequirementInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutRequirementInput, AuditLogUncheckedUpdateWithoutRequirementInput>
    create: XOR<AuditLogCreateWithoutRequirementInput, AuditLogUncheckedCreateWithoutRequirementInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutRequirementInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutRequirementInput, AuditLogUncheckedUpdateWithoutRequirementInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutRequirementInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutRequirementInput>
  }

  export type LabourProfileUpsertWithWhereUniqueWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    update: XOR<LabourProfileUpdateWithoutRequirementInput, LabourProfileUncheckedUpdateWithoutRequirementInput>
    create: XOR<LabourProfileCreateWithoutRequirementInput, LabourProfileUncheckedCreateWithoutRequirementInput>
  }

  export type LabourProfileUpdateWithWhereUniqueWithoutRequirementInput = {
    where: LabourProfileWhereUniqueInput
    data: XOR<LabourProfileUpdateWithoutRequirementInput, LabourProfileUncheckedUpdateWithoutRequirementInput>
  }

  export type LabourProfileUpdateManyWithWhereWithoutRequirementInput = {
    where: LabourProfileScalarWhereInput
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyWithoutRequirementInput>
  }

  export type OfferLetterDetailsUpsertWithoutRequirementInput = {
    update: XOR<OfferLetterDetailsUpdateWithoutRequirementInput, OfferLetterDetailsUncheckedUpdateWithoutRequirementInput>
    create: XOR<OfferLetterDetailsCreateWithoutRequirementInput, OfferLetterDetailsUncheckedCreateWithoutRequirementInput>
    where?: OfferLetterDetailsWhereInput
  }

  export type OfferLetterDetailsUpdateToOneWithWhereWithoutRequirementInput = {
    where?: OfferLetterDetailsWhereInput
    data: XOR<OfferLetterDetailsUpdateWithoutRequirementInput, OfferLetterDetailsUncheckedUpdateWithoutRequirementInput>
  }

  export type OfferLetterDetailsUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferLetterDetailsUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null
    workingDays?: NullableStringFieldUpdateOperationsInput | string | null
    leaveSalary?: NullableStringFieldUpdateOperationsInput | string | null
    endOfService?: NullableStringFieldUpdateOperationsInput | string | null
    probationPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateWithoutJobRolesInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementInput
    auditLogs?: AuditLogCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutJobRolesInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutJobRolesInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
  }

  export type AgencyCreateWithoutJobRoleInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutJobRoleInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutJobRoleInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutJobRoleInput, AgencyUncheckedCreateWithoutJobRoleInput>
  }

  export type LabourAssignmentCreateWithoutJobRoleInput = {
    id?: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: AgencyCreateNestedOneWithoutLabourAssignmentInput
    labour: LabourProfileCreateNestedOneWithoutLabourAssignmentInput
  }

  export type LabourAssignmentUncheckedCreateWithoutJobRoleInput = {
    id?: string
    agencyId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourAssignmentCreateOrConnectWithoutJobRoleInput = {
    where: LabourAssignmentWhereUniqueInput
    create: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput>
  }

  export type LabourAssignmentCreateManyJobRoleInputEnvelope = {
    data: LabourAssignmentCreateManyJobRoleInput | LabourAssignmentCreateManyJobRoleInput[]
    skipDuplicates?: boolean
  }

  export type JobRoleForwardingCreateWithoutJobRoleInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    agency: AgencyCreateNestedOneWithoutJobRoleForwardingsInput
  }

  export type JobRoleForwardingUncheckedCreateWithoutJobRoleInput = {
    id?: string
    agencyId: string
    quantity: number
    createdAt?: Date | string
  }

  export type JobRoleForwardingCreateOrConnectWithoutJobRoleInput = {
    where: JobRoleForwardingWhereUniqueInput
    create: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput>
  }

  export type JobRoleForwardingCreateManyJobRoleInputEnvelope = {
    data: JobRoleForwardingCreateManyJobRoleInput | JobRoleForwardingCreateManyJobRoleInput[]
    skipDuplicates?: boolean
  }

  export type RequirementUpsertWithoutJobRolesInput = {
    update: XOR<RequirementUpdateWithoutJobRolesInput, RequirementUncheckedUpdateWithoutJobRolesInput>
    create: XOR<RequirementCreateWithoutJobRolesInput, RequirementUncheckedCreateWithoutJobRolesInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutJobRolesInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutJobRolesInput, RequirementUncheckedUpdateWithoutJobRolesInput>
  }

  export type RequirementUpdateWithoutJobRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementNestedInput
    auditLogs?: AuditLogUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutJobRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput
  }

  export type AgencyUpsertWithoutJobRoleInput = {
    update: XOR<AgencyUpdateWithoutJobRoleInput, AgencyUncheckedUpdateWithoutJobRoleInput>
    create: XOR<AgencyCreateWithoutJobRoleInput, AgencyUncheckedCreateWithoutJobRoleInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutJobRoleInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutJobRoleInput, AgencyUncheckedUpdateWithoutJobRoleInput>
  }

  export type AgencyUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type LabourAssignmentUpsertWithWhereUniqueWithoutJobRoleInput = {
    where: LabourAssignmentWhereUniqueInput
    update: XOR<LabourAssignmentUpdateWithoutJobRoleInput, LabourAssignmentUncheckedUpdateWithoutJobRoleInput>
    create: XOR<LabourAssignmentCreateWithoutJobRoleInput, LabourAssignmentUncheckedCreateWithoutJobRoleInput>
  }

  export type LabourAssignmentUpdateWithWhereUniqueWithoutJobRoleInput = {
    where: LabourAssignmentWhereUniqueInput
    data: XOR<LabourAssignmentUpdateWithoutJobRoleInput, LabourAssignmentUncheckedUpdateWithoutJobRoleInput>
  }

  export type LabourAssignmentUpdateManyWithWhereWithoutJobRoleInput = {
    where: LabourAssignmentScalarWhereInput
    data: XOR<LabourAssignmentUpdateManyMutationInput, LabourAssignmentUncheckedUpdateManyWithoutJobRoleInput>
  }

  export type JobRoleForwardingUpsertWithWhereUniqueWithoutJobRoleInput = {
    where: JobRoleForwardingWhereUniqueInput
    update: XOR<JobRoleForwardingUpdateWithoutJobRoleInput, JobRoleForwardingUncheckedUpdateWithoutJobRoleInput>
    create: XOR<JobRoleForwardingCreateWithoutJobRoleInput, JobRoleForwardingUncheckedCreateWithoutJobRoleInput>
  }

  export type JobRoleForwardingUpdateWithWhereUniqueWithoutJobRoleInput = {
    where: JobRoleForwardingWhereUniqueInput
    data: XOR<JobRoleForwardingUpdateWithoutJobRoleInput, JobRoleForwardingUncheckedUpdateWithoutJobRoleInput>
  }

  export type JobRoleForwardingUpdateManyWithWhereWithoutJobRoleInput = {
    where: JobRoleForwardingScalarWhereInput
    data: XOR<JobRoleForwardingUpdateManyMutationInput, JobRoleForwardingUncheckedUpdateManyWithoutJobRoleInput>
  }

  export type RequirementCreateWithoutLabourProfileInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutLabourProfileInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutLabourProfileInput, RequirementUncheckedCreateWithoutLabourProfileInput>
  }

  export type AgencyCreateWithoutLabourProfileInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    JobRole?: JobRoleCreateNestedManyWithoutAssignedAgencyInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutLabourProfileInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutLabourProfileInput, AgencyUncheckedCreateWithoutLabourProfileInput>
  }

  export type LabourStageHistoryCreateWithoutLabourInput = {
    id?: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LabourStageHistoryUncheckedCreateWithoutLabourInput = {
    id?: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LabourStageHistoryCreateOrConnectWithoutLabourInput = {
    where: LabourStageHistoryWhereUniqueInput
    create: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput>
  }

  export type LabourStageHistoryCreateManyLabourInputEnvelope = {
    data: LabourStageHistoryCreateManyLabourInput | LabourStageHistoryCreateManyLabourInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutLabourProfileInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    performedBy: UserCreateNestedOneWithoutAuditLogsInput
    Requirement?: RequirementCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedById: string
    performedAt?: Date | string
    createdAt?: Date | string
    Requirement?: RequirementUncheckedCreateNestedManyWithoutAuditLogsInput
  }

  export type AuditLogCreateOrConnectWithoutLabourProfileInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput>
  }

  export type DocumentCreateWithoutLabourProfileInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
    owner: UserCreateNestedOneWithoutDocumentInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutLabourProfileInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutLabourProfileInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput>
  }

  export type DocumentCreateManyLabourProfileInputEnvelope = {
    data: DocumentCreateManyLabourProfileInput | DocumentCreateManyLabourProfileInput[]
    skipDuplicates?: boolean
  }

  export type LabourAssignmentCreateWithoutLabourInput = {
    id?: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRole: JobRoleCreateNestedOneWithoutLabourAssignmentInput
    agency: AgencyCreateNestedOneWithoutLabourAssignmentInput
  }

  export type LabourAssignmentUncheckedCreateWithoutLabourInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourAssignmentCreateOrConnectWithoutLabourInput = {
    where: LabourAssignmentWhereUniqueInput
    create: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput>
  }

  export type LabourAssignmentCreateManyLabourInputEnvelope = {
    data: LabourAssignmentCreateManyLabourInput | LabourAssignmentCreateManyLabourInput[]
    skipDuplicates?: boolean
  }

  export type RequirementUpsertWithoutLabourProfileInput = {
    update: XOR<RequirementUpdateWithoutLabourProfileInput, RequirementUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<RequirementCreateWithoutLabourProfileInput, RequirementUncheckedCreateWithoutLabourProfileInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutLabourProfileInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutLabourProfileInput, RequirementUncheckedUpdateWithoutLabourProfileInput>
  }

  export type RequirementUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput
  }

  export type AgencyUpsertWithoutLabourProfileInput = {
    update: XOR<AgencyUpdateWithoutLabourProfileInput, AgencyUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<AgencyCreateWithoutLabourProfileInput, AgencyUncheckedCreateWithoutLabourProfileInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutLabourProfileInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutLabourProfileInput, AgencyUncheckedUpdateWithoutLabourProfileInput>
  }

  export type AgencyUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    JobRole?: JobRoleUpdateManyWithoutAssignedAgencyNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type LabourStageHistoryUpsertWithWhereUniqueWithoutLabourInput = {
    where: LabourStageHistoryWhereUniqueInput
    update: XOR<LabourStageHistoryUpdateWithoutLabourInput, LabourStageHistoryUncheckedUpdateWithoutLabourInput>
    create: XOR<LabourStageHistoryCreateWithoutLabourInput, LabourStageHistoryUncheckedCreateWithoutLabourInput>
  }

  export type LabourStageHistoryUpdateWithWhereUniqueWithoutLabourInput = {
    where: LabourStageHistoryWhereUniqueInput
    data: XOR<LabourStageHistoryUpdateWithoutLabourInput, LabourStageHistoryUncheckedUpdateWithoutLabourInput>
  }

  export type LabourStageHistoryUpdateManyWithWhereWithoutLabourInput = {
    where: LabourStageHistoryScalarWhereInput
    data: XOR<LabourStageHistoryUpdateManyMutationInput, LabourStageHistoryUncheckedUpdateManyWithoutLabourInput>
  }

  export type LabourStageHistoryScalarWhereInput = {
    AND?: LabourStageHistoryScalarWhereInput | LabourStageHistoryScalarWhereInput[]
    OR?: LabourStageHistoryScalarWhereInput[]
    NOT?: LabourStageHistoryScalarWhereInput | LabourStageHistoryScalarWhereInput[]
    id?: StringFilter<"LabourStageHistory"> | string
    labourId?: StringFilter<"LabourStageHistory"> | string
    stage?: EnumLabourStageFilter<"LabourStageHistory"> | $Enums.LabourStage
    status?: EnumStageStatusFilter<"LabourStageHistory"> | $Enums.StageStatus
    notes?: StringNullableFilter<"LabourStageHistory"> | string | null
    documents?: StringNullableListFilter<"LabourStageHistory">
    createdAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    updatedAt?: DateTimeFilter<"LabourStageHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"LabourStageHistory"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutLabourProfileInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutLabourProfileInput, AuditLogUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<AuditLogCreateWithoutLabourProfileInput, AuditLogUncheckedCreateWithoutLabourProfileInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutLabourProfileInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutLabourProfileInput, AuditLogUncheckedUpdateWithoutLabourProfileInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutLabourProfileInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutLabourProfileInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutLabourProfileInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutLabourProfileInput, DocumentUncheckedUpdateWithoutLabourProfileInput>
    create: XOR<DocumentCreateWithoutLabourProfileInput, DocumentUncheckedCreateWithoutLabourProfileInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutLabourProfileInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutLabourProfileInput, DocumentUncheckedUpdateWithoutLabourProfileInput>
  }

  export type DocumentUpdateManyWithWhereWithoutLabourProfileInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutLabourProfileInput>
  }

  export type LabourAssignmentUpsertWithWhereUniqueWithoutLabourInput = {
    where: LabourAssignmentWhereUniqueInput
    update: XOR<LabourAssignmentUpdateWithoutLabourInput, LabourAssignmentUncheckedUpdateWithoutLabourInput>
    create: XOR<LabourAssignmentCreateWithoutLabourInput, LabourAssignmentUncheckedCreateWithoutLabourInput>
  }

  export type LabourAssignmentUpdateWithWhereUniqueWithoutLabourInput = {
    where: LabourAssignmentWhereUniqueInput
    data: XOR<LabourAssignmentUpdateWithoutLabourInput, LabourAssignmentUncheckedUpdateWithoutLabourInput>
  }

  export type LabourAssignmentUpdateManyWithWhereWithoutLabourInput = {
    where: LabourAssignmentScalarWhereInput
    data: XOR<LabourAssignmentUpdateManyMutationInput, LabourAssignmentUncheckedUpdateManyWithoutLabourInput>
  }

  export type JobRoleCreateWithoutLabourAssignmentInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    requirement: RequirementCreateNestedOneWithoutJobRolesInput
    assignedAgency?: AgencyCreateNestedOneWithoutJobRoleInput
    forwardings?: JobRoleForwardingCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUncheckedCreateWithoutLabourAssignmentInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    forwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleCreateOrConnectWithoutLabourAssignmentInput = {
    where: JobRoleWhereUniqueInput
    create: XOR<JobRoleCreateWithoutLabourAssignmentInput, JobRoleUncheckedCreateWithoutLabourAssignmentInput>
  }

  export type AgencyCreateWithoutLabourAssignmentInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    JobRole?: JobRoleCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutLabourAssignmentInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    jobRoleForwardings?: JobRoleForwardingUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutLabourAssignmentInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutLabourAssignmentInput, AgencyUncheckedCreateWithoutLabourAssignmentInput>
  }

  export type LabourProfileCreateWithoutLabourAssignmentInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileUncheckedCreateWithoutLabourAssignmentInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
  }

  export type LabourProfileCreateOrConnectWithoutLabourAssignmentInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutLabourAssignmentInput, LabourProfileUncheckedCreateWithoutLabourAssignmentInput>
  }

  export type JobRoleUpsertWithoutLabourAssignmentInput = {
    update: XOR<JobRoleUpdateWithoutLabourAssignmentInput, JobRoleUncheckedUpdateWithoutLabourAssignmentInput>
    create: XOR<JobRoleCreateWithoutLabourAssignmentInput, JobRoleUncheckedCreateWithoutLabourAssignmentInput>
    where?: JobRoleWhereInput
  }

  export type JobRoleUpdateToOneWithWhereWithoutLabourAssignmentInput = {
    where?: JobRoleWhereInput
    data: XOR<JobRoleUpdateWithoutLabourAssignmentInput, JobRoleUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type JobRoleUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    requirement?: RequirementUpdateOneRequiredWithoutJobRolesNestedInput
    assignedAgency?: AgencyUpdateOneWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    forwardings?: JobRoleForwardingUncheckedUpdateManyWithoutJobRoleNestedInput
  }

  export type AgencyUpsertWithoutLabourAssignmentInput = {
    update: XOR<AgencyUpdateWithoutLabourAssignmentInput, AgencyUncheckedUpdateWithoutLabourAssignmentInput>
    create: XOR<AgencyCreateWithoutLabourAssignmentInput, AgencyUncheckedCreateWithoutLabourAssignmentInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutLabourAssignmentInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutLabourAssignmentInput, AgencyUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type AgencyUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    JobRole?: JobRoleUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    jobRoleForwardings?: JobRoleForwardingUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type LabourProfileUpsertWithoutLabourAssignmentInput = {
    update: XOR<LabourProfileUpdateWithoutLabourAssignmentInput, LabourProfileUncheckedUpdateWithoutLabourAssignmentInput>
    create: XOR<LabourProfileCreateWithoutLabourAssignmentInput, LabourProfileUncheckedCreateWithoutLabourAssignmentInput>
    where?: LabourProfileWhereInput
  }

  export type LabourProfileUpdateToOneWithWhereWithoutLabourAssignmentInput = {
    where?: LabourProfileWhereInput
    data: XOR<LabourProfileUpdateWithoutLabourAssignmentInput, LabourProfileUncheckedUpdateWithoutLabourAssignmentInput>
  }

  export type LabourProfileUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutLabourAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
  }

  export type LabourProfileCreateWithoutStagesInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    auditLogs?: AuditLogCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateWithoutStagesInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutLabourProfileInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileCreateOrConnectWithoutStagesInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutStagesInput, LabourProfileUncheckedCreateWithoutStagesInput>
  }

  export type LabourProfileUpsertWithoutStagesInput = {
    update: XOR<LabourProfileUpdateWithoutStagesInput, LabourProfileUncheckedUpdateWithoutStagesInput>
    create: XOR<LabourProfileCreateWithoutStagesInput, LabourProfileUncheckedCreateWithoutStagesInput>
    where?: LabourProfileWhereInput
  }

  export type LabourProfileUpdateToOneWithWhereWithoutStagesInput = {
    where?: LabourProfileWhereInput
    data: XOR<LabourProfileUpdateWithoutStagesInput, LabourProfileUncheckedUpdateWithoutStagesInput>
  }

  export type LabourProfileUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type RequirementCreateWithoutAuditLogsInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedCreateNestedOneWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutAuditLogsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput>
  }

  export type LabourProfileCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    currentStage?: $Enums.LabourStage
    requirement?: RequirementCreateNestedOneWithoutLabourProfileInput
    agency: AgencyCreateNestedOneWithoutLabourProfileInput
    stages?: LabourStageHistoryCreateNestedManyWithoutLabourInput
    Document?: DocumentCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    agencyId: string
    currentStage?: $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedCreateNestedManyWithoutLabourInput
    Document?: DocumentUncheckedCreateNestedManyWithoutLabourProfileInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutLabourInput
  }

  export type LabourProfileCreateOrConnectWithoutAuditLogsInput = {
    where: LabourProfileWhereUniqueInput
    create: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type RequirementUpsertWithWhereUniqueWithoutAuditLogsInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutAuditLogsInput, RequirementUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<RequirementCreateWithoutAuditLogsInput, RequirementUncheckedCreateWithoutAuditLogsInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutAuditLogsInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutAuditLogsInput, RequirementUncheckedUpdateWithoutAuditLogsInput>
  }

  export type RequirementUpdateManyWithWhereWithoutAuditLogsInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type LabourProfileUpsertWithWhereUniqueWithoutAuditLogsInput = {
    where: LabourProfileWhereUniqueInput
    update: XOR<LabourProfileUpdateWithoutAuditLogsInput, LabourProfileUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<LabourProfileCreateWithoutAuditLogsInput, LabourProfileUncheckedCreateWithoutAuditLogsInput>
  }

  export type LabourProfileUpdateWithWhereUniqueWithoutAuditLogsInput = {
    where: LabourProfileWhereUniqueInput
    data: XOR<LabourProfileUpdateWithoutAuditLogsInput, LabourProfileUncheckedUpdateWithoutAuditLogsInput>
  }

  export type LabourProfileUpdateManyWithWhereWithoutAuditLogsInput = {
    where: LabourProfileScalarWhereInput
    data: XOR<LabourProfileUpdateManyMutationInput, LabourProfileUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type JobRoleCreateWithoutForwardingsInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    requirement: RequirementCreateNestedOneWithoutJobRolesInput
    assignedAgency?: AgencyCreateNestedOneWithoutJobRoleInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleUncheckedCreateWithoutForwardingsInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutJobRoleInput
  }

  export type JobRoleCreateOrConnectWithoutForwardingsInput = {
    where: JobRoleWhereUniqueInput
    create: XOR<JobRoleCreateWithoutForwardingsInput, JobRoleUncheckedCreateWithoutForwardingsInput>
  }

  export type AgencyCreateWithoutJobRoleForwardingsInput = {
    id?: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgencyProfileInput
    JobRole?: JobRoleCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutJobRoleForwardingsInput = {
    id?: string
    userId: string
    agencyName: string
    registrationNo?: string | null
    licenseNumber: string
    licenseExpiry: Date | string
    country: string
    website?: string | null
    address: string
    city: string
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobRole?: JobRoleUncheckedCreateNestedManyWithoutAssignedAgencyInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutAgencyInput
    LabourAssignment?: LabourAssignmentUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutJobRoleForwardingsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutJobRoleForwardingsInput, AgencyUncheckedCreateWithoutJobRoleForwardingsInput>
  }

  export type JobRoleUpsertWithoutForwardingsInput = {
    update: XOR<JobRoleUpdateWithoutForwardingsInput, JobRoleUncheckedUpdateWithoutForwardingsInput>
    create: XOR<JobRoleCreateWithoutForwardingsInput, JobRoleUncheckedCreateWithoutForwardingsInput>
    where?: JobRoleWhereInput
  }

  export type JobRoleUpdateToOneWithWhereWithoutForwardingsInput = {
    where?: JobRoleWhereInput
    data: XOR<JobRoleUpdateWithoutForwardingsInput, JobRoleUncheckedUpdateWithoutForwardingsInput>
  }

  export type JobRoleUpdateWithoutForwardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    requirement?: RequirementUpdateOneRequiredWithoutJobRolesNestedInput
    assignedAgency?: AgencyUpdateOneWithoutJobRoleNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateWithoutForwardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutJobRoleNestedInput
  }

  export type AgencyUpsertWithoutJobRoleForwardingsInput = {
    update: XOR<AgencyUpdateWithoutJobRoleForwardingsInput, AgencyUncheckedUpdateWithoutJobRoleForwardingsInput>
    create: XOR<AgencyCreateWithoutJobRoleForwardingsInput, AgencyUncheckedCreateWithoutJobRoleForwardingsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutJobRoleForwardingsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutJobRoleForwardingsInput, AgencyUncheckedUpdateWithoutJobRoleForwardingsInput>
  }

  export type AgencyUpdateWithoutJobRoleForwardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgencyProfileNestedInput
    JobRole?: JobRoleUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutJobRoleForwardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobRole?: JobRoleUncheckedUpdateManyWithoutAssignedAgencyNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAgencyNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type RequirementCreateWithoutOfferLetterDetailsInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementInput
    jobRoles?: JobRoleCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutOfferLetterDetailsInput = {
    id?: string
    clientId: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobRoles?: JobRoleUncheckedCreateNestedManyWithoutRequirementInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutRequirementInput
    LabourProfile?: LabourProfileUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutOfferLetterDetailsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutOfferLetterDetailsInput, RequirementUncheckedCreateWithoutOfferLetterDetailsInput>
  }

  export type RequirementUpsertWithoutOfferLetterDetailsInput = {
    update: XOR<RequirementUpdateWithoutOfferLetterDetailsInput, RequirementUncheckedUpdateWithoutOfferLetterDetailsInput>
    create: XOR<RequirementCreateWithoutOfferLetterDetailsInput, RequirementUncheckedCreateWithoutOfferLetterDetailsInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutOfferLetterDetailsInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutOfferLetterDetailsInput, RequirementUncheckedUpdateWithoutOfferLetterDetailsInput>
  }

  export type RequirementUpdateWithoutOfferLetterDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutOfferLetterDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    clientProfile?: ClientCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    Document?: DocumentCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
    createdById?: string | null
    clientProfile?: ClientUncheckedCreateNestedOneWithoutUserInput
    agencyProfile?: AgencyUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPerformedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    Document?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    name: string
    email: string
    password: string
    tempPassword?: string | null
    phone?: string | null
    altContact?: string | null
    profilePicture?: string | null
    role: $Enums.UserRole
    status?: $Enums.AccountStatus
    resetRequired?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleteAt?: Date | string | null
    deletionType?: $Enums.DeletionType | null
    deletionReason?: string | null
    deletionRequestedBy?: string | null
  }

  export type AuditLogCreateManyPerformedByInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: string
    entityId: string
    description?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogCreateaffectedFieldsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    senderId?: string | null
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    recipientId: string
    entityType?: string | null
    entityId?: string | null
    isRead?: boolean
    isArchived?: boolean
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    actionText?: string | null
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type DocumentCreateManyOwnerInput = {
    id?: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Document?: DocumentUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    clientProfile?: ClientUncheckedUpdateOneWithoutUserNestedInput
    agencyProfile?: AgencyUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPerformedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tempPassword?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altContact?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    resetRequired?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionType?: NullableEnumDeletionTypeFieldUpdateOperationsInput | $Enums.DeletionType | null
    deletionReason?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUpdateManyWithoutAuditLogsNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUncheckedUpdateManyWithoutAuditLogsNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateManyWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labourProfile?: LabourProfileUpdateOneWithoutDocumentNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateManyClientInput = {
    id?: string
    status?: $Enums.RequirementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleCreateManyAssignedAgencyInput = {
    id?: string
    requirementId: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
  }

  export type LabourProfileCreateManyAgencyInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    requirementId?: string | null
    currentStage?: $Enums.LabourStage
  }

  export type LabourAssignmentCreateManyAgencyInput = {
    id?: string
    jobRoleId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleForwardingCreateManyAgencyInput = {
    id?: string
    jobRoleId: string
    quantity: number
    createdAt?: Date | string
  }

  export type JobRoleUpdateWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    requirement?: RequirementUpdateOneRequiredWithoutJobRolesNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUncheckedUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateManyWithoutAssignedAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabourProfileUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
  }

  export type LabourAssignmentUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRole?: JobRoleUpdateOneRequiredWithoutLabourAssignmentNestedInput
    labour?: LabourProfileUpdateOneRequiredWithoutLabourAssignmentNestedInput
  }

  export type LabourAssignmentUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRole?: JobRoleUpdateOneRequiredWithoutForwardingsNestedInput
  }

  export type JobRoleForwardingUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyRequirementInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    labourProfileId?: string | null
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    uploadedAt?: Date | string
  }

  export type DocumentUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutDocumentNestedInput
    labourProfile?: LabourProfileUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    labourProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleCreateManyRequirementInput = {
    id?: string
    title: string
    quantity: number
    nationality: string
    startDate: Date | string
    contractDuration?: $Enums.ContractDuration | null
    salaryCurrency?: string | null
    basicSalary: number
    foodAllowance?: number | null
    foodProvidedByCompany?: boolean
    housingAllowance?: number | null
    housingProvidedByCompany?: boolean
    transportationAllowance?: number | null
    transportationProvidedByCompany?: boolean
    healthInsurance: string
    mobileAllowance?: number | null
    mobileProvidedByCompany?: boolean
    natureOfWorkAllowance?: number | null
    otherAllowance?: number | null
    ticketFrequency: string
    workLocations: string
    previousExperience: string
    totalExperienceYears?: number | null
    preferredAge?: number | null
    languageRequirements?: JobRoleCreatelanguageRequirementsInput | string[]
    specialRequirements?: string | null
    assignedAgencyId?: string | null
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    needsMoreLabour?: boolean
  }

  export type LabourProfileCreateManyRequirementInput = {
    id?: string
    name: string
    profileImage?: string | null
    age: number
    gender: $Enums.Gender
    nationality: string
    email?: string | null
    phone?: string | null
    passportNumber: string
    passportExpiry: Date | string
    passportVerified?: boolean
    visaType?: string | null
    visaExpiry?: Date | string | null
    visaVerified?: boolean
    medicalReport?: string | null
    medicalVerified?: boolean
    policeClearance?: string | null
    policeVerified?: boolean
    contractVerified?: boolean
    status?: $Enums.LabourProfileStatus
    verificationStatus?: $Enums.DocumentVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documentsSubmittedAt?: Date | string | null
    documentsVerifiedAt?: Date | string | null
    jobRole?: string | null
    skills?: LabourProfileCreateskillsInput | string[]
    experience?: string | null
    education?: string | null
    languages?: LabourProfileCreatelanguagesInput | string[]
    agencyId: string
    currentStage?: $Enums.LabourStage
  }

  export type JobRoleUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    assignedAgency?: AgencyUpdateOneWithoutJobRoleNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutJobRoleNestedInput
    forwardings?: JobRoleForwardingUncheckedUpdateManyWithoutJobRoleNestedInput
  }

  export type JobRoleUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDuration?: NullableEnumContractDurationFieldUpdateOperationsInput | $Enums.ContractDuration | null
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: FloatFieldUpdateOperationsInput | number
    foodAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    foodProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    housingAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    housingProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    transportationAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    transportationProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    healthInsurance?: StringFieldUpdateOperationsInput | string
    mobileAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    mobileProvidedByCompany?: BoolFieldUpdateOperationsInput | boolean
    natureOfWorkAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllowance?: NullableFloatFieldUpdateOperationsInput | number | null
    ticketFrequency?: StringFieldUpdateOperationsInput | string
    workLocations?: StringFieldUpdateOperationsInput | string
    previousExperience?: StringFieldUpdateOperationsInput | string
    totalExperienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    preferredAge?: NullableIntFieldUpdateOperationsInput | number | null
    languageRequirements?: JobRoleUpdatelanguageRequirementsInput | string[]
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    needsMoreLabour?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutLabourProfileNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
  }

  export type LabourAssignmentCreateManyJobRoleInput = {
    id?: string
    agencyId: string
    labourId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobRoleForwardingCreateManyJobRoleInput = {
    id?: string
    agencyId: string
    quantity: number
    createdAt?: Date | string
  }

  export type LabourAssignmentUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutLabourAssignmentNestedInput
    labour?: LabourProfileUpdateOneRequiredWithoutLabourAssignmentNestedInput
  }

  export type LabourAssignmentUncheckedUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    labourId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneRequiredWithoutJobRoleForwardingsNestedInput
  }

  export type JobRoleForwardingUncheckedUpdateWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRoleForwardingUncheckedUpdateManyWithoutJobRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourStageHistoryCreateManyLabourInput = {
    id?: string
    stage: $Enums.LabourStage
    status: $Enums.StageStatus
    notes?: string | null
    documents?: LabourStageHistoryCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DocumentCreateManyLabourProfileInput = {
    id?: string
    ownerId: string
    type: $Enums.DocumentType
    url: string
    status: $Enums.AccountStatus
    category?: $Enums.DocumentCategory
    requirementId?: string | null
    uploadedAt?: Date | string
  }

  export type LabourAssignmentCreateManyLabourInput = {
    id?: string
    jobRoleId: string
    agencyId: string
    isBackup?: boolean
    agencyStatus?: $Enums.RequirementStatus
    adminStatus?: $Enums.RequirementStatus
    clientStatus?: $Enums.RequirementStatus
    adminFeedback?: string | null
    clientFeedback?: string | null
    signedOfferLetterUrl?: string | null
    visaUrl?: string | null
    travelDate?: Date | string | null
    flightTicketUrl?: string | null
    medicalCertificateUrl?: string | null
    policeClearanceUrl?: string | null
    employmentContractUrl?: string | null
    additionalDocumentsUrls?: LabourAssignmentCreateadditionalDocumentsUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabourStageHistoryUpdateWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabourStageHistoryUncheckedUpdateWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LabourStageHistoryUncheckedUpdateManyWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    status?: EnumStageStatusFieldUpdateOperationsInput | $Enums.StageStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: LabourStageHistoryUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    Requirement?: RequirementUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requirement?: RequirementUncheckedUpdateManyWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateManyWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    affectedFields?: AuditLogUpdateaffectedFieldsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: StringFieldUpdateOperationsInput | string
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutDocumentNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutLabourProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    category?: EnumDocumentCategoryFieldUpdateOperationsInput | $Enums.DocumentCategory
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentUpdateWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRole?: JobRoleUpdateOneRequiredWithoutLabourAssignmentNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourAssignmentNestedInput
  }

  export type LabourAssignmentUncheckedUpdateWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAssignmentUncheckedUpdateManyWithoutLabourInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobRoleId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    isBackup?: BoolFieldUpdateOperationsInput | boolean
    agencyStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    clientStatus?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    adminFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    signedOfferLetterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    visaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightTicketUrl?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCertificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    policeClearanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    employmentContractUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalDocumentsUrls?: LabourAssignmentUpdateadditionalDocumentsUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementNestedInput
    jobRoles?: JobRoleUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobRoles?: JobRoleUncheckedUpdateManyWithoutRequirementNestedInput
    LabourProfile?: LabourProfileUncheckedUpdateManyWithoutRequirementNestedInput
    OfferLetterDetails?: OfferLetterDetailsUncheckedUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourProfileUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    requirement?: RequirementUpdateOneWithoutLabourProfileNestedInput
    agency?: AgencyUpdateOneRequiredWithoutLabourProfileNestedInput
    stages?: LabourStageHistoryUpdateManyWithoutLabourNestedInput
    Document?: DocumentUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
    stages?: LabourStageHistoryUncheckedUpdateManyWithoutLabourNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutLabourProfileNestedInput
    LabourAssignment?: LabourAssignmentUncheckedUpdateManyWithoutLabourNestedInput
  }

  export type LabourProfileUncheckedUpdateManyWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    visaType?: NullableStringFieldUpdateOperationsInput | string | null
    visaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visaVerified?: BoolFieldUpdateOperationsInput | boolean
    medicalReport?: NullableStringFieldUpdateOperationsInput | string | null
    medicalVerified?: BoolFieldUpdateOperationsInput | boolean
    policeClearance?: NullableStringFieldUpdateOperationsInput | string | null
    policeVerified?: BoolFieldUpdateOperationsInput | boolean
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLabourProfileStatusFieldUpdateOperationsInput | $Enums.LabourProfileStatus
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentsSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobRole?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LabourProfileUpdateskillsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: LabourProfileUpdatelanguagesInput | string[]
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    agencyId?: StringFieldUpdateOperationsInput | string
    currentStage?: EnumLabourStageFieldUpdateOperationsInput | $Enums.LabourStage
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}